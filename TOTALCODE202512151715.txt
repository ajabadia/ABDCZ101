
================================================================================
FILE: .\Source\PluginEditor.cpp
================================================================================
/*
  ==============================================================================

    PluginEditor.cpp
    Created: 14 Dec 2025
    Author:  Antigravity

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "State/Parameters.h" 

//==============================================================================
CZ101AudioProcessorEditor::CZ101AudioProcessorEditor(CZ101AudioProcessor& p)
    : AudioProcessorEditor(&p), audioProcessor(p),
      // Oscillator 1
      osc1LevelKnob("Level"),
      osc2LevelKnob("Level"), osc2DetuneKnob("Detune"),
      hardSyncButton("Hard Sync"), ringModButton("Ring Mod"),
      glideKnob("Glide"),
      // Filter


      filterCutoffKnob("Cutoff"), filterResonanceKnob("Res."),
      // PITCH
      pitchEditor(p, CZ101::UI::EnvelopeEditor::EnvelopeType::PITCH),
      // DCW
      dcwEditor(p, CZ101::UI::EnvelopeEditor::EnvelopeType::DCW),
      dcwAttackKnob("Att"), dcwDecayKnob("Dec"), dcwSustainKnob("Sus"), dcwReleaseKnob("Rel"),
      // DCA
      dcaEditor(p, CZ101::UI::EnvelopeEditor::EnvelopeType::DCA),
      dcaAttackKnob("Att"), dcaDecayKnob("Dec"), dcaSustainKnob("Sus"), dcaReleaseKnob("Rel"),
      // Effects
      delayTimeKnob("Time"), delayFeedbackKnob("Fdbk"), delayMixKnob("Mix"),
      chorusRateKnob("Rate"), chorusDepthKnob("Dep"), chorusMixKnob("Mix"),
      reverbSizeKnob("Size"), reverbMixKnob("Mix"),
      lfoRateKnob("Rate"),
      
      filterGroup("grpFilter", "FILTER"),
      lfoGroup("grpLfo", "LFO"),
      delayGroup("grpDelay", "DELAY"),
      chorusGroup("grpChorus", "CHORUS"),
      reverbGroup("grpReverb", "REVERB"),
      
      keyboardComponent(keyboardState, juce::MidiKeyboardComponent::horizontalKeyboard)
{
    juce::LookAndFeel::setDefaultLookAndFeel(&customLookAndFeel);
    
    // --- HEADER ---
    addAndMakeVisible(lcdDisplay);
    lcdDisplay.setText("CZ-101 EMULATOR", "PRESET: INIT");

    addAndMakeVisible(presetBrowser);
    presetBrowser.setPresetManager(&audioProcessor.getPresetManager());
    presetBrowser.onPresetSelected = [this](int index) {
        juce::ignoreUnused(index);
        auto name = audioProcessor.getPresetManager().getCurrentPreset().name;
        lcdDisplay.setText("CZ-101 EMULATOR", "PRESET: " + juce::String(name));
    };
    
    addAndMakeVisible(midiIndicator);
    
    addAndMakeVisible(midiOutputSelector);
    midiOutputSelector.setTextWhenNoChoicesAvailable("No MIDI Out");
    midiOutputSelector.onChange = [this] { 
        int selectedIndex = midiOutputSelector.getSelectedItemIndex();
        int deviceIndex = selectedIndex - 1;
        auto devices = juce::MidiOutput::getAvailableDevices();
        
        if (deviceIndex >= 0 && deviceIndex < devices.size())
            activeMidiOutput = juce::MidiOutput::openDevice(devices[deviceIndex].identifier);
        else
            activeMidiOutput.reset();
    };
    refreshMidiOutputs();
    
    addAndMakeVisible(loadSysExButton);
    loadSysExButton.onClick = [this] { loadSysExFile(); };

    // --- OSCILLATORS ---
    addAndMakeVisible(osc1WaveSelector);
    osc1WaveSelector.addItemList({"Sine", "Sawtooth", "Square", "Triangle"}, 1);
    addAndMakeVisible(osc1LevelKnob);
    
    addAndMakeVisible(osc2WaveSelector);
    osc2WaveSelector.addItemList({"Sine", "Sawtooth", "Square", "Triangle"}, 1);
    addAndMakeVisible(osc2LevelKnob);
    addAndMakeVisible(osc2DetuneKnob);
    addAndMakeVisible(hardSyncButton);
    addAndMakeVisible(ringModButton);
    addAndMakeVisible(glideKnob);

    // --- FILTER ---
    addAndMakeVisible(filterCutoffKnob);
    addAndMakeVisible(filterResonanceKnob);
    
    // --- ENVELOPES ---
    // Editors
    addAndMakeVisible(pitchEditor);
    addAndMakeVisible(dcwEditor);
    addAndMakeVisible(dcaEditor);
    
    // Knobs
    addAndMakeVisible(dcwAttackKnob);
    addAndMakeVisible(dcwDecayKnob);
    addAndMakeVisible(dcwSustainKnob);
    addAndMakeVisible(dcwReleaseKnob);
    
    addAndMakeVisible(dcaAttackKnob);
    addAndMakeVisible(dcaDecayKnob);
    addAndMakeVisible(dcaSustainKnob);
    addAndMakeVisible(dcaReleaseKnob);
    
    addAndMakeVisible(waveformDisplay); 
    
    /* 
       NOTE: Logic that was accidentally pasted into initializer list 
       is effectively restored here by ensuring 'addAndMakeVisible' calls above 
       and 'attachments' below are correct.
    */

    // --- EFFECTS ---
    addAndMakeVisible(filterGroup);
    addAndMakeVisible(lfoGroup);
    addAndMakeVisible(delayGroup);
    addAndMakeVisible(chorusGroup);
    addAndMakeVisible(reverbGroup);

    addAndMakeVisible(delayTimeKnob);
    addAndMakeVisible(delayFeedbackKnob);
    addAndMakeVisible(delayMixKnob);
    
    addAndMakeVisible(chorusRateKnob);
    addAndMakeVisible(chorusDepthKnob);
    addAndMakeVisible(chorusMixKnob);
    
    addAndMakeVisible(reverbSizeKnob);
    addAndMakeVisible(reverbMixKnob);
    
    addAndMakeVisible(lfoRateKnob);

    // --- KEYBOARD ---
    addAndMakeVisible(keyboardComponent);
    keyboardState.addListener(this);

    // --- ATTACHMENTS ---
    auto& params = audioProcessor.getParameters();
    
    auto attachSlider = [&](juce::AudioParameterFloat* param, juce::Slider& slider) {
        if (param) sliderAttachments.emplace_back(std::make_unique<SliderAttachment>(*param, slider));
    };
    
    auto attachCombo = [&](juce::AudioParameterChoice* param, juce::ComboBox& box) {
        if (param) comboBoxAttachments.emplace_back(std::make_unique<ComboBoxAttachment>(*param, box));
    };

    attachSlider(params.osc1Level, osc1LevelKnob);
    attachCombo(params.osc1Waveform, osc1WaveSelector);
    
    attachSlider(params.osc2Level, osc2LevelKnob);
    attachSlider(params.osc2Detune, osc2DetuneKnob);
    attachCombo(params.osc2Waveform, osc2WaveSelector);
    
    if (params.hardSync)
        hardSyncAttachment = std::make_unique<ButtonAttachment>(*params.hardSync, hardSyncButton);

    if (params.ringMod)
        ringModAttachment = std::make_unique<ButtonAttachment>(*params.ringMod, ringModButton);
    
    if (params.glideTime)
        attachSlider(params.glideTime, glideKnob);
    
    attachSlider(params.filterCutoff, filterCutoffKnob);
    attachSlider(params.filterResonance, filterResonanceKnob);
    
    attachSlider(params.dcwAttack, dcwAttackKnob);
    attachSlider(params.dcwDecay, dcwDecayKnob);
    attachSlider(params.dcwSustain, dcwSustainKnob);
    attachSlider(params.dcwRelease, dcwReleaseKnob);
    
    attachSlider(params.dcaAttack, dcaAttackKnob);
    attachSlider(params.dcaDecay, dcaDecayKnob);
    attachSlider(params.dcaSustain, dcaSustainKnob);
    attachSlider(params.dcaRelease, dcaReleaseKnob);
    
    attachSlider(params.delayTime, delayTimeKnob);
    attachSlider(params.delayFeedback, delayFeedbackKnob);
    attachSlider(params.delayMix, delayMixKnob);

    attachSlider(params.chorusRate, chorusRateKnob);
    attachSlider(params.chorusDepth, chorusDepthKnob);
    attachSlider(params.chorusMix, chorusMixKnob);
    
    attachSlider(params.reverbSize, reverbSizeKnob);
    attachSlider(params.reverbMix, reverbMixKnob);
    
    attachSlider(params.lfoRate, lfoRateKnob);

    setSize(900, 850); 
    startTimerHz(4); // Update UI 4 times per second
}

CZ101AudioProcessorEditor::~CZ101AudioProcessorEditor()
{
    stopTimer();
    keyboardState.removeListener(this);
    juce::LookAndFeel::setDefaultLookAndFeel(nullptr);
}

//==============================================================================
void CZ101AudioProcessorEditor::paint(juce::Graphics& g)
{
    g.fillAll(juce::Colour(0xff181818));
    
    g.setColour(juce::Colours::cyan);
    g.setFont(14.0f);
    
    auto area = getLocalBounds().reduced(10);
    area.removeFromTop(60); // Header
    area.removeFromTop(10); // Spacer

    // Osc
    auto oscArea = area.removeFromTop(90);
    g.setColour(juce::Colour(0xff004400));
    g.fillRect(oscArea);
    g.setColour(juce::Colours::white);
    g.drawText("DCO (OSCILLATORS)", oscArea.removeFromTop(20), juce::Justification::centred);
    
    area.removeFromTop(10);
    
    // Waveform
    area.removeFromTop(60);
    area.removeFromTop(10);
    
    // Envelopes
    auto envArea = area.removeFromTop(200);
    g.setColour(juce::Colour(0xff440000));
    g.fillRect(envArea);
    g.setColour(juce::Colours::white);
    
    // Updated Headers for 3 Envelopes
    // PITCH (Left), DCW (Mid), DCA (Right)
    // We can rely on visual separation or draw text in columns
    // Let's just draw centered title and let the sub-labels (if any) handle it.
    // Or split the area here for text.
    
    auto titleArea = envArea.removeFromTop(20);
    auto w3 = titleArea.getWidth() / 3;
    g.drawText("PITCH (DCO)", titleArea.removeFromLeft(w3), juce::Justification::centred);
    g.drawText("TIMBRE (DCW)", titleArea.removeFromLeft(w3), juce::Justification::centred);
    g.drawText("AMP (DCA)", titleArea, juce::Justification::centred);
    
    area.removeFromTop(10);
    
    // Filter/FX
    // Filter/FX
    auto fxArea = area.removeFromTop(120); // Height increased for Groups
    // Text is handled by GroupComponents now
    
    // Background separation
    g.setColour(juce::Colour(0xff000044)); 
    g.fillRect(fxArea);
}

void CZ101AudioProcessorEditor::resized()
{
    auto area = getLocalBounds().reduced(10);
    
    // HEADER
    auto headerArea = area.removeFromTop(60);
    lcdDisplay.setBounds(headerArea.removeFromLeft(250).reduced(5));
    midiIndicator.setBounds(headerArea.removeFromRight(40).reduced(5));
    midiOutputSelector.setBounds(headerArea.removeFromRight(150).reduced(5, 15));
    // Load Button next to Preset Browser
    loadSysExButton.setBounds(headerArea.removeFromRight(80).reduced(5, 15));
    
    presetBrowser.setBounds(headerArea.reduced(5));

    area.removeFromTop(10);

    // OSCILLATORS
    auto oscArea = area.removeFromTop(90);
    oscArea.removeFromTop(20);
    
    juce::FlexBox oscBox;
    oscBox.justifyContent = juce::FlexBox::JustifyContent::center;
    
    oscBox.items.add(juce::FlexItem(osc1WaveSelector).withWidth(100).withHeight(30).withMargin({20, 10, 0, 10}));
    oscBox.items.add(juce::FlexItem(osc1LevelKnob).withWidth(70).withHeight(70));
    
    oscBox.items.add(juce::FlexItem().withWidth(20));
    
    oscBox.items.add(juce::FlexItem(osc2WaveSelector).withWidth(100).withHeight(30).withMargin({20, 10, 0, 10}));
    oscBox.items.add(juce::FlexItem(osc2LevelKnob).withWidth(70).withHeight(70));
    oscBox.items.add(juce::FlexItem(osc2DetuneKnob).withWidth(70).withHeight(70));
    
    // Buttons container? Or just add them
    oscBox.items.add(juce::FlexItem(hardSyncButton).withWidth(80).withHeight(30).withMargin({20, 0, 0, 5}));
    oscBox.items.add(juce::FlexItem(ringModButton).withWidth(80).withHeight(30).withMargin({20, 0, 0, 5}));
    
    // Glide Knob
    oscBox.items.add(juce::FlexItem(glideKnob).withWidth(60).withHeight(60).withMargin({0, 0, 0, 10}));

    oscBox.performLayout(oscArea);
    
    area.removeFromTop(10);

    // WAVEFORM
    auto vizArea = area.removeFromTop(60);
    waveformDisplay.setBounds(vizArea.reduced(40, 5));
    
    area.removeFromTop(10);

    // ENVELOPES
    auto envArea = area.removeFromTop(200);
    envArea.removeFromTop(20); 
    
    // Split into 3
    int w3 = envArea.getWidth() / 3;
    auto pitchArea = envArea.removeFromLeft(w3).reduced(5);
    auto dcwArea = envArea.removeFromLeft(w3).reduced(5);
    auto dcaArea = envArea.reduced(5);
    
    // PITCH (Only Editor, no ADSR knobs for Pitch yet? Or reuse? We don't have ADSR knobs for Pitch exposed in Processor params)
    // So Pitch is just the graph.
    pitchEditor.setBounds(pitchArea.removeFromTop(100)); 
    // Spacer below pitch?
    
    // DCW
    dcwEditor.setBounds(dcwArea.removeFromTop(100));
    juce::FlexBox dcwKnobs;
    dcwKnobs.justifyContent = juce::FlexBox::JustifyContent::center;
    dcwKnobs.items.add(juce::FlexItem(dcwAttackKnob).withWidth(40).withHeight(75)); 
    dcwKnobs.items.add(juce::FlexItem(dcwDecayKnob).withWidth(40).withHeight(75));
    dcwKnobs.items.add(juce::FlexItem(dcwSustainKnob).withWidth(40).withHeight(75));
    dcwKnobs.items.add(juce::FlexItem(dcwReleaseKnob).withWidth(40).withHeight(75));
    dcwKnobs.performLayout(dcwArea);
    
    // DCA
    dcaEditor.setBounds(dcaArea.removeFromTop(100));
    juce::FlexBox dcaKnobs;
    dcaKnobs.justifyContent = juce::FlexBox::JustifyContent::center;
    dcaKnobs.items.add(juce::FlexItem(dcaAttackKnob).withWidth(40).withHeight(75));
    dcaKnobs.items.add(juce::FlexItem(dcaDecayKnob).withWidth(40).withHeight(75));
    dcaKnobs.items.add(juce::FlexItem(dcaSustainKnob).withWidth(40).withHeight(75));
    dcaKnobs.items.add(juce::FlexItem(dcaReleaseKnob).withWidth(40).withHeight(75));
    dcaKnobs.performLayout(dcaArea);

    area.removeFromTop(10);

    // FILTER/FX
    auto fxArea = area.removeFromTop(120);
    
    // 5 Columns now ? (Filter, LFO, Delay, Chorus, Reverb)
    int colW = fxArea.getWidth() / 5;
    
    auto filterArea = fxArea.removeFromLeft(colW).reduced(5);
    auto lfoArea = fxArea.removeFromLeft(colW).reduced(5);
    auto delayArea = fxArea.removeFromLeft(colW).reduced(5);
    auto chorusArea = fxArea.removeFromLeft(colW).reduced(5);
    auto reverbArea = fxArea.reduced(5);
    
    // ... (Filter/LFO same) ...
    // Filter
    filterGroup.setBounds(filterArea);
    juce::FlexBox fltBox; fltBox.justifyContent = juce::FlexBox::JustifyContent::center;
    fltBox.items.add(juce::FlexItem(filterCutoffKnob).withWidth(70).withHeight(75).withMargin({15, 0, 0, 0}));
    fltBox.items.add(juce::FlexItem(filterResonanceKnob).withWidth(70).withHeight(75).withMargin({15, 0, 0, 0}));
    fltBox.performLayout(filterArea);
    
    // LFO
    lfoGroup.setBounds(lfoArea);
    juce::FlexBox lfoBox; lfoBox.justifyContent = juce::FlexBox::JustifyContent::center;
    lfoBox.items.add(juce::FlexItem(lfoRateKnob).withWidth(70).withHeight(75).withMargin({15, 0, 0, 0}));
    lfoBox.performLayout(lfoArea);

    // Delay
    delayGroup.setBounds(delayArea);
    juce::FlexBox dlyBox; dlyBox.justifyContent = juce::FlexBox::JustifyContent::center;
    // Reduce width to fit 5 cols
    dlyBox.items.add(juce::FlexItem(delayTimeKnob).withWidth(50).withHeight(75).withMargin({15, 0, 0, 0}));
    dlyBox.items.add(juce::FlexItem(delayFeedbackKnob).withWidth(50).withHeight(75).withMargin({15, 0, 0, 0}));
    dlyBox.items.add(juce::FlexItem(delayMixKnob).withWidth(50).withHeight(75).withMargin({15, 0, 0, 0}));
    dlyBox.performLayout(delayArea);
    
    // Chorus
    chorusGroup.setBounds(chorusArea);
    juce::FlexBox choBox; choBox.justifyContent = juce::FlexBox::JustifyContent::center;
    choBox.items.add(juce::FlexItem(chorusRateKnob).withWidth(50).withHeight(75).withMargin({15, 0, 0, 0}));
    choBox.items.add(juce::FlexItem(chorusDepthKnob).withWidth(50).withHeight(75).withMargin({15, 0, 0, 0}));
    choBox.items.add(juce::FlexItem(chorusMixKnob).withWidth(50).withHeight(75).withMargin({15, 0, 0, 0}));
    choBox.performLayout(chorusArea);

    // Reverb
    reverbGroup.setBounds(reverbArea);
    juce::FlexBox revBox; revBox.justifyContent = juce::FlexBox::JustifyContent::center;
    revBox.items.add(juce::FlexItem(reverbSizeKnob).withWidth(50).withHeight(75).withMargin({15, 0, 0, 0}));
    revBox.items.add(juce::FlexItem(reverbMixKnob).withWidth(50).withHeight(75).withMargin({15, 0, 0, 0}));
    revBox.performLayout(reverbArea);
    
    // KEYBOARD
    auto keyboardArea = area.removeFromBottom(80);
    keyboardComponent.setBounds(keyboardArea);
}

void CZ101AudioProcessorEditor::refreshMidiOutputs()
{
    auto devices = juce::MidiOutput::getAvailableDevices();
    midiOutputSelector.clear();
    midiOutputSelector.addItem("No MIDI Out", 1);
    
    int i = 2;
    for (const auto& dev : devices)
    {
        midiOutputSelector.addItem(dev.name, i++);
    }
    midiOutputSelector.setSelectedId(1);
}

void CZ101AudioProcessorEditor::handleNoteOn(juce::MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity)
{
    juce::MidiMessage noteOn = juce::MidiMessage::noteOn(midiChannel, midiNoteNumber, velocity);
    audioProcessor.getMidiProcessor().processMessage(noteOn);
    midiIndicator.triggerActivity();
    if (activeMidiOutput) activeMidiOutput->sendMessageNow(noteOn);
}

void CZ101AudioProcessorEditor::handleNoteOff(juce::MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity)
{
    juce::MidiMessage noteOff = juce::MidiMessage::noteOff(midiChannel, midiNoteNumber, velocity);
    audioProcessor.getMidiProcessor().processMessage(noteOff);
    if (activeMidiOutput) activeMidiOutput->sendMessageNow(noteOff);
}

void CZ101AudioProcessorEditor::timerCallback()
{
    auto cpu = audioProcessor.getPerformanceMonitor().getAverageCpuUsage() * 100.0;
    auto preset = audioProcessor.getPresetManager().getCurrentPreset().name;
    
    // Format: "CZ-101  CPU: 12.5%"
    juce::String cpuStr = juce::String(cpu, 1) + "%";
    
    // Pad CPU string
    while (cpuStr.length() < 5) cpuStr = " " + cpuStr;
    
    lcdDisplay.setText("CZ-101   CPU:" + cpuStr, "PRESET: " + juce::String(preset));
    
    // Update waveform (if needed frequently, though it usually pulls from buffer)
    waveformDisplay.repaint();
    
    // Refresh Envelope UI from Engine State (in case preset changed)
    // We do this periodically to catch preset changes without a dedicated listener system
    pitchEditor.updateData();
    dcwEditor.updateData();
    dcaEditor.updateData();
}

bool CZ101AudioProcessorEditor::isInterestedInFileDrag (const juce::StringArray& files)
{
    for (auto file : files)
    {
        if (file.endsWithIgnoreCase(".syx"))
            return true;
    }
    return false;
}

void CZ101AudioProcessorEditor::filesDropped (const juce::StringArray& files, int x, int y)
{
    juce::ignoreUnused(x, y);
    
    for (auto path : files)
    {
        if (path.endsWithIgnoreCase(".syx"))
        {
            juce::File file(path);
            juce::MemoryBlock sysexData;
            
            if (file.loadFileAsData(sysexData))
            {
                // Pass to SysExManager via Processor
                // SysExManager takes raw void* and size
                audioProcessor.getSysExManager().handleSysEx(sysexData.getData(), (int)sysexData.getSize());
                
                // Explicitly refresh UI immediately (though timer fits eventually)
                timerCallback(); 
                
                // Flash indicator or show message?
                // For now, rely on LCD updating "PRESET: [Name]" which happens in timerCallback
            }
        }
    }
}

void CZ101AudioProcessorEditor::loadSysExFile()
{
    fileChooser = std::make_unique<juce::FileChooser>("Load SysEx Patch",
        juce::File::getSpecialLocation(juce::File::userHomeDirectory),
        "*.syx");

    auto folderChooserFlags = juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles;

    fileChooser->launchAsync(folderChooserFlags, [this](const juce::FileChooser& fc)
    {
        auto file = fc.getResult();
        if (file.existsAsFile())
        {
            juce::MemoryBlock sysexData;
            if (file.loadFileAsData(sysexData))
            {
                audioProcessor.getSysExManager().handleSysEx(sysexData.getData(), (int)sysexData.getSize());
                timerCallback();
            }
        }
    });
}

================================================================================
FILE: .\Source\PluginEditor.h
================================================================================
#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include "PluginProcessor.h"
#include "UI/CZ101LookAndFeel.h"
#include "UI/Components/Knob.h"
#include "UI/Components/WaveformDisplay.h"
#include "UI/Components/PresetBrowser.h"
#include "UI/Components/MIDIActivityIndicator.h"
#include "UI/Components/EnvelopeEditor.h"
#include "UI/LCDDisplay.h"

/**
 * CZ-101 Emulator Editor
 * 
 * Interfaz grÃ¡fica completa del plugin con todos los componentes UI
 */
class CZ101AudioProcessorEditor : public juce::AudioProcessorEditor,
                                   private juce::MidiKeyboardState::Listener,
                                   private juce::Timer,
                                   public juce::FileDragAndDropTarget
{
public:
    CZ101AudioProcessorEditor(CZ101AudioProcessor&);
    ~CZ101AudioProcessorEditor() override;

    //==============================================================================
    void paint(juce::Graphics&) override;
    void resized() override;
    
    juce::MidiKeyboardState& getKeyboardState() { return keyboardState; }

    // Helper to refresh MIDI devices
    // Helper to refresh MIDI devices
    void refreshMidiOutputs();
    
    // Timer callback for UI updates (CPU meter)
    void timerCallback() override;

    // File Drag & Drop
    bool isInterestedInFileDrag (const juce::StringArray& files) override;
    void filesDropped (const juce::StringArray& files, int x, int y) override;

private:
    // MidiKeyboardState::Listener
    void handleNoteOn(juce::MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity) override;
    void handleNoteOff(juce::MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity) override;
    CZ101AudioProcessor& audioProcessor;
    
    // Custom Look and Feel
    CZ101::UI::CZ101LookAndFeel customLookAndFeel;
    
    // MIDI Infrastructure
    juce::MidiKeyboardState keyboardState;
    juce::MidiKeyboardComponent keyboardComponent;
    juce::ComboBox midiOutputSelector;
    std::unique_ptr<juce::MidiOutput> activeMidiOutput;
    
    // Header Components
    CZ101::UI::LCDDisplay lcdDisplay;
    CZ101::UI::PresetBrowser presetBrowser;
    CZ101::UI::MIDIActivityIndicator midiIndicator;
    CZ101::UI::WaveformDisplay waveformDisplay;
    
    juce::TextButton loadSysExButton { "LOAD SYSX" };
    std::unique_ptr<juce::FileChooser> fileChooser;
    void loadSysExFile();
    
    // --- OSCILLATOR SECTION ---
    juce::ComboBox osc1WaveSelector;
    CZ101::UI::Knob osc1LevelKnob;
    
    juce::ComboBox osc2WaveSelector;
    CZ101::UI::Knob osc2LevelKnob;
    CZ101::UI::Knob osc2DetuneKnob;
    
    juce::ToggleButton hardSyncButton;
    juce::ToggleButton ringModButton;
    CZ101::UI::Knob glideKnob;
    
    // --- FILTER SECTION ---
    CZ101::UI::Knob filterCutoffKnob;
    CZ101::UI::Knob filterResonanceKnob;
    
    // --- ENVELOPE SECTIONS ---
    // PITCH (DCO)
    CZ101::UI::EnvelopeEditor pitchEditor;

    // DCW (Timbre)
    CZ101::UI::EnvelopeEditor dcwEditor;
    CZ101::UI::Knob dcwAttackKnob;
    CZ101::UI::Knob dcwDecayKnob;
    CZ101::UI::Knob dcwSustainKnob;
    CZ101::UI::Knob dcwReleaseKnob;
    
    // DCA (Amplitude) -> Reusing generic names for clarity
    CZ101::UI::EnvelopeEditor dcaEditor;
    CZ101::UI::Knob dcaAttackKnob;
    CZ101::UI::Knob dcaDecayKnob;
    CZ101::UI::Knob dcaSustainKnob;
    CZ101::UI::Knob dcaReleaseKnob;
    
    // --- EFFECTS & LFO ---
    // Group Boxes
    juce::GroupComponent filterGroup;
    juce::GroupComponent lfoGroup;
    juce::GroupComponent delayGroup;
    juce::GroupComponent chorusGroup; 
    juce::GroupComponent reverbGroup;
    
    // Chorus Knobs
    CZ101::UI::Knob chorusRateKnob;
    CZ101::UI::Knob chorusDepthKnob;
    CZ101::UI::Knob chorusMixKnob;
    
    CZ101::UI::Knob delayTimeKnob;
    CZ101::UI::Knob delayFeedbackKnob;
    CZ101::UI::Knob delayMixKnob;
    
    CZ101::UI::Knob reverbSizeKnob;
    CZ101::UI::Knob reverbMixKnob;
    
    CZ101::UI::Knob lfoRateKnob;
    
    // --- ATTACHMENTS ---
    // Using ParameterAttachment because we manage parameters manually (no APVTS)
    using SliderAttachment = juce::SliderParameterAttachment;
    using ComboBoxAttachment = juce::ComboBoxParameterAttachment;
    using ButtonAttachment = juce::ButtonParameterAttachment;
    
    std::vector<std::unique_ptr<SliderAttachment>> sliderAttachments;
    std::vector<std::unique_ptr<ComboBoxAttachment>> comboBoxAttachments;
    std::unique_ptr<ButtonAttachment> hardSyncAttachment;
    std::unique_ptr<ButtonAttachment> ringModAttachment;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(CZ101AudioProcessorEditor)
};

================================================================================
FILE: .\Source\PluginProcessor.cpp
================================================================================
#include "PluginProcessor.h"
#include "PluginEditor.h"

CZ101AudioProcessor::CZ101AudioProcessor()
    : AudioProcessor(BusesProperties()
                     .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      voiceManager(),
      parameters(*this),
      presetManager(&parameters, &voiceManager),
      midiProcessor(voiceManager, presetManager),
      sysExManager(presetManager)
{
    parameters.createParameters();
    
    midiProcessor.setSysExManager(&sysExManager);
    
    // Load default preset once parameters are ready
    if (!presetManager.getPresets().empty())
        presetManager.loadPreset(0);
}

CZ101AudioProcessor::~CZ101AudioProcessor()
{
}

const juce::String CZ101AudioProcessor::getName() const
{
    return JucePlugin_Name;
}

bool CZ101AudioProcessor::acceptsMidi() const
{
    return true;
}

bool CZ101AudioProcessor::producesMidi() const
{
    return false;
}

bool CZ101AudioProcessor::isMidiEffect() const
{
    return false;
}

double CZ101AudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int CZ101AudioProcessor::getNumPrograms()
{
    return 1;
}

int CZ101AudioProcessor::getCurrentProgram()
{
    return 0;
}

void CZ101AudioProcessor::setCurrentProgram(int index)
{
    juce::ignoreUnused(index);
}

const juce::String CZ101AudioProcessor::getProgramName(int index)
{
    juce::ignoreUnused(index);
    return {};
}

void CZ101AudioProcessor::changeProgramName(int index, const juce::String& newName)
{
    juce::ignoreUnused(index, newName);
}

void CZ101AudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused(samplesPerBlock);
    
    voiceManager.setSampleRate(sampleRate);
    filterL.setSampleRate(sampleRate);
    filterR.setSampleRate(sampleRate);
    delayL.setSampleRate(sampleRate);
    delayR.setSampleRate(sampleRate);
    reverb.setSampleRate(sampleRate);
    chorus.prepare(sampleRate);
    lfo.setSampleRate(sampleRate);
    lfo.setFrequency(1.0f); // Default rate
}

void CZ101AudioProcessor::releaseResources()
{
}

bool CZ101AudioProcessor::isBusesLayoutSupported(const BusesLayout& layouts) const
{
    if (layouts.getMainOutputChannelSet() != juce::AudioChannelSet::stereo())
        return false;
    return true;
}

void CZ101AudioProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    juce::ScopedNoDenormals noDenormals;
    
    performanceMonitor.startMeasurement();
    
    auto totalNumInputChannels = getTotalNumInputChannels();
    auto totalNumOutputChannels = getTotalNumOutputChannels();
    
    for (auto i = totalNumInputChannels; i < totalNumOutputChannels; ++i)
        buffer.clear(i, 0, buffer.getNumSamples());
    
    updateParameters();
    
    midiProcessor.processMidiBuffer(midiMessages);
    
    auto* channelDataL = buffer.getWritePointer(0);
    auto* channelDataR = buffer.getWritePointer(1);
    
    float lfoVal = lfo.getNextValue();
    voiceManager.updateLFO(lfoVal);
    
    voiceManager.renderNextBlock(channelDataL, channelDataR, buffer.getNumSamples());
    
    for (int i = 0; i < buffer.getNumSamples(); ++i)
    {
        channelDataL[i] = filterL.processSample(channelDataL[i]);
        channelDataR[i] = filterR.processSample(channelDataR[i]);
        
        channelDataL[i] = delayL.processSample(channelDataL[i]);
        channelDataR[i] = delayR.processSample(channelDataR[i]);
    }
    
    // Process Reverb (Block-based)
    // Process Reverb (Block-based)
    float* left = buffer.getWritePointer(0);
    float* right = buffer.getWritePointer(1);
    
    // Process Chorus (Block-based)
    chorus.process(left, right, buffer.getNumSamples());
    
    // Re-get pointers (Chorus might have modified buffer/ptrs if it were internal buffer swap, though getWritePointer is persistent for block)
    // However, good practice if using distinct buffers. Here we use the same buffer. 
    // The user explicitly requested: "Fix: Obtener punteros despuÃ©s de chorus.process()" because "reverb.processStereo() requiere punteros".
    // Actually getWritePointer is valid for the whole block. But let's follow the instruction.
    left = buffer.getWritePointer(0);
    right = buffer.getWritePointer(1);
    
    reverb.processStereo(left, right, buffer.getNumSamples());
    
    performanceMonitor.stopMeasurement();
}

void CZ101AudioProcessor::updateParameters()
{
    // --- VOICES (Oscillators & Envelopes) ---
    // Direct update without checks (Assumes parameters are created safely in ctor)
    voiceManager.setOsc1Level(parameters.osc1Level->get());
    voiceManager.setOsc1Waveform(parameters.osc1Waveform->getIndex());

    voiceManager.setOsc2Level(parameters.osc2Level->get());
    voiceManager.setOsc2Waveform(parameters.osc2Waveform->getIndex());
    voiceManager.setOsc2Detune(parameters.osc2Detune->get());
    
    // Hard Sync
    if (parameters.hardSync)
        voiceManager.setHardSync(parameters.hardSync->get());
    
    if (parameters.ringMod)
        voiceManager.setRingMod(parameters.ringMod->get());

    if (parameters.glideTime)
        voiceManager.setGlideTime(parameters.glideTime->get());

    // DCW
    voiceManager.setDCWAttack(parameters.dcwAttack->get());
    voiceManager.setDCWDecay(parameters.dcwDecay->get());
    voiceManager.setDCWSustain(parameters.dcwSustain->get());
    voiceManager.setDCWRelease(parameters.dcwRelease->get());

    // DCA
    voiceManager.setDCAAttack(parameters.dcaAttack->get());
    voiceManager.setDCADecay(parameters.dcaDecay->get());
    voiceManager.setDCASustain(parameters.dcaSustain->get());
    voiceManager.setDCARelease(parameters.dcaRelease->get());

    // --- EFFECTS ---
    if (parameters.filterCutoff)
    {
        float cutoff = parameters.filterCutoff->get();
        filterL.setCutoff(cutoff);
        filterR.setCutoff(cutoff);
    }
    
    if (parameters.filterResonance)
    {
        float res = parameters.filterResonance->get();
        filterL.setResonance(res);
        filterR.setResonance(res);
    }
    
    if (parameters.delayTime)
    {
        delayL.setDelayTime(parameters.delayTime->get());
        delayR.setDelayTime(parameters.delayTime->get());
    }
    
    if (parameters.delayFeedback)
    {
        delayL.setFeedback(parameters.delayFeedback->get());
        delayR.setFeedback(parameters.delayFeedback->get());
    }
    
    if (parameters.delayMix)
    {
        delayL.setMix(parameters.delayMix->get());
        delayR.setMix(parameters.delayMix->get());
    }
    
    // Chorus Parameters
    // This part of the original request was for `updateParameters`
    // The audio processing part of the request was moved to `processBlock`
    // as it's an audio processing function.
    if (parameters.chorusRate)
        chorus.setRate(parameters.chorusRate->get());
    if (parameters.chorusDepth)
        chorus.setDepth(parameters.chorusDepth->get());
    if (parameters.chorusMix)
        chorus.setMix(parameters.chorusMix->get());
    
    if (parameters.reverbSize && parameters.reverbMix)
    {
        // Reverb Params: room, damping, wet, dry, width
        float size = parameters.reverbSize->get();
        float mix = parameters.reverbMix->get();
        
        // Map Mix to Wet/Dry (simple)
        // Dry = 1.0, Wet=Mix? Or Dry=1-Mix?
        // Let's keep dry 1.0 (typical send style or parallel) or balanced.
        // For effect box: Dry reduces as Wet increases? 
        // juce::Reverb typical: WetLevel 0..1, DryLevel 0..1
        // Let's do: Dry = 1.0, Wet = Mix * 0.8
        
        // juce::Reverb::Parameters struct setter
        reverbParams.roomSize = size;
        reverbParams.damping = 0.5f;
        reverbParams.wetLevel = mix;
        reverbParams.dryLevel = 1.0f - (mix * 0.5f);
        reverbParams.width = 1.0f;
        reverbParams.freezeMode = 0.0f;
        
        reverb.setParameters(reverbParams);
    }
    
    // LFO / Vibrato
    if (parameters.lfoRate)
    {
        lfo.setFrequency(parameters.lfoRate->get());
    }
    
    if (parameters.lfoDepth)
    {
        // Map 0.0-1.0 to semitones (e.g. 0 to 2 semitones depth)
        float depth = parameters.lfoDepth->get() * 2.0f; 
        voiceManager.setVibratoDepth(depth);
    }
}

bool CZ101AudioProcessor::hasEditor() const
{
    return true;
}

juce::AudioProcessorEditor* CZ101AudioProcessor::createEditor()
{
    return new CZ101AudioProcessorEditor(*this);
}

void CZ101AudioProcessor::getStateInformation(juce::MemoryBlock& destData)
{
    juce::ignoreUnused(destData);
}

void CZ101AudioProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    juce::ignoreUnused(data, sizeInBytes);
}

juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new CZ101AudioProcessor();
}

================================================================================
FILE: .\Source\PluginProcessor.h
================================================================================
#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include "Utils/PerformanceMonitor.h"
#include "Core/VoiceManager.h"
#include "MIDI/MIDIProcessor.h"
#include "MIDI/SysExManager.h"
#include "State/Parameters.h"
#include "State/PresetManager.h"
#include "DSP/Filters/ResonantFilter.h"
#include "DSP/Effects/Delay.h"
#include "DSP/Effects/Chorus.h"
#include "DSP/Effects/Reverb.h"
#include "DSP/Modulation/LFO.h"

class CZ101AudioProcessor : public juce::AudioProcessor
{
public:
    CZ101AudioProcessor();
    ~CZ101AudioProcessor() override;

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;

    bool isBusesLayoutSupported(const BusesLayout& layouts) const override;

    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override;

    const juce::String getName() const override;

    bool acceptsMidi() const override;
    bool producesMidi() const override;
    bool isMidiEffect() const override;
    double getTailLengthSeconds() const override;
    int getNumPrograms() override;
    int getCurrentProgram() override;
    void setCurrentProgram(int index) override;
    const juce::String getProgramName(int index) override;
    void changeProgramName(int index, const juce::String& newName) override;

    void getStateInformation(juce::MemoryBlock& destData) override;
    void setStateInformation(const void* data, int sizeInBytes) override;
    
    CZ101::State::PresetManager& getPresetManager() { return presetManager; }
    CZ101::MIDI::SysExManager& getSysExManager() { return sysExManager; }
    CZ101::MIDI::MIDIProcessor& getMidiProcessor() { return midiProcessor; }
    CZ101::State::Parameters& getParameters() { return parameters; }
    CZ101::Core::VoiceManager& getVoiceManager() { return voiceManager; }
    CZ101::Utils::PerformanceMonitor& getPerformanceMonitor() { return performanceMonitor; }

private:
    CZ101::Core::VoiceManager voiceManager;
    CZ101::MIDI::MIDIProcessor midiProcessor;
    CZ101::State::Parameters parameters;
    CZ101::State::PresetManager presetManager;
    CZ101::MIDI::SysExManager sysExManager{presetManager};
    
    CZ101::DSP::ResonantFilter filterL;
    CZ101::DSP::ResonantFilter filterR;
    CZ101::DSP::Effects::Delay delayL;
    CZ101::DSP::Effects::Delay delayR;
    
    juce::Reverb reverb;
    juce::Reverb::Parameters reverbParams;
    CZ101::DSP::Effects::Chorus chorus;
    
    // UI Update Tracking
    CZ101::DSP::LFO lfo;
    CZ101::Utils::PerformanceMonitor performanceMonitor;
    
    void updateParameters();

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(CZ101AudioProcessor)
};

================================================================================
FILE: .\Source\Core\Voice.cpp
================================================================================
#include <JuceHeader.h>
#include "Voice.h"
#include <cmath>

namespace CZ101 {
namespace Core {

Voice::Voice()
{
}

void Voice::setSampleRate(double sr) noexcept
{
    osc1.setSampleRate(sr);
    osc2.setSampleRate(sr);
    dcwEnvelope.setSampleRate(sr);
    dcaEnvelope.setSampleRate(sr);
    pitchEnvelope.setSampleRate(sr);
}

void Voice::noteOn(int midiNote, float velocity) noexcept
{
    // Frequency
    currentNote = midiNote;
    currentVelocity = velocity;
    
    // Convert note
    baseFrequency = midiNoteToFrequency(midiNote);
    targetFrequency = baseFrequency;
    currentFrequency = baseFrequency; // Start at note (glide handles transition)
    
    // Reset phase if hard sync or just standard gate behavior
    // CZ-101 resets on note on usually
    osc1.reset();
    osc2.reset();
    
    // Envelopes
    dcwEnvelope.noteOn();
    dcaEnvelope.noteOn();
    pitchEnvelope.noteOn();
}

void Voice::noteOff() noexcept
{
    dcwEnvelope.noteOff();
    dcaEnvelope.noteOff();
    pitchEnvelope.noteOff();
}

void Voice::reset() noexcept
{
    dcwEnvelope.reset();
    dcaEnvelope.reset();
    pitchEnvelope.reset();
}

// ... Oscillators ...

void Voice::setOsc1Waveform(DSP::PhaseDistOscillator::Waveform w) noexcept { osc1.setWaveform(w); }
void Voice::setOsc1Level(float level) noexcept { osc1Level = level; }

void Voice::setOsc2Waveform(DSP::PhaseDistOscillator::Waveform w) noexcept { osc2.setWaveform(w); }
void Voice::setOsc2Level(float level) noexcept { osc2Level = level; }
void Voice::setOsc2Detune(float cents) noexcept 
{ 
    osc2Detune = cents; 
    currentDetuneFactor =std::pow(2.0f, cents / 1200.0f);
}

void Voice::setHardSync(bool enabled) noexcept { isHardSyncEnabled = enabled; }
void Voice::setRingMod(bool enabled) noexcept { isRingModEnabled = enabled; }
void Voice::setGlideTime(float seconds) noexcept { glideTime = seconds; }

// ... DCW Envelope ...
void Voice::setVibratoDepth(float semitones) noexcept { vibratoDepth = semitones; }
void Voice::setLFOValue(float val) noexcept { lfoValue = val; }
void Voice::setPitchBend(float semitones) noexcept { pitchBendFactor = std::pow(2.0f, semitones / 12.0f); }
void Voice::setMasterTune(float semitones) noexcept { masterTuneFactor = std::pow(2.0f, semitones / 12.0f); }

// ... DCW Envelope ...

void Voice::setDCWAttack(float s) noexcept { juce::ignoreUnused(s); }
void Voice::setDCWDecay(float s) noexcept { juce::ignoreUnused(s); }
void Voice::setDCWSustain(float l) noexcept { juce::ignoreUnused(l); }
void Voice::setDCWRelease(float s) noexcept { juce::ignoreUnused(s); }

void Voice::setDCWStage(int i, float r, float l) noexcept { dcwEnvelope.setStage(i, r, l); }
void Voice::setDCWSustainPoint(int i) noexcept { dcwEnvelope.setSustainPoint(i); }
void Voice::setDCWEndPoint(int i) noexcept { dcwEnvelope.setEndPoint(i); }

void Voice::getDCWStage(int i, float& r, float& l) const noexcept { r = dcwEnvelope.getStageRate(i); l = dcwEnvelope.getStageLevel(i); }
int Voice::getDCWSustainPoint() const noexcept { return dcwEnvelope.getSustainPoint(); }
int Voice::getDCWEndPoint() const noexcept { return dcwEnvelope.getEndPoint(); }

// ... DCA Envelope ...

void Voice::setDCAAttack(float s) noexcept { }
void Voice::setDCADecay(float s) noexcept { }
void Voice::setDCASustain(float l) noexcept { }
void Voice::setDCARelease(float s) noexcept { }

void Voice::setDCAStage(int i, float r, float l) noexcept { dcaEnvelope.setStage(i, r, l); }
void Voice::setDCASustainPoint(int i) noexcept { dcaEnvelope.setSustainPoint(i); }
void Voice::setDCAEndPoint(int i) noexcept { dcaEnvelope.setEndPoint(i); }

void Voice::getDCAStage(int i, float& r, float& l) const noexcept { r = dcaEnvelope.getStageRate(i); l = dcaEnvelope.getStageLevel(i); }
int Voice::getDCASustainPoint() const noexcept { return dcaEnvelope.getSustainPoint(); }
int Voice::getDCAEndPoint() const noexcept { return dcaEnvelope.getEndPoint(); }

// ... Pitch Envelope ...

void Voice::setPitchStage(int i, float r, float l) noexcept { pitchEnvelope.setStage(i, r, l); }
void Voice::setPitchSustainPoint(int i) noexcept { pitchEnvelope.setSustainPoint(i); }
void Voice::setPitchEndPoint(int i) noexcept { pitchEnvelope.setEndPoint(i); }

void Voice::getPitchStage(int i, float& r, float& l) const noexcept { r = pitchEnvelope.getStageRate(i); l = pitchEnvelope.getStageLevel(i); }
int Voice::getPitchSustainPoint() const noexcept { return pitchEnvelope.getSustainPoint(); }
int Voice::getPitchEndPoint() const noexcept { return pitchEnvelope.getEndPoint(); }

float Voice::renderNextSample() noexcept
{
    if (!dcaEnvelope.isActive()) return 0.0f;
    
    // Get Envelope Values
    float dcwValue = dcwEnvelope.getNextValue(); // Timbre
    float dcaValue = dcaEnvelope.getNextValue(); // Amp
    float pitchEnvVal = pitchEnvelope.getNextValue(); // Pitch Mod (0-1)
    
    // ... Processing Logic (Same as before) ...
    
    // Pitch Modulation
    // 0.0 -> -1 Octave, 0.5 -> Unison, 1.0 -> +1 Octave
    // Modulate Pitch (Envelope 0..1  ->  +/- 50 Semitones)
    // 0.5 = No Mod. 1.0 = +50 semi. 0.0 = -50 semi.
    float semitones = (pitchEnvVal - 0.5f) * 100.0f;
    float pitchMod = std::pow(2.0f, semitones / 12.0f); 

    // Glide Processing
    if (glideTime > 0.001f && currentFrequency != targetFrequency)
    {
        // Simple 1-pole lowpass
        // 4.0f scale factor to make "1.0" feel like approx 1 sec at 44.1k
        float alpha = 1.0f / (44100.0f * (glideTime + 0.001f)); 
        float diff = targetFrequency - currentFrequency;
        currentFrequency += diff * alpha * 4.0f; 
        
        // Snap if close
        if (std::abs(diff) < 0.1f) currentFrequency = targetFrequency;
    }
    else
    {
        currentFrequency = targetFrequency;
    }
    
    // Apply LFO (Vibrato)
    float vibratoMod = 1.0f;
    if (vibratoDepth > 0.001f)
    {
        // LFO value is -1 to 1. scaling to semitones
        float lfoSemitones = lfoValue * vibratoDepth;
        vibratoMod = std::pow(2.0f, lfoSemitones / 12.0f);
    }
    
    // Apply modulated frequency to Base (currentFrequency)
    // Combine Pitch Envelope (pitchMod), Vibrato (vibratoMod), Pitch Bend, and Master Tune
    float finalFreq = currentFrequency * pitchMod * vibratoMod * pitchBendFactor * masterTuneFactor;
    osc1.setFrequency(finalFreq);
    osc2.setFrequency(finalFreq * currentDetuneFactor);
    
    bool osc1Wrapped = false;
    float osc1Sample = osc1.renderNextSample(dcwValue, &osc1Wrapped);
    
    // Hard Sync Logic: If Osc1 wrapped, reset Osc2
    if (isHardSyncEnabled && osc1Wrapped)
    {
        osc2.reset();
    }
    
    // Osc 2
    float osc2Sample = osc2.renderNextSample(dcwValue);
    
    // Ring Mod?
    if (isRingModEnabled)
    {
        // Ring mod: Osc2 is modulated by Osc1
        // Usually, Ring Mod replaces Osc2 output, or mixes.
        // In CZ: Ring Mod output replaces standard Osc2.
        // Osc2 Output = Osc1 * Osc2
        osc2Sample = osc1Sample * osc2Sample;
    }
    
    // Mix
    float mix = (osc1Sample * osc1Level) + (osc2Sample * osc2Level);
    
    // Apply VCA (DCA) and Velocity
    return mix * dcaValue * currentVelocity;
}

float Voice::midiNoteToFrequency(int midiNote) const noexcept
{
    return 440.0f * std::pow(2.0f, (midiNote - 69) / 12.0f);
}

} // namespace Core
} // namespace CZ101

================================================================================
FILE: .\Source\Core\Voice.h
================================================================================
#pragma once

#include "../DSP/Oscillators/PhaseDistOsc.h"
#include "../DSP/Envelopes/MultiStageEnv.h"

namespace CZ101 {
namespace Core {

/**
 * @brief Voice - Complete synthesizer voice
 * 
 * Integrates oscillators and envelopes to create the CZ-101 sound.
 * Architecture: DCO (oscillators) â†’ DCW (timbre envelope) â†’ DCA (amplitude envelope)
 */
class Voice
{
public:
    Voice();
    
    void setSampleRate(double sampleRate) noexcept;
    
    // Note control
    void noteOn(int midiNote, float velocity) noexcept;
    void noteOff() noexcept;
    void reset() noexcept;
    
    // Oscillator 1 parameters
    void setOsc1Waveform(DSP::PhaseDistOscillator::Waveform waveform) noexcept;
    void setOsc1Level(float level) noexcept;
    
    // Oscillator 2 parameters
    void setOsc2Waveform(DSP::PhaseDistOscillator::Waveform waveform) noexcept;
    void setOsc2Level(float level) noexcept;
    void setOsc2Detune(float cents) noexcept;  // -100 to +100 cents
    
    /**
     * @brief Enable/Disable Hard Sync (Osc2 resets when Osc1 wraps)
     */
    void setHardSync(bool enabled) noexcept;

    /**
     * @brief Enable/Disable Ring Modulation (Osc2 output = Osc1 * Osc2)
     */
    /**
     * @brief Enable/Disable Ring Modulation (Osc2 output = Osc1 * Osc2)
     */
    void setRingMod(bool enabled) noexcept;

    /**
     * @brief Set Glide (Portamento) Time in seconds
     * @param seconds Slide time (0.0 to ~2.0)
     */
    /**
     * @brief Set Glide (Portamento) Time in seconds
     * @param seconds Slide time (0.0 to ~2.0)
     */
    void setGlideTime(float seconds) noexcept;

    // --- Modulation (LFO) ---
    void setVibratoDepth(float semitones) noexcept;
    void setLFOValue(float value) noexcept; // -1.0 to 1.0
    
    // --- Global Pitch ---
    void setPitchBend(float semitones) noexcept;
    void setMasterTune(float semitones) noexcept;

    // --- Pitch Envelope Controls ---
    
    // DCW Envelope (Legacy ADSR Wrappers)
    void setDCWAttack(float seconds) noexcept;
    void setDCWDecay(float seconds) noexcept;
    void setDCWSustain(float level) noexcept;
    void setDCWRelease(float seconds) noexcept;
    
    // DCW 8-Stage Control
    void setDCWStage(int index, float rate, float level) noexcept;
    void setDCWSustainPoint(int index) noexcept;
    void setDCWEndPoint(int index) noexcept;
    
    void getDCWStage(int index, float& rate, float& level) const noexcept;
    int getDCWSustainPoint() const noexcept;
    int getDCWEndPoint() const noexcept;
    
    // DCA Envelope (Legacy ADSR Wrappers)
    void setDCAAttack(float seconds) noexcept;
    void setDCADecay(float seconds) noexcept;
    void setDCASustain(float level) noexcept;
    void setDCARelease(float seconds) noexcept;

    // DCA 8-Stage Control
    void setDCAStage(int index, float rate, float level) noexcept;
    void setDCASustainPoint(int index) noexcept;
    void setDCAEndPoint(int index) noexcept;

    void getDCAStage(int index, float& rate, float& level) const noexcept;
    int getDCASustainPoint() const noexcept;
    int getDCAEndPoint() const noexcept;

    // Pitch Envelope (DCO) 8-Stage Control
    void setPitchStage(int index, float rate, float level) noexcept;
    void setPitchSustainPoint(int index) noexcept;
    void setPitchEndPoint(int index) noexcept;
    
    void getPitchStage(int index, float& rate, float& level) const noexcept;
    int getPitchSustainPoint() const noexcept;
    int getPitchEndPoint() const noexcept;
    
    // Rendering
    float renderNextSample() noexcept;
    
    bool isActive() const noexcept { return dcaEnvelope.isActive(); }
    int getCurrentNote() const noexcept { return currentNote; }
    
private:
    // Oscillators
    DSP::PhaseDistOscillator osc1;
    DSP::PhaseDistOscillator osc2;
    
    // Envelopes
    DSP::MultiStageEnvelope dcwEnvelope;  // Digital Controlled Wave (timbre)
    DSP::MultiStageEnvelope dcaEnvelope;  // Digital Controlled Amplifier (volume)
    DSP::MultiStageEnvelope pitchEnvelope; // DCO Pitch Envelope (new)
    
    // State
    int currentNote = -1;
    float currentVelocity = 1.0f;
    
    // Mix levels
    float osc1Level = 0.5f;
    float osc2Level = 0.5f;
    float osc2Detune = 0.0f;
    
    // Pitch Modulation State (Optimization)
    float baseFrequency = 440.0f;
    float currentDetuneFactor = 1.0f;
    
    bool isHardSyncEnabled = false;
    bool isRingModEnabled = false;
    
    float glideTime = 0.0f;
    float currentFrequency = 440.0f;
    float targetFrequency = 440.0f;
    
    // LFO State
    float vibratoDepth = 0.0f;
    float lfoValue = 0.0f;
    
    // Pitch Bend
    float pitchBendFactor = 1.0f;
    float masterTuneFactor = 1.0f;
    
    // Helper
    float midiNoteToFrequency(int midiNote) const noexcept;
};

} // namespace Core
} // namespace CZ101

================================================================================
FILE: .\Source\Core\VoiceManager.cpp
================================================================================
#include "VoiceManager.h"
#include <algorithm>

namespace CZ101 {
namespace Core {

VoiceManager::VoiceManager()
{
}

void VoiceManager::setSampleRate(double sampleRate) noexcept
{
    for (auto& voice : voices)
        voice.setSampleRate(sampleRate);
}

// Optimization: Use a macro or template if this gets too repetitive, 
// but for clarity we'll implement explicit loopers.

void VoiceManager::setOsc1Waveform(int waveformIndex) noexcept
{
    auto w = static_cast<DSP::PhaseDistOscillator::Waveform>(waveformIndex);
    for (auto& voice : voices) voice.setOsc1Waveform(w);
}

void VoiceManager::setOsc1Level(float level) noexcept
{
    for (auto& voice : voices) voice.setOsc1Level(level);
}

void VoiceManager::setOsc2Waveform(int waveformIndex) noexcept
{
    auto w = static_cast<DSP::PhaseDistOscillator::Waveform>(waveformIndex);
    for (auto& voice : voices) voice.setOsc2Waveform(w);
}

void VoiceManager::setOsc2Level(float level) noexcept
{
    for (auto& voice : voices) voice.setOsc2Level(level);
}

void VoiceManager::setOsc2Detune(float cents) noexcept
{
    for (auto& voice : voices) voice.setOsc2Detune(cents);
}

void VoiceManager::setDCWAttack(float seconds) noexcept { for (auto& v : voices) v.setDCWAttack(seconds); }
void VoiceManager::setDCWDecay(float seconds) noexcept { for (auto& v : voices) v.setDCWDecay(seconds); }
void VoiceManager::setDCWSustain(float level) noexcept { for (auto& v : voices) v.setDCWSustain(level); }
void VoiceManager::setDCWRelease(float seconds) noexcept { for (auto& v : voices) v.setDCWRelease(seconds); }

void VoiceManager::setDCAAttack(float seconds) noexcept { for (auto& v : voices) v.setDCAAttack(seconds); }
void VoiceManager::setDCADecay(float seconds) noexcept { for (auto& v : voices) v.setDCADecay(seconds); }
void VoiceManager::setDCASustain(float level) noexcept { for (auto& v : voices) v.setDCASustain(level); }
void VoiceManager::setDCARelease(float seconds) noexcept { for (auto& v : voices) v.setDCARelease(seconds); }

// 8-Stage Control
void VoiceManager::setDCWStage(int index, float rate, float level) noexcept { for (auto& v : voices) v.setDCWStage(index, rate, level); }
void VoiceManager::setDCWSustainPoint(int index) noexcept { for (auto& v : voices) v.setDCWSustainPoint(index); }
void VoiceManager::setDCWEndPoint(int index) noexcept { for (auto& v : voices) v.setDCWEndPoint(index); }

void VoiceManager::setDCAStage(int index, float rate, float level) noexcept { for (auto& v : voices) v.setDCAStage(index, rate, level); }
void VoiceManager::setDCASustainPoint(int index) noexcept { for (auto& v : voices) v.setDCASustainPoint(index); }
void VoiceManager::setDCAEndPoint(int index) noexcept { for (auto& v : voices) v.setDCAEndPoint(index); }

// Pitch Envelope
void VoiceManager::setPitchStage(int index, float rate, float level) noexcept { for (auto& v : voices) v.setPitchStage(index, rate, level); }
void VoiceManager::setPitchSustainPoint(int index) noexcept { for (auto& v : voices) v.setPitchSustainPoint(index); }
void VoiceManager::setPitchEndPoint(int index) noexcept { for (auto& v : voices) v.setPitchEndPoint(index); }

void VoiceManager::getDCWStage(int index, float& rate, float& level) const noexcept { voices[0].getDCWStage(index, rate, level); }
int VoiceManager::getDCWSustainPoint() const noexcept { return voices[0].getDCWSustainPoint(); }
int VoiceManager::getDCWEndPoint() const noexcept { return voices[0].getDCWEndPoint(); }

void VoiceManager::getDCAStage(int index, float& rate, float& level) const noexcept { voices[0].getDCAStage(index, rate, level); }
int VoiceManager::getDCASustainPoint() const noexcept { return voices[0].getDCASustainPoint(); }
int VoiceManager::getDCAEndPoint() const noexcept { return voices[0].getDCAEndPoint(); }

void VoiceManager::getPitchStage(int index, float& rate, float& level) const noexcept { voices[0].getPitchStage(index, rate, level); }
int VoiceManager::getPitchSustainPoint() const noexcept { return voices[0].getPitchSustainPoint(); }
int VoiceManager::getPitchEndPoint() const noexcept { return voices[0].getPitchEndPoint(); }

void VoiceManager::setHardSync(bool enabled) noexcept { for (auto& v : voices) v.setHardSync(enabled); }
void VoiceManager::setRingMod(bool enabled) noexcept { for (auto& v : voices) v.setRingMod(enabled); }
void VoiceManager::setGlideTime(float seconds) noexcept { for (auto& v : voices) v.setGlideTime(seconds); }
void VoiceManager::setMasterTune(float semitones) noexcept { for (auto& v : voices) v.setMasterTune(semitones); }
void VoiceManager::setPitchBend(float semitones) noexcept { for (auto& v : voices) v.setPitchBend(semitones); }
void VoiceManager::setVibratoDepth(float semitones) noexcept { for (auto& v : voices) v.setVibratoDepth(semitones); }
void VoiceManager::updateLFO(float val) noexcept { for (auto& v : voices) v.setLFOValue(val); }

void VoiceManager::noteOn(int midiNote, float velocity) noexcept
{
    // Check if any voice is already playing this note (e.g. still in release phase)
    // If so, steal it (monophonic retrigger per key) to prevent duplicate voices for same note
    int voiceIndex = findVoicePlayingNote(midiNote);
    
    if (voiceIndex < 0)
        voiceIndex = findFreeVoice();
    
    if (voiceIndex < 0)
        voiceIndex = findVoiceToSteal();
    
    if (voiceIndex >= 0)
        voices[voiceIndex].noteOn(midiNote, velocity);
}

void VoiceManager::noteOff(int midiNote) noexcept
{
    // Safely turn off ALL voices playing this note (just in case multiple exist)
    for (auto& voice : voices)
    {
        if (voice.isActive() && voice.getCurrentNote() == midiNote)
        {
            voice.noteOff();
        }
    }
}

void VoiceManager::allNotesOff() noexcept
{
    for (auto& voice : voices)
        voice.noteOff();
}

void VoiceManager::renderNextBlock(float* outputL, float* outputR, int numSamples) noexcept
{
    for (int i = 0; i < numSamples; ++i)
    {
        float sample = 0.0f;
        for (auto& voice : voices)
            sample += voice.renderNextSample();
        
        outputL[i] = sample;
        outputR[i] = sample;
    }
}

int VoiceManager::getActiveVoiceCount() const noexcept
{
    int count = 0;
    for (const auto& voice : voices)
        if (voice.isActive())
            ++count;
    return count;
}

int VoiceManager::findFreeVoice() const noexcept
{
    for (int i = 0; i < MAX_VOICES; ++i)
        if (!voices[i].isActive())
            return i;
    return -1;
}

int VoiceManager::findVoiceToSteal() const noexcept
{
    // Simple: steal oldest (first active voice)
    for (int i = 0; i < MAX_VOICES; ++i)
        if (voices[i].isActive())
            return i;
    return 0;
}

int VoiceManager::findVoicePlayingNote(int midiNote) const noexcept
{
    for (int i = 0; i < MAX_VOICES; ++i)
        if (voices[i].getCurrentNote() == midiNote)
            return i;
    return -1;
}

} // namespace Core
} // namespace CZ101
================================================================================
FILE: .\Source\Core\VoiceManager.h
================================================================================
#pragma once

#include "Voice.h"
#include <array>

namespace CZ101 {
namespace Core {

class VoiceManager
{
public:
    static constexpr int MAX_VOICES = 8;
    
    enum VoiceStealingMode
    {
        OLDEST,
        QUIETEST,
        RELEASE_PHASE
    };
    
    VoiceManager();
    
    void setSampleRate(double sampleRate) noexcept;
    void setVoiceStealingMode(VoiceStealingMode mode) noexcept { stealingMode = mode; }
    
    // Parameter Control (Proxy to all voices)
    // Oscillator 1
    void setOsc1Waveform(int waveformIndex) noexcept;
    void setOsc1Level(float level) noexcept;
    
    // Oscillator 2
    void setOsc2Waveform(int waveformIndex) noexcept;
    void setOsc2Level(float level) noexcept;
    void setOsc2Detune(float cents) noexcept;
    
    // DCW Envelope
    void setDCWAttack(float seconds) noexcept;
    void setDCWDecay(float seconds) noexcept;
    void setDCWSustain(float level) noexcept;
    void setDCWRelease(float seconds) noexcept;
    
    // DCA Envelope
    void setDCAAttack(float seconds) noexcept;
    void setDCADecay(float seconds) noexcept;
    void setDCASustain(float level) noexcept;
    void setDCARelease(float seconds) noexcept;
    
    // 8-Stage Envelope Control
    void setDCWStage(int index, float rate, float level) noexcept;
    void setDCWSustainPoint(int index) noexcept;
    void setDCWEndPoint(int index) noexcept;

    // Getters for UI
    void getDCWStage(int index, float& rate, float& level) const noexcept;
    int getDCWSustainPoint() const noexcept;
    int getDCWEndPoint() const noexcept;

    void getDCAStage(int index, float& rate, float& level) const noexcept;
    int getDCASustainPoint() const noexcept;
    int getDCAEndPoint() const noexcept;
    
    void getPitchStage(int index, float& rate, float& level) const noexcept;
    int getPitchSustainPoint() const noexcept;
    int getPitchEndPoint() const noexcept;
    
    void setDCAStage(int index, float rate, float level) noexcept;
    void setDCASustainPoint(int index) noexcept;
    void setDCAEndPoint(int index) noexcept;

    // Pitch Envelope (DCO)
    void setPitchStage(int index, float rate, float level) noexcept;
    void setPitchSustainPoint(int index) noexcept;
    void setPitchEndPoint(int index) noexcept;

    // Hard Sync
    void setHardSync(bool enabled) noexcept;

    // Ring Mod
    void setRingMod(bool enabled) noexcept;

    // Glide
    void setGlideTime(float seconds) noexcept;
    void setMasterTune(float semitones) noexcept;
    void setPitchBend(float semitones) noexcept;
    
    // LFO Control
    void setVibratoDepth(float semitones) noexcept;
    void updateLFO(float currentLFOValue) noexcept;

    void noteOn(int midiNote, float velocity) noexcept;
    void noteOff(int midiNote) noexcept;
    void allNotesOff() noexcept;
    
    void renderNextBlock(float* outputL, float* outputR, int numSamples) noexcept;
    
    int getActiveVoiceCount() const noexcept;
    
private:
    std::array<Voice, MAX_VOICES> voices;
    VoiceStealingMode stealingMode = RELEASE_PHASE;
    
    int findFreeVoice() const noexcept;
    int findVoiceToSteal() const noexcept;
    int findVoicePlayingNote(int midiNote) const noexcept;
};

} // namespace Core
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Chorus.cpp
================================================================================
#include "Chorus.h"
#include <cmath>

namespace CZ101 {
namespace DSP {
namespace Effects {

Chorus::Chorus()
{
    // Max delay depth 20ms usually enough (Allocating 50ms for safety)
    // 50ms at 192kHz ~= 9600 samples
    bufferSize = 16384; 
    delayBufferL.resize(bufferSize, 0.0f);
    delayBufferR.resize(bufferSize, 0.0f);
}

void Chorus::prepare(double sr)
{
    sampleRate = sr;
    setRate(rate); // Recalc increment
    reset();
}

void Chorus::reset()
{
    std::fill(delayBufferL.begin(), delayBufferL.end(), 0.0f);
    std::fill(delayBufferR.begin(), delayBufferR.end(), 0.0f);
    writeIndex = 0;
    lfoPhase = 0.0f;
}

void Chorus::setRate(float rateHz)
{
    rate = rateHz;
    // Inc per sample = Rate / SR
    // 2PI for sin? Or 0-1 phasor? Using 0-1
    lfoIncrement = rate / static_cast<float>(sampleRate);
}

void Chorus::setDepth(float depthMs)
{
    depth = depthMs;
}

void Chorus::setMix(float mix0to1)
{
    mix = std::clamp(mix0to1, 0.0f, 1.0f);
}

float Chorus::getInterpolatedSample(const std::vector<float>& buffer, float readIndex) const
{
    // Linear Interpolation
    int index1 = static_cast<int>(readIndex);
    int index2 = (index1 + 1) % bufferSize;
    float fraction = readIndex - index1;
    
    float s1 = buffer[index1];
    float s2 = buffer[index2];
    
    return s1 + fraction * (s2 - s1);
}

void Chorus::process(float* leftChannel, float* rightChannel, int numSamples)
{
    if (mix < 0.01f) return; // Bypass efficiency
    
    const float depthSamples = (depth / 1000.0f) * static_cast<float>(sampleRate);
    // Base delay for Chorus usually slightly more than depth excursion
    const float baseDelay = depthSamples * 1.5f + 100.0f; // Offset to avoid crossing write pointer
    
    for (int i = 0; i < numSamples; ++i)
    {
        // Update LFO
        lfoPhase += lfoIncrement;
        if (lfoPhase >= 1.0f) lfoPhase -= 1.0f;
        
        // Calculate LFO values
        // Left: Sin(phase)
        // Right: Cos(phase) or Sin(phase + 90) -> Separation
        float lfoValL = std::sin(lfoPhase * 2.0f * juce::MathConstants<float>::pi);
        float lfoValR = std::cos(lfoPhase * 2.0f * juce::MathConstants<float>::pi);
        
        // Calculate read positions
        // Delay = Base + Depth * LFO
        float delayL = baseDelay + (depthSamples * lfoValL);
        float delayR = baseDelay + (depthSamples * lfoValR);
        
        // Circular buffer read pointers
        float readPosL = static_cast<float>(writeIndex) - delayL;
        if (readPosL < 0.0f) readPosL += bufferSize;
        
        float readPosR = static_cast<float>(writeIndex) - delayR;
        if (readPosR < 0.0f) readPosR += bufferSize;
        
        // Read wet samples
        float wetL = getInterpolatedSample(delayBufferL, readPosL);
        float wetR = getInterpolatedSample(delayBufferR, readPosR);
        
        // Write inputs to buffer
        delayBufferL[writeIndex] = leftChannel[i];
        delayBufferR[writeIndex] = rightChannel[i];
        
        // Mix
        leftChannel[i] = (leftChannel[i] * (1.0f - mix * 0.5f)) + (wetL * mix);
        rightChannel[i] = (rightChannel[i] * (1.0f - mix * 0.5f)) + (wetR * mix);
        
        // Advance write pointer
        writeIndex++;
        if (writeIndex >= bufferSize) writeIndex = 0;
    }
}

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Chorus.h
================================================================================
#pragma once

#include <vector>
#include <cmath>
#include <JuceHeader.h>

namespace CZ101 {
namespace DSP {
namespace Effects {

class Chorus {
public:
    Chorus();
    
    void prepare(double sampleRate);
    void reset();
    
    void setRate(float rateHz);
    void setDepth(float depthMs);
    void setMix(float mix0to1);
    
    void process(float* leftChannel, float* rightChannel, int numSamples);
    
private:
    double sampleRate = 44100.0;
    
    // Parameters
    float rate = 0.5f;
    float depth = 2.0f; // ms
    float mix = 0.0f;
    
    // Delay lines
    std::vector<float> delayBufferL;
    std::vector<float> delayBufferR;
    int writeIndex = 0;
    int bufferSize = 0;
    
    // LFO state
    float lfoPhase = 0.0f;
    float lfoIncrement = 0.0f;
    
    // Helpers
    float getInterpolatedSample(const std::vector<float>& buffer, float readIndex) const;
};

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Delay.cpp
================================================================================
#include "Delay.h"

namespace CZ101 {
namespace DSP {
namespace Effects {

Delay::Delay()
{
    buffer.fill(0.0f);
}

void Delay::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
}

void Delay::setDelayTime(float seconds) noexcept
{
    seconds = std::clamp(seconds, 0.001f, 2.0f);
    delayInSamples = static_cast<int>(seconds * sampleRate);
    delayInSamples = std::min(delayInSamples, MAX_DELAY_SAMPLES - 1);
}

void Delay::setFeedback(float amount) noexcept
{
    feedback = std::clamp(amount, 0.0f, 0.95f);
}

void Delay::setMix(float amount) noexcept
{
    mix = std::clamp(amount, 0.0f, 1.0f);
}

void Delay::reset() noexcept
{
    buffer.fill(0.0f);
    writePos = 0;
}

float Delay::processSample(float input) noexcept
{
    int readPos = writePos - delayInSamples;
    if (readPos < 0)
        readPos += MAX_DELAY_SAMPLES;
    
    float delayed = buffer[readPos];
    buffer[writePos] = input + delayed * feedback;
    
    writePos = (writePos + 1) % MAX_DELAY_SAMPLES;
    
    return input * (1.0f - mix) + delayed * mix;
}

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Delay.h
================================================================================
#pragma once

#include <array>
#include <algorithm>

namespace CZ101 {
namespace DSP {
namespace Effects {
    
class Delay
{
public:
    Delay();
    
    void setSampleRate(double sampleRate) noexcept;
    void setDelayTime(float seconds) noexcept;
    void setFeedback(float amount) noexcept;
    void setMix(float amount) noexcept;
    void reset() noexcept;
    
    float processSample(float input) noexcept;
    
private:
    static constexpr int MAX_DELAY_SAMPLES = 88200;  // 2 seconds @ 44.1kHz
    
    std::array<float, MAX_DELAY_SAMPLES> buffer;
    double sampleRate = 44100.0;
    int delayInSamples = 22050;
    int writePos = 0;
    float feedback = 0.5f;
    float mix = 0.3f;
};

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Reverb.cpp
================================================================================
#include "Reverb.h"

namespace CZ101 {
namespace DSP {

Reverb::Reverb()
{
    // Set default parameters
    params.roomSize = 0.5f;
    params.damping = 0.5f;
    params.wetLevel = 0.33f;
    params.dryLevel = 1.0f; // Normally we control mix differently, but juce::Reverb has explicit wet/dry
    params.width = 1.0f;
    params.freezeMode = 0.0f;
    
    reverb.setParameters(params);
}

void Reverb::prepare(double sampleRate, int samplesPerBlock)
{
    currentSampleRate = sampleRate;
    reverb.setSampleRate(sampleRate);
    reverb.reset();
    (void)samplesPerBlock;
}

void Reverb::reset()
{
    reverb.reset();
}

void Reverb::setParameters(float roomSize, float damping, float wetLevel, float dryLevel, float width)
{
    params.roomSize = roomSize;
    params.damping = damping;
    params.wetLevel = wetLevel;
    params.dryLevel = dryLevel;
    params.width = width;
    
    reverb.setParameters(params);
}

void Reverb::process(juce::AudioBuffer<float>& buffer)
{
    // juce::Reverb processes stereo buffers naturally
    if (buffer.getNumChannels() == 2)
    {
        reverb.processStereo(buffer.getWritePointer(0), buffer.getWritePointer(1), buffer.getNumSamples());
    }
    else if (buffer.getNumChannels() == 1)
    {
        reverb.processMono(buffer.getWritePointer(0), buffer.getNumSamples());
    }
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Reverb.h
================================================================================
#pragma once

#include <juce_audio_basics/juce_audio_basics.h>

namespace CZ101 {
namespace DSP {

class Reverb
{
public:
    Reverb();
    
    void prepare(double sampleRate, int samplesPerBlock);
    void reset();
    
    void setParameters(float roomSize, float damping, float wetLevel, float dryLevel, float width);
    
    void process(juce::AudioBuffer<float>& buffer);
    
private:
    juce::Reverb reverb;
    juce::Reverb::Parameters params;
    
    double currentSampleRate = 44100.0;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Envelopes\ADSREnvelope.cpp
================================================================================
#include "ADSREnvelope.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

ADSREnvelope::ADSREnvelope()
{
}

void ADSREnvelope::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
}

void ADSREnvelope::setAttackTime(float seconds) noexcept
{
    attackTime = std::clamp(seconds, 0.001f, 10.0f);
}

void ADSREnvelope::setDecayTime(float seconds) noexcept
{
    decayTime = std::clamp(seconds, 0.001f, 10.0f);
}

void ADSREnvelope::setSustainLevel(float level) noexcept
{
    sustainLevel = std::clamp(level, 0.0f, 1.0f);
}

void ADSREnvelope::setReleaseTime(float seconds) noexcept
{
    releaseTime = std::clamp(seconds, 0.001f, 10.0f);
}

void ADSREnvelope::noteOn() noexcept
{
    currentStage = ATTACK;
    stageProgress = 0.0f;
}

void ADSREnvelope::noteOff() noexcept
{
    if (currentStage != IDLE)
    {
        currentStage = RELEASE;
        stageProgress = 0.0f;
    }
}

void ADSREnvelope::reset() noexcept
{
    currentStage = IDLE;
    currentValue = 0.0f;
    stageProgress = 0.0f;
}

float ADSREnvelope::getNextValue() noexcept
{
    if (currentStage == IDLE)
        return 0.0f;
    
    float stageDuration = 0.0f;
    float targetValue = 0.0f;
    float startValue = currentValue;
    
    switch (currentStage)
    {
        case ATTACK:
            stageDuration = attackTime;
            targetValue = 1.0f;
            startValue = 0.0f;
            break;
            
        case DECAY:
            stageDuration = decayTime;
            targetValue = sustainLevel;
            startValue = 1.0f;
            break;
            
        case SUSTAIN:
            return sustainLevel;
            
        case RELEASE:
            stageDuration = releaseTime;
            targetValue = 0.0f;
            startValue = currentValue;
            break;
            
        default:
            return 0.0f;
    }
    
    // Calculate progress increment
    float increment = 1.0f / (stageDuration * static_cast<float>(sampleRate));
    stageProgress += increment;
    
    // Apply exponential curve
    float curvedProgress = calculateExponentialCurve(stageProgress);
    
    // Interpolate between start and target
    currentValue = startValue + (targetValue - startValue) * curvedProgress;
    
    // Check if stage is complete
    if (stageProgress >= 1.0f)
    {
        currentValue = targetValue;
        advanceStage();
    }
    
    return currentValue;
}

float ADSREnvelope::calculateExponentialCurve(float t) const noexcept
{
    // Exponential curve: 1 - e^(-factor * t)
    // This creates a natural-sounding envelope
    t = std::clamp(t, 0.0f, 1.0f);
    return 1.0f - std::exp(-CURVE_FACTOR * t);
}

void ADSREnvelope::advanceStage() noexcept
{
    stageProgress = 0.0f;
    
    switch (currentStage)
    {
        case ATTACK:
            currentStage = DECAY;
            break;
            
        case DECAY:
            currentStage = SUSTAIN;
            break;
            
        case SUSTAIN:
            // Stay in sustain until noteOff
            break;
            
        case RELEASE:
            currentStage = IDLE;
            currentValue = 0.0f;
            break;
            
        default:
            break;
    }
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Envelopes\ADSREnvelope.h
================================================================================
#pragma once

#include <cmath>

namespace CZ101 {
namespace DSP {

/**
 * @brief ADSR Envelope Generator
 * 
 * Classic Attack-Decay-Sustain-Release envelope with exponential curves.
 * Used for both amplitude (DCA) and filter/timbre (DCW) modulation.
 */
class ADSREnvelope
{
public:
    enum Stage
    {
        IDLE = 0,
        ATTACK,
        DECAY,
        SUSTAIN,
        RELEASE,
        NUM_STAGES
    };
    
    ADSREnvelope();
    
    void setSampleRate(double sampleRate) noexcept;
    
    // Parameters in seconds
    void setAttackTime(float seconds) noexcept;
    void setDecayTime(float seconds) noexcept;
    void setSustainLevel(float level) noexcept;  // [0.0, 1.0]
    void setReleaseTime(float seconds) noexcept;
    
    void noteOn() noexcept;
    void noteOff() noexcept;
    void reset() noexcept;
    
    /**
     * @brief Get next envelope value
     * @return Envelope value [0.0, 1.0]
     */
    float getNextValue() noexcept;
    
    Stage getCurrentStage() const noexcept { return currentStage; }
    bool isActive() const noexcept { return currentStage != IDLE; }
    
private:
    double sampleRate = 44100.0;
    
    // Parameters
    float attackTime = 0.01f;    // 10ms
    float decayTime = 0.1f;      // 100ms
    float sustainLevel = 0.7f;   // 70%
    float releaseTime = 0.2f;    // 200ms
    
    // State
    Stage currentStage = IDLE;
    float currentValue = 0.0f;
    float stageProgress = 0.0f;  // [0.0, 1.0]
    
    // Exponential curve factor (higher = more exponential)
    static constexpr float CURVE_FACTOR = 4.0f;
    
    float calculateExponentialCurve(float t) const noexcept;
    void advanceStage() noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Envelopes\MultiStageEnv.cpp
================================================================================
#include "MultiStageEnv.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

MultiStageEnvelope::MultiStageEnvelope()
{
    // Default: Simple ADSR-like shape using 8 stages
    // Stage 0: Attack to 1.0
    setStage(0, 0.9f, 1.0f);
    // Stage 1: Decay to 0.5
    setStage(1, 0.8f, 0.5f);
    // Stage 2: Sustain at 0.5
    setStage(2, 0.99f, 0.5f);
    
    // Sets sustain point at Stage 2
    setSustainPoint(2);
    
    // Stage 3: Release to 0
    setStage(3, 0.8f, 0.0f);
    
    // End point at Stage 3
    setEndPoint(3);
}

void MultiStageEnvelope::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
}

void MultiStageEnvelope::setStage(int index, float rate, float level) noexcept
{
    if (index >= 0 && index < MAX_STAGES)
    {
        stages[index].rate = std::clamp(rate, 0.0f, 1.0f);
        stages[index].level = std::clamp(level, 0.0f, 1.0f);
    }
}

void MultiStageEnvelope::setSustainPoint(int stageIndex) noexcept
{
    if (stageIndex >= -1 && stageIndex < MAX_STAGES)
        sustainPoint = stageIndex;
}

void MultiStageEnvelope::setEndPoint(int stageIndex) noexcept
{
    if (stageIndex >= 0 && stageIndex < MAX_STAGES)
        endPoint = stageIndex;
}

void MultiStageEnvelope::noteOn() noexcept
{
    currentStage = 0;
    currentValue = 0.0f; // CZ starts from 0 (or previous value in advanced modes, but 0 simplify)
    targetValue = stages[0].level;
    
    float seconds = rateToSeconds(stages[0].rate);
    float samples = static_cast<float>(seconds * sampleRate);
    
    if (samples < 1.0f) samples = 1.0f;
    
    // Calculate linear increment
    currentIncrement = (targetValue - currentValue) / samples;
    
    active = true;
    released = false;
}

void MultiStageEnvelope::noteOff() noexcept
{
    released = true;
    
    // If currently holding at sustain point, move to next stage immediately
    if (active && currentStage == sustainPoint)
    {
        // Force transition to next stage
        currentStage++;
        if (currentStage > endPoint)
        {
            active = false;
            return;
        }
        
        // Setup next stage
        targetValue = stages[currentStage].level;
        float seconds = rateToSeconds(stages[currentStage].rate);
        float samples = static_cast<float>(seconds * sampleRate);
        if (samples < 1.0f) samples = 1.0f;
        
        currentIncrement = (targetValue - currentValue) / samples;
    }
}

void MultiStageEnvelope::reset() noexcept
{
    active = false;
    currentStage = 0;
    currentValue = 0.0f;
    currentIncrement = 0.0f;
}

float MultiStageEnvelope::getNextValue() noexcept
{
    if (!active) return currentValue;
    
    // Apply increment
    currentValue += currentIncrement;
    
    // Check if we reached target (or crossed it)
    bool reached = false;
    if (currentIncrement > 0.0f && currentValue >= targetValue) reached = true;
    else if (currentIncrement < 0.0f && currentValue <= targetValue) reached = true;
    else if (currentIncrement == 0.0f) reached = true; // Special case
    
    if (reached)
    {
        currentValue = targetValue; // Snap to target
        
        // Logic for Sustain / End
        
        // Are we at Sustain Point?
        if (currentStage == sustainPoint && !released)
        {
            // Hold here until Note Off
            currentIncrement = 0.0f;
        }
        else if (currentStage == endPoint)
        {
            // End of envelope
            active = false;
            currentIncrement = 0.0f;
        }
        else
        {
            // Move to next stage
            currentStage++;
            
            if (currentStage < MAX_STAGES)
            {
                targetValue = stages[currentStage].level;
                float seconds = rateToSeconds(stages[currentStage].rate);
                float samples = static_cast<float>(seconds * sampleRate);
                if (samples < 1.0f) samples = 1.0f;
                
                currentIncrement = (targetValue - currentValue) / samples;
            }
            else
            {
                active = false; // Safety
            }
        }
    }
    
    return currentValue;
}

float MultiStageEnvelope::rateToSeconds(float rate) const noexcept
{
    // CZ-101 Rate approximation
    // Rate 0.0 (slow) -> ~3 seconds (can be longer on real hardware)
    // Rate 1.0 (fast) -> ~1 ms
    
    // Using exponential curve
    // Invert rate: 1.0 is slow, 0.0 is fast for calculation
    float r = 1.0f - rate;
    
    // Base 30s max time
    return 0.001f + (std::pow(r, 4.0f) * 30.0f);
}

float MultiStageEnvelope::getStageRate(int index) const noexcept
{
    if (index >= 0 && index < MAX_STAGES)
        return stages[index].rate;
    return 0.0f;
}

float MultiStageEnvelope::getStageLevel(int index) const noexcept
{
    if (index >= 0 && index < MAX_STAGES)
        return stages[index].level;
    return 0.0f;
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Envelopes\MultiStageEnv.h
================================================================================
#pragma once

#include <array>
#include <cmath>

namespace CZ101 {
namespace DSP {

/**
 * @brief Multi-Stage Envelope Generator (8 stages)
 * 
 * Authentic CZ-101 Envelope Architecture:
 * - 8 Steps per envelope
 * - Each step has a Rate (speed) and Level (target)
 * - Sustain Point: The step where the envelope holds while key is pressed.
 * - End Point: The final step of the envelope.
 */
class MultiStageEnvelope
{
public:
    static constexpr int MAX_STAGES = 8;
    
    struct Stage
    {
        float level = 0.0f;      // Target level [0.0, 1.0]
        float rate = 0.5f;       // Speed to reach level [0.0, 1.0] (1.0 = fast, 0.0 = slow)
    };
    
    MultiStageEnvelope();
    
    void setSampleRate(double sampleRate) noexcept;
    
    // Configuration
    void setStage(int index, float rate, float level) noexcept;
    void setSustainPoint(int stageIndex) noexcept;
    void setEndPoint(int stageIndex) noexcept;
    
    // Runtime
    void noteOn() noexcept;
    void noteOff() noexcept;
    void reset() noexcept;
    
    float getNextValue() noexcept;
    
    // Getters for adapter logic
    float getStageRate(int index) const noexcept;
    float getStageLevel(int index) const noexcept;
    
    bool isActive() const noexcept { return active; }
    int getCurrentStage() const noexcept { return currentStage; }
    
    int getSustainPoint() const noexcept { return sustainPoint; }
    int getEndPoint() const noexcept { return endPoint; }
    
private:
    double sampleRate = 44100.0;
    std::array<Stage, MAX_STAGES> stages;
    
    int currentStage = 0;
    float currentValue = 0.0f;
    float currentIncrement = 0.0f;
    float targetValue = 0.0f;
    
    int sustainPoint = -1;  // -1 = no sustain (or one-shot)
    int endPoint = 7;       // Default to using all 8 stages
    
    bool active = false;
    bool released = false;
    
    // CZ-101 Rate to Time conversion (internal helper)
    // Rate 0-99 mapped to ms
    float rateToSeconds(float rate) const noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Filters\ResonantFilter.cpp
================================================================================
#include "ResonantFilter.h"

namespace CZ101 {
namespace DSP {

ResonantFilter::ResonantFilter()
{
    updateCoefficients();
}

void ResonantFilter::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
    updateCoefficients();
}

void ResonantFilter::setType(Type type) noexcept
{
    filterType = type;
    updateCoefficients();
}

void ResonantFilter::setCutoff(float frequency) noexcept
{
    cutoffFreq = std::clamp(frequency, 20.0f, 20000.0f);
    updateCoefficients();
}

void ResonantFilter::setResonance(float q) noexcept
{
    resonance = std::clamp(q, 0.1f, 10.0f);
    updateCoefficients();
}

void ResonantFilter::reset() noexcept
{
    z1 = 0.0f;
    z2 = 0.0f;
}

float ResonantFilter::processSample(float input) noexcept
{
    float output = a0 * input + a1 * z1 + a2 * z2 - b1 * z1 - b2 * z2;
    
    z2 = z1;
    z1 = output;
    
    return output;
}

void ResonantFilter::updateCoefficients() noexcept
{
    constexpr float PI = 3.14159265358979323846f;
    
    float omega = 2.0f * PI * cutoffFreq / static_cast<float>(sampleRate);
    float sinOmega = std::sin(omega);
    float cosOmega = std::cos(omega);
    float alpha = sinOmega / (2.0f * resonance);
    
    switch (filterType)
    {
        case LOWPASS:
        {
            float b0 = (1.0f - cosOmega) / 2.0f;
            float b1_coef = 1.0f - cosOmega;
            float b2_coef = (1.0f - cosOmega) / 2.0f;
            float a0_coef = 1.0f + alpha;
            float a1_coef = -2.0f * cosOmega;
            float a2_coef = 1.0f - alpha;
            
            a0 = b0 / a0_coef;
            a1 = b1_coef / a0_coef;
            a2 = b2_coef / a0_coef;
            b1 = a1_coef / a0_coef;
            b2 = a2_coef / a0_coef;
            break;
        }
        
        case HIGHPASS:
        {
            float b0 = (1.0f + cosOmega) / 2.0f;
            float b1_coef = -(1.0f + cosOmega);
            float b2_coef = (1.0f + cosOmega) / 2.0f;
            float a0_coef = 1.0f + alpha;
            float a1_coef = -2.0f * cosOmega;
            float a2_coef = 1.0f - alpha;
            
            a0 = b0 / a0_coef;
            a1 = b1_coef / a0_coef;
            a2 = b2_coef / a0_coef;
            b1 = a1_coef / a0_coef;
            b2 = a2_coef / a0_coef;
            break;
        }
        
        case BANDPASS:
        {
            float b0 = alpha;
            float b1_coef = 0.0f;
            float b2_coef = -alpha;
            float a0_coef = 1.0f + alpha;
            float a1_coef = -2.0f * cosOmega;
            float a2_coef = 1.0f - alpha;
            
            a0 = b0 / a0_coef;
            a1 = b1_coef / a0_coef;
            a2 = b2_coef / a0_coef;
            b1 = a1_coef / a0_coef;
            b2 = a2_coef / a0_coef;
            break;
        }
        
        default:
            break;
    }
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Filters\ResonantFilter.h
================================================================================
#pragma once

#include <cmath>
#include <algorithm>

namespace CZ101 {
namespace DSP {

class ResonantFilter
{
public:
    enum Type
    {
        LOWPASS = 0,
        HIGHPASS,
        BANDPASS,
        NUM_TYPES
    };
    
    ResonantFilter();
    
    void setSampleRate(double sampleRate) noexcept;
    void setType(Type type) noexcept;
    void setCutoff(float frequency) noexcept;
    void setResonance(float q) noexcept;
    void reset() noexcept;
    
    float processSample(float input) noexcept;
    
private:
    double sampleRate = 44100.0;
    Type filterType = LOWPASS;
    float cutoffFreq = 1000.0f;
    float resonance = 0.7f;
    
    // State variables (2-pole)
    float z1 = 0.0f;
    float z2 = 0.0f;
    
    // Coefficients
    float a0 = 1.0f, a1 = 0.0f, a2 = 0.0f;
    float b1 = 0.0f, b2 = 0.0f;
    
    void updateCoefficients() noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Modulation\LFO.cpp
================================================================================
#include "LFO.h"
#include <algorithm>
#include <random>

namespace CZ101 {
namespace DSP {

LFO::LFO()
{
    updatePhaseIncrement();
}

void LFO::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
    updatePhaseIncrement();
}

void LFO::setFrequency(float hz) noexcept
{
    frequency = std::clamp(hz, 0.01f, 20.0f);
    updatePhaseIncrement();
}

void LFO::setWaveform(Waveform waveform) noexcept
{
    currentWaveform = waveform;
}

void LFO::reset() noexcept
{
    phase = 0.0f;
}

void LFO::updatePhaseIncrement() noexcept
{
    phaseIncrement = frequency / static_cast<float>(sampleRate);
}

float LFO::getNextValue() noexcept
{
    float value = 0.0f;
    
    switch (currentWaveform)
    {
        case SINE: value = renderSine(); break;
        case TRIANGLE: value = renderTriangle(); break;
        case SAWTOOTH: value = renderSawtooth(); break;
        case SQUARE: value = renderSquare(); break;
        case RANDOM: value = renderRandom(); break;
        default: value = 0.0f;
    }
    
    phase += phaseIncrement;
    if (phase >= 1.0f)
        phase -= 1.0f;
    
    return value;
}

float LFO::renderSine() noexcept
{
    constexpr float TWO_PI = 6.28318530718f;
    return std::sin(TWO_PI * phase);
}

float LFO::renderTriangle() noexcept
{
    if (phase < 0.25f)
        return 4.0f * phase;
    else if (phase < 0.75f)
        return 2.0f - 4.0f * phase;
    else
        return 4.0f * phase - 4.0f;
}

float LFO::renderSawtooth() noexcept
{
    return 2.0f * phase - 1.0f;
}

float LFO::renderSquare() noexcept
{
    return (phase < 0.5f) ? 1.0f : -1.0f;
}

float LFO::renderRandom() noexcept
{
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_real_distribution<float> dis(-1.0f, 1.0f);
    
    if (phase < phaseIncrement)
        randomValue = dis(gen);
    
    return randomValue;
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Modulation\LFO.h
================================================================================
#pragma once

#include <cmath>

namespace CZ101 {
namespace DSP {

class LFO
{
public:
    enum Waveform
    {
        SINE = 0,
        TRIANGLE,
        SAWTOOTH,
        SQUARE,
        RANDOM,
        NUM_WAVEFORMS
    };
    
    LFO();
    
    void setSampleRate(double sampleRate) noexcept;
    void setFrequency(float hz) noexcept;
    void setWaveform(Waveform waveform) noexcept;
    void reset() noexcept;
    
    float getNextValue() noexcept;
    
private:
    double sampleRate = 44100.0;
    float frequency = 1.0f;
    Waveform currentWaveform = SINE;
    float phase = 0.0f;
    float phaseIncrement = 0.0f;
    float randomValue = 0.0f;
    
    void updatePhaseIncrement() noexcept;
    float renderSine() noexcept;
    float renderTriangle() noexcept;
    float renderSawtooth() noexcept;
    float renderSquare() noexcept;
    float renderRandom() noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\PhaseDistOsc.cpp
================================================================================
#include "PhaseDistOsc.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

PhaseDistOscillator::PhaseDistOscillator()
{
    updatePhaseIncrement();
}

void PhaseDistOscillator::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
    updatePhaseIncrement();
}

void PhaseDistOscillator::setFrequency(float freq) noexcept
{
    frequency = std::clamp(freq, 20.0f, 20000.0f);
    updatePhaseIncrement();
}

void PhaseDistOscillator::setWaveform(Waveform waveform) noexcept
{
    currentWaveform = waveform;
}

void PhaseDistOscillator::reset() noexcept
{
    phase = 0.0f;
}

void PhaseDistOscillator::updatePhaseIncrement() noexcept
{
    phaseIncrement = static_cast<float>(frequency / sampleRate);
}

float PhaseDistOscillator::renderNextSample(float dcwAmount, bool* outDidWrap) noexcept
{
    float sample = 0.0f;
    
    // Render based on current waveform
    switch (currentWaveform)
    {
        case SINE:
            sample = renderSine();
            break;
        case SAWTOOTH:
            sample = renderSawtooth();
            break;
        case SQUARE:
            sample = renderSquare();
            break;
        case TRIANGLE:
            sample = renderTriangle();
            break;
        default:
            sample = 0.0f;
    }

    // Phase Distortion Simulation (Timbre Modulation)
    // Mix between Pure Sine (fundamental) and Full Waveform based on DCW amount
    // This creates the characteristic "wah" or filter sweep sound of PD synthesis
    if (dcwAmount < 1.0f && currentWaveform != SINE)
    {
        float sineComp = renderSine();
        // Linear interpolation: sine -> full waveform
        sample = sineComp + (sample - sineComp) * dcwAmount;
    }
    
    // Advance phase
    phase += phaseIncrement;
    if (phase >= 1.0f)
    {
        phase -= 1.0f;
        if (outDidWrap) *outDidWrap = true;
    }
    else
    {
        if (outDidWrap) *outDidWrap = false;
    }
    
    return sample;
}

float PhaseDistOscillator::renderSine() noexcept
{
    // Sine wave: Perfect, no aliasing, no PolyBLEP needed
    return waveTable.getSine(phase);
}

float PhaseDistOscillator::renderSawtooth() noexcept
{
    // Naive sawtooth
    float value = 2.0f * phase - 1.0f;
    
    // Apply PolyBLEP at discontinuity (phase wraps from 1.0 to 0.0)
    value -= polyBLEP(phase, phaseIncrement);
    
    return value;
}

float PhaseDistOscillator::renderSquare() noexcept
{
    // Naive square wave
    float value = (phase < 0.5f) ? 1.0f : -1.0f;
    
    // Apply PolyBLEP at rising edge (phase = 0.0)
    value += polyBLEP(phase, phaseIncrement);
    
    // Apply PolyBLEP at falling edge (phase = 0.5)
    float phaseShifted = phase + 0.5f;
    if (phaseShifted >= 1.0f)
        phaseShifted -= 1.0f;
    value -= polyBLEP(phaseShifted, phaseIncrement);
    
    return value;
}

float PhaseDistOscillator::renderTriangle() noexcept
{
    // Triangle: Continuous waveform, no PolyBLEP needed
    return waveTable.getTriangle(phase);
}

float PhaseDistOscillator::polyBLEP(float t, float dt) const noexcept
{
    // PolyBLEP: Polynomial Bandlimited Step
    // Reduces aliasing by smoothing discontinuities
    
    // t: normalized phase [0.0, 1.0]
    // dt: phase increment per sample (frequency/sampleRate)
    
    // Discontinuity at start of cycle (t near 0.0)
    if (t < dt)
    {
        t /= dt;
        // Polynomial: t^2 - 2t + 1
        return t + t - t * t - 1.0f;
    }
    // Discontinuity at end of cycle (t near 1.0)
    else if (t > 1.0f - dt)
    {
        t = (t - 1.0f) / dt;
        // Polynomial: t^2 + 2t + 1
        return t * t + t + t + 1.0f;
    }
    
    // No discontinuity, no correction needed
    return 0.0f;
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\PhaseDistOsc.h
================================================================================
#pragma once

#include "WaveTable.h"
#include <cmath>

namespace CZ101 {
namespace DSP {

/**
 * @brief Phase Distortion Oscillator with PolyBLEP anti-aliasing
 * 
 * Core oscillator for CZ-101 emulation. Generates waveforms with
 * professional quality anti-aliasing using PolyBLEP technique.
 */
class PhaseDistOscillator
{
public:
    enum Waveform
    {
        SINE = 0,
        SAWTOOTH,
        SQUARE,
        TRIANGLE,
        NUM_WAVEFORMS
    };
    
    PhaseDistOscillator();
    
    /**
     * @brief Set sample rate
     * @param sampleRate Sample rate in Hz (e.g., 44100.0)
     */
    void setSampleRate(double sampleRate) noexcept;
    
    /**
     * @brief Set frequency
     * @param frequency Frequency in Hz (e.g., 440.0 for A4)
     */
    void setFrequency(float frequency) noexcept;
    
    /**
     * @brief Set waveform type
     * @param waveform Waveform enum value
     */
    void setWaveform(Waveform waveform) noexcept;
    
    /**
     * @brief Reset phase to zero
     */
    void reset() noexcept;
    
    /**
     * @brief Render next sample with Phase Distortion simulation
     * @param dcwAmount Timbre control [0.0 = Pure Sine, 1.0 = Full Waveform]
     * @param outDidWrap Pointer to bool that will be set to true if phase wrapped (optional)
     * @return Audio sample [-1.0, 1.0]
     */
    float renderNextSample(float dcwAmount, bool* outDidWrap = nullptr) noexcept;
    
private:
    WaveTable waveTable;
    
    double sampleRate = 44100.0;
    float frequency = 440.0f;
    Waveform currentWaveform = SINE;
    
    float phase = 0.0f;           // Current phase [0.0, 1.0]
    float phaseIncrement = 0.0f;  // Phase increment per sample
    
    /**
     * @brief PolyBLEP: Polynomial Bandlimited Step
     * 
     * Reduces aliasing by smoothing discontinuities in waveforms.
     * Essential for sawtooth and square waves.
     * 
     * @param t Normalized phase [0.0, 1.0]
     * @param dt Phase increment (frequency/sampleRate)
     * @return Correction value to subtract from naive waveform
     */
    float polyBLEP(float t, float dt) const noexcept;
    
    // Waveform renderers
    float renderSine() noexcept;
    float renderSawtooth() noexcept;
    float renderSquare() noexcept;
    float renderTriangle() noexcept;
    
    void updatePhaseIncrement() noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\WaveShaper.cpp
================================================================================
#include "WaveShaper.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

float WaveShaper::applyPhaseDistortion(float phase, float amount) const noexcept
{
    // Clamp inputs
    phase = std::clamp(phase, 0.0f, 1.0f);
    amount = std::clamp(amount, 0.0f, 1.0f);
    
    // No distortion: return original phase
    if (amount < 0.001f)
        return phase;
    
    // Apply resonance curve
    // This creates the characteristic CZ-101 timbre by
    // compressing/expanding different parts of the waveform
    float distorted = resonanceCurve(phase, amount);
    
    return std::clamp(distorted, 0.0f, 1.0f);
}

float WaveShaper::resonanceCurve(float phase, float resonance) const noexcept
{
    // CZ-101 Phase Distortion algorithm
    // Based on the original Casio implementation
    
    // The curve compresses the first half and expands the second half
    // creating harmonic content similar to filter resonance
    
    // Calculate distortion factor
    // Higher resonance = more compression/expansion
    float factor = 1.0f + resonance * 3.0f;
    
    // Apply non-linear curve
    // This creates the phase distortion effect
    float distorted;
    
    if (phase < 0.5f)
    {
        // First half: compress (speeds up playback)
        float t = phase * 2.0f;  // Normalize to [0, 1]
        distorted = std::pow(t, factor) * 0.5f;
    }
    else
    {
        // Second half: expand (slows down playback)
        float t = (phase - 0.5f) * 2.0f;  // Normalize to [0, 1]
        distorted = 0.5f + (1.0f - std::pow(1.0f - t, factor)) * 0.5f;
    }
    
    return distorted;
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\WaveShaper.h
================================================================================
#pragma once

#include <cmath>

namespace CZ101 {
namespace DSP {

/**
 * @brief WaveShaper for Phase Distortion synthesis
 * 
 * Implements the core CZ-101 phase distortion algorithm.
 * Modulates the phase of a waveform to create harmonic content.
 */
class WaveShaper
{
public:
    WaveShaper() = default;
    
    /**
     * @brief Apply phase distortion to a normalized phase value
     * 
     * @param phase Input phase [0.0, 1.0]
     * @param amount Distortion amount [0.0, 1.0]
     *               0.0 = no distortion (linear)
     *               1.0 = maximum distortion
     * @return Distorted phase [0.0, 1.0]
     */
    float applyPhaseDistortion(float phase, float amount) const noexcept;
    
private:
    /**
     * @brief Resonance curve for phase distortion
     * Creates the characteristic CZ-101 timbre
     */
    float resonanceCurve(float phase, float resonance) const noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\WaveTable.cpp
================================================================================
#include "WaveTable.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

WaveTable::WaveTable()
{
    generateTables();
}

void WaveTable::generateTables()
{
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    
    for (int i = 0; i < TABLE_SIZE; ++i)
    {
        const float phase = static_cast<float>(i) / static_cast<float>(TABLE_SIZE);
        
        // Sine wave: Perfect, no aliasing
        sineTable[i] = std::sin(TWO_PI * phase);
        
        // Sawtooth: Naive version (PolyBLEP applied at render time)
        sawtoothTable[i] = 2.0f * phase - 1.0f;
        
        // Square: Naive version (PolyBLEP applied at render time)
        squareTable[i] = (phase < 0.5f) ? 1.0f : -1.0f;
        
        // Triangle: Continuous waveform
        if (phase < 0.25f)
            triangleTable[i] = 4.0f * phase;
        else if (phase < 0.75f)
            triangleTable[i] = 2.0f - 4.0f * phase;
        else
            triangleTable[i] = 4.0f * phase - 4.0f;
    }
}

float WaveTable::getSine(float phase) const noexcept
{
    return interpolate(sineTable, phase);
}

float WaveTable::getSawtooth(float phase) const noexcept
{
    return interpolate(sawtoothTable, phase);
}

float WaveTable::getSquare(float phase) const noexcept
{
    return interpolate(squareTable, phase);
}

float WaveTable::getTriangle(float phase) const noexcept
{
    return interpolate(triangleTable, phase);
}

float WaveTable::getPulse(float phase, float width) const noexcept
{
    // Pulse wave with variable width
    // width = 0.5 is square wave
    phase = phase - std::floor(phase);
    width = std::clamp(width, 0.1f, 0.9f);
    return (phase < width) ? 1.0f : -1.0f;
}

float WaveTable::getDoubleSine(float phase) const noexcept
{
    // Two sine waves, one octave apart
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    
    phase = phase - std::floor(phase);
    float fundamental = std::sin(TWO_PI * phase);
    float octave = std::sin(TWO_PI * phase * 2.0f);
    
    return (fundamental + octave * 0.5f) / 1.5f;  // Normalize
}

float WaveTable::getHalfSine(float phase) const noexcept
{
    // Sine wave rectified (only positive half)
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    
    phase = phase - std::floor(phase);
    float sine = std::sin(TWO_PI * phase);
    
    return (sine > 0.0f) ? sine : 0.0f;
}

float WaveTable::getResonantSaw(float phase) const noexcept
{
    // Sawtooth with emphasized harmonics (resonant character)
    phase = phase - std::floor(phase);
    
    float saw = 2.0f * phase - 1.0f;
    
    // Add harmonic emphasis
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    float harmonic = std::sin(TWO_PI * phase * 3.0f) * 0.3f;
    
    return std::clamp(saw + harmonic, -1.0f, 1.0f);
}

float WaveTable::getResonantTriangle(float phase) const noexcept
{
    // Triangle with emphasized harmonics
    phase = phase - std::floor(phase);
    
    float tri;
    if (phase < 0.25f)
        tri = 4.0f * phase;
    else if (phase < 0.75f)
        tri = 2.0f - 4.0f * phase;
    else
        tri = 4.0f * phase - 4.0f;
    
    // Add harmonic emphasis
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    float harmonic = std::sin(TWO_PI * phase * 5.0f) * 0.2f;
    
    return std::clamp(tri + harmonic, -1.0f, 1.0f);
}

float WaveTable::getTrapezoid(float phase) const noexcept
{
    // Trapezoid wave (between square and triangle)
    phase = phase - std::floor(phase);
    
    constexpr float riseTime = 0.15f;   // 15% rise
    constexpr float fallTime = 0.15f;   // 15% fall
    constexpr float highTime = 0.35f;   // 35% high
    // lowTime = 0.35f (35% low) - implicit in else branch
    
    if (phase < riseTime)
        return (phase / riseTime) * 2.0f - 1.0f;  // Rising
    else if (phase < riseTime + highTime)
        return 1.0f;  // High
    else if (phase < riseTime + highTime + fallTime)
        return 1.0f - ((phase - riseTime - highTime) / fallTime) * 2.0f;  // Falling
    else
        return -1.0f;  // Low
}

float WaveTable::interpolate(const std::array<float, TABLE_SIZE>& table, float phase) const noexcept
{
    // Wrap phase to [0.0, 1.0]
    phase = phase - std::floor(phase);
    
    // Convert to table index
    const float indexFloat = phase * static_cast<float>(TABLE_SIZE);
    const int index0 = static_cast<int>(indexFloat) % TABLE_SIZE;
    const int index1 = (index0 + 1) % TABLE_SIZE;
    
    // Linear interpolation
    const float frac = indexFloat - std::floor(indexFloat);
    return table[index0] + frac * (table[index1] - table[index0]);
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\WaveTable.h
================================================================================
#pragma once

#include <array>
#include <cmath>

namespace CZ101 {
namespace DSP {

/**
 * @brief WaveTable generator for Phase Distortion synthesis
 * 
 * Generates lookup tables for basic waveforms used in CZ-101 emulation.
 * Tables are 256 samples for efficient memory usage and fast lookup.
 * 
 * Note: Sawtooth and Square will use PolyBLEP at render time,
 * so these tables are "naive" versions.
 */
class WaveTable
{
public:
    static constexpr int TABLE_SIZE = 256;
    
    WaveTable();
    
    /**
     * @brief Get sine wave value at normalized phase
     * @param phase Normalized phase [0.0, 1.0]
     * @return Sample value [-1.0, 1.0]
     */
    float getSine(float phase) const noexcept;
    
    /**
     * @brief Get sawtooth wave value at normalized phase
     * @param phase Normalized phase [0.0, 1.0]
     * @return Sample value [-1.0, 1.0]
     * @note This is a naive sawtooth. Apply PolyBLEP at render time!
     */
    float getSawtooth(float phase) const noexcept;
    
    /**
     * @brief Get square wave value at normalized phase
     * @param phase Normalized phase [0.0, 1.0]
     * @return Sample value [-1.0, 1.0]
     * @note This is a naive square. Apply PolyBLEP at render time!
     */
    float getSquare(float phase) const noexcept;
    
    /**
     * @brief Get triangle wave value at normalized phase
     * @param phase Normalized phase [0.0, 1.0]
     * @return Sample value [-1.0, 1.0]
     */
    float getTriangle(float phase) const noexcept;
    
    // Advanced waveforms (CZ-101 specific)
    float getPulse(float phase, float width = 0.5f) const noexcept;
    float getDoubleSine(float phase) const noexcept;
    float getHalfSine(float phase) const noexcept;
    float getResonantSaw(float phase) const noexcept;
    float getResonantTriangle(float phase) const noexcept;
    float getTrapezoid(float phase) const noexcept;
    
private:
    std::array<float, TABLE_SIZE> sineTable;
    std::array<float, TABLE_SIZE> sawtoothTable;
    std::array<float, TABLE_SIZE> squareTable;
    std::array<float, TABLE_SIZE> triangleTable;
    
    void generateTables();
    
    // Helper: Linear interpolation between table samples
    float interpolate(const std::array<float, TABLE_SIZE>& table, float phase) const noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\MIDI\MIDIProcessor.cpp
================================================================================
#include "MIDIProcessor.h"

namespace CZ101 {
namespace MIDI {

MIDIProcessor::MIDIProcessor(Core::VoiceManager& vm, State::PresetManager& pm)
    : voiceManager(vm), presetManager(pm)
{
}

void MIDIProcessor::processMidiMessage(const juce::MidiMessage& message) noexcept
{
    if (message.isNoteOn())
        handleNoteOn(message.getNoteNumber(), message.getFloatVelocity());
    else if (message.isNoteOff())
        handleNoteOff(message.getNoteNumber());
    else if (message.isPitchWheel())
        handlePitchBend(message.getPitchWheelValue());
    else if (message.isControllerOfType(1))
        handleControlChange(1, message.getControllerValue());
    else if (message.isSysEx())
        handleSysEx(message.getSysExData(), message.getSysExDataSize());
}

void MIDIProcessor::processMidiBuffer(const juce::MidiBuffer& midiBuffer) noexcept
{
    for (const auto metadata : midiBuffer)
        processMidiMessage(metadata.getMessage());
}

void MIDIProcessor::handleNoteOn(int note, float velocity) noexcept
{
    voiceManager.noteOn(note, velocity);
}

void MIDIProcessor::handleNoteOff(int note) noexcept
{
    voiceManager.noteOff(note);
}

void MIDIProcessor::handlePitchBend(int value) noexcept
{
    // Convert 0-16383 to -1.0 to +1.0
    // CZ-101 Spec: 8 bit resolution, 0-12 semitones.
    float normalized = (value - 8192) / 8192.0f;
    currentPitchBend = normalized * pitchBendRange;
    
    // Apply pitch bend to all voices
    voiceManager.setPitchBend(currentPitchBend);
}

void MIDIProcessor::handleControlChange(int cc, int value) noexcept
{
    float normValue = value / 127.0f;
    
    switch (cc)
    {
        case 1: // Vibrato On/Off (We map to Depth)
            // If value > 64 ? Depth = 0.1 : 0.0?
            // User requested mapping, let's map 0-127 to 0.0-1.0 depth (approx 1 semitone max)
            voiceManager.setVibratoDepth(normValue * 1.0f); 
            break;
            
        case 5: // Portamento Time
            portamentoTime = normValue * 2.0f; // Max 2 seconds
            if (portamentoEnabled)
                voiceManager.setGlideTime(portamentoTime);
            break;
            
        case 6: // Master Tune
            // Map 0-127 to +/- 1 semitone? Or +/- 100 cents?
            // Let's do +/- 100 cents (+/- 1 semitone)
            // Center 64 = 0.
            {
                float tune = (value - 64) / 64.0f; // -1 to +1 approx
                voiceManager.setMasterTune(tune);
            }
            break;
            
        case 65: // Portamento On/Off
            portamentoEnabled = (value >= 64);
            voiceManager.setGlideTime(portamentoEnabled ? portamentoTime : 0.0f);
            break;
            
        default:
            break;
    }
}

void MIDIProcessor::handleSysEx(const void* data, int size) noexcept
{
    if (sysExManager)
        sysExManager->handleSysEx(data, size);
}

} // namespace MIDI
} // namespace CZ101

================================================================================
FILE: .\Source\MIDI\MIDIProcessor.h
================================================================================
#pragma once

#include "../Core/VoiceManager.h"
#include "SysExManager.h"
#include <juce_audio_processors/juce_audio_processors.h>

namespace CZ101 {
namespace MIDI {

class MIDIProcessor
{
public:
    MIDIProcessor(Core::VoiceManager& voiceManager, State::PresetManager& presetManager);
    
    void processMidiMessage(const juce::MidiMessage& message) noexcept;
    void setSysExManager(SysExManager* sysEx) { sysExManager = sysEx; }
    
    // Alias for external use
    void processMessage(const juce::MidiMessage& message) { processMidiMessage(message); }
    void processMidiBuffer(const juce::MidiBuffer& midiBuffer) noexcept;
    
    void setPitchBendRange(int semitones) noexcept { pitchBendRange = semitones; }

private:
    Core::VoiceManager& voiceManager;
    State::PresetManager& presetManager; 
    
    SysExManager* sysExManager = nullptr;
    int pitchBendRange = 2;  // Â±2 semitones
    float currentPitchBend = 0.0f;
    
    // MIDI State
    float portamentoTime = 0.0f;
    bool portamentoEnabled = true; // Default ON? Or OFF? Spec says ? 65 is Portamento On/Off.
    
    void handleNoteOn(int note, float velocity) noexcept;
    void handleNoteOff(int note) noexcept;
    void handlePitchBend(int value) noexcept;
    void handleControlChange(int cc, int value) noexcept;
    void handleSysEx(const void* data, int size) noexcept;
};

} // namespace MIDI
} // namespace CZ101

================================================================================
FILE: .\Source\MIDI\SysExManager.cpp
================================================================================
#include "SysExManager.h"
#include <juce_core/juce_core.h>
#include <iostream>

namespace CZ101 {
namespace MIDI {

SysExManager::SysExManager(State::PresetManager& pm)
    : presetManager(pm)
{
}

void SysExManager::handleSysEx(const void* data, int size)
{
    const juce::uint8* bytes = static_cast<const juce::uint8*>(data);
    
    // Basic Validation
    if (size < 6 || bytes[0] != SYSEX_START || bytes[size-1] != SYSEX_END) {
        std::cout << "[SysEx] Invalid framing or size: " << size << std::endl;
        return;
    }
        
    // Check Manufacturer (Casio = 0x44)
    if (bytes[1] != MANU_ID_CASIO) {
        std::cout << "[SysEx] Wrong Manufacturer: " << (int)bytes[1] << std::endl;
        return;
    }
        
    // CZ-101 Dump Header usually: F0 44 00 00 70+ch ...
    // Let's look for the "Receive Request" pattern or "Dump" pattern.
    // Doc: "Receive request: F0 44 00 00 70+ch 20 program ... F7"
    // But actual Data Dump is the response to a "Send Request".
    // "Send request... CZ101: F0 44 00 00 70+ch 30" -> Ack.
    // The big data block usually comes after a handshake.
    // However, .syx files usually contain the FULL sequence or the DATA block.
    // A Sound Data Reference usually looks like:
    // F0 44 00 00 7n 31 ... data ... sum F7
    
    // For now, let's just look for the data payload signature if possible.
    // If bytes[5] == 0x31 (Data follows?) or we just try to parse if valid.
    
    // Let's try to parse if it looks like a parameter dump.
    // Dump length is huge (256 bytes payload meaning 512 nibbles?).
    // 25 distinct sections.
    
    // Simplified: process payload if it matches Casio format.
    // Offset 6 is usually where data starts?
    int payloadStart = 6; 
    int payloadEnd = size - 2; // exclude checksum and F7?
    
    if (payloadEnd - payloadStart > 100) // Arbitrary check for "big enough"
    {
        parseToneData(bytes + payloadStart, payloadEnd - payloadStart);
    }
}

juce::MidiMessage SysExManager::createDumpMessage(const State::Preset& preset)
{
    // TODO: Implement encoding
    juce::ignoreUnused(preset);
    return juce::MidiMessage::createSysExMessage(nullptr, 0); 
}

// âš ï¸ CRITICAL: Casio uses little-endian nibble pairs
// Dato hexadecimal 5F se transmite como 0F 05 (nibbles invertidos y separados)
// Handbook: "Dato hexadecimal 5F se transmite como 0F 05"
// So: Byte 1 = Low Nibble (0F), Byte 2 = High Nibble (05)
juce::uint8 SysExManager::decodeByte(juce::uint8 lowNibble, juce::uint8 highNibble) const
{
    return (lowNibble & 0x0F) | ((highNibble & 0x0F) << 4);
}

float SysExManager::mapRangeTo01(int value, int min, int max)
{
    if (max == min) return 0.0f;
    return static_cast<float>(value - min) / static_cast<float>(max - min);
}

float SysExManager::mapRateToSeconds(int rate)
{
    // CZ Rate 0-99. 99 is fast (~1ms), 0 is slow (~3s?).
    // Invert: 99 -> 0.0, 0 -> 1.0 logic?
    // Our map: 0..1 to Seconds.
    return 1.0f - (rate / 99.0f);
}

void SysExManager::parseToneData(const juce::uint8* payload, int payloadSize)
{
    // Need approx 256 bytes payload (256 nibbles = 128 bytes internal data)
    // File is 264 bytes total -> ~256 data.
    std::cout << "[SysEx] Payload Size: " << payloadSize << std::endl;
    if (payloadSize < 240) {
        std::cout << "[SysEx] Error: Payload too small (" << payloadSize << " < 240)" << std::endl;
        return;
    } 
    
    State::Preset p = presetManager.getCurrentPreset(); 
    p.name = "SysEx Import";
    
    int currentByte = 0;
    auto getNextByte = [&]() -> juce::uint8 {
        if (currentByte + 1 >= payloadSize) return 0;
        juce::uint8 v = decodeByte(payload[currentByte], payload[currentByte+1]);
        currentByte += 2;
        return v;
    };
    
    // --- 1. PFLAG (1 byte) ---
    juce::uint8 pflag = getNextByte();
    int octave = (pflag >> 1) & 0x03; // Bits 1-2
    int lineSel = pflag & 0x01;       // Bit 0? Handbook says "Line Select: bits 0-1"? 
    juce::ignoreUnused(octave, lineSel);
    
    // --- 2. PDS (1 byte) - Detune Sign ---
    juce::uint8 pds = getNextByte();
    juce::ignoreUnused(pds);
    
    // --- 3. PDL, PDH (2 bytes) - Detune Range ---
    juce::uint8 pdl = getNextByte();
    juce::uint8 pdh = getNextByte();
    int detuneVal = pdl | (pdh << 8);
    juce::ignoreUnused(detuneVal);
    // TODO: Map detune
    
    // --- 4. PVK (1 byte) - Vibrato Wave ---
    juce::uint8 pvk = getNextByte();
    juce::ignoreUnused(pvk);
    // 0x08=Sine, 0x04=Tri, 0x20=Saw, 0x02=Square
    // We only have Sine implemented fully, currently?
    
    // --- 5. PVDL (3 bytes) - Vibrato Delay ---
    getNextByte(); getNextByte(); getNextByte(); 
    
    // --- 6. PVS (3 bytes) - Vibrato Rate ---
    getNextByte(); getNextByte(); getNextByte();
    
    // --- 7. PVD (3 bytes) - Vibrato Depth ---
    juce::uint8 pvd1 = getNextByte();
    juce::uint8 pvd2 = getNextByte(); 
    juce::uint8 pvd3 = getNextByte();
    juce::ignoreUnused(pvd1, pvd2, pvd3);
    // Usually only one byte matters for basic emulation (depth).
    // mapRangeTo01(pvd3, 0, 99) -> Vibrato Depth?
    
    // ... Skipping to Section 12 (DCA1 Env) ...
    // Sections 8-11: MFW, MAMD, MWMD, PMAL
    getNextByte(); getNextByte(); // MFW (Wave)
    getNextByte(); getNextByte(); // MAMD
    getNextByte(); getNextByte(); // MWMD
    juce::uint8 pmal = getNextByte(); // DCA1 End Step
    
    auto parseEnvelope = [&](State::EnvelopeData& env, int endStep) {
        env.endPoint = (endStep > 7) ? 7 : endStep;
        
        for (int i=0; i<8; ++i) {
            juce::uint8 rawRate = getNextByte();
            juce::uint8 rawLevel = getNextByte();
            
            // Handbook formulas:
            // rate = (99 * (byte - 8) / 119) + 1  (approx)
            // level = (119 * byte / 99) (approx)
            // But we store 0.0-1.0 float in EnvelopeData.
            
            // Simply normalize raw byte (0-127) to 0-1 for now is safer than specific formulas unless matching hardware exactness.
            // But let's try to respect the range 0-99.
            int rateVal = rawRate; // approx
            int levelVal = rawLevel & 0x7F; // remove flags
            
            env.rates[i] = mapRangeTo01(rateVal, 0, 127); // Simple map
            env.levels[i] = mapRangeTo01(levelVal, 0, 127);
            
            if (rawLevel & 0x80) env.sustainPoint = i;
        }
    };
    
    // 12: DCA1 Env
    State::EnvelopeData dca1; 
    parseEnvelope(dca1, pmal);
    p.dcaEnv = dca1; // Only mapping to Voice 1 mapping for now
    
    // 13: PMWL (DCW1 End)
    juce::uint8 pmwl = getNextByte();
    
    // 14: DCW1 Env
    State::EnvelopeData dcw1;
    parseEnvelope(dcw1, pmwl);
    p.dcwEnv = dcw1;
    
    // 15: PMPL (DCO1 End)
    juce::uint8 pmpl = getNextByte();
    
    // 16: DCO1 Env
    State::EnvelopeData dco1;
    parseEnvelope(dco1, pmpl);
    p.pitchEnv = dco1;
    
    // Skip Line 2 for now to keep it simple (monotimbral preset structure assumption)
    // Or we could map it if Preset struct supported dual lines.
    
    // Apply
    presetManager.loadPresetFromStruct(p);
}

} // namespace MIDI
} // namespace CZ101

================================================================================
FILE: .\Source\MIDI\SysExManager.h
================================================================================
#pragma once

#include <juce_audio_basics/juce_audio_basics.h>
#include "../State/PresetManager.h"

namespace CZ101 {
namespace MIDI {

class SysExManager
{
public:
    SysExManager(State::PresetManager& presetManager);
    
    // Main entry point for incoming SysEx data
    void handleSysEx(const void* data, int size);
    
    // Create a dump message for a specific preset
    juce::MidiMessage createDumpMessage(const State::Preset& preset);

private:
    State::PresetManager& presetManager;
    
    // Constants
    static constexpr juce::uint8 SYSEX_START = 0xF0;
    static constexpr juce::uint8 SYSEX_END = 0xF7;
    static constexpr juce::uint8 MANU_ID_CASIO = 0x44;
    
    // Helpers for CZ Nibble format
    juce::uint8 decodeByte(juce::uint8 lowNibble, juce::uint8 highNibble) const;
    
    // Parameter Mapping
    void parseToneData(const juce::uint8* payload, int payloadSize);
    
    // Parameter Setters helpers
    float mapRangeTo01(int value, int min, int max);
    float mapRateToSeconds(int rate); // CZ 0-99 to seconds
};

} // namespace MIDI
} // namespace CZ101

================================================================================
FILE: .\Source\State\Parameters.cpp
================================================================================
#include "Parameters.h"

namespace CZ101 {
namespace State {

Parameters::Parameters(juce::AudioProcessor& processor)
    : audioProcessor(processor)
{
}

void Parameters::createParameters()
{
    using namespace juce;
    
    // Oscillator 1
    osc1Level = new AudioParameterFloat("osc1_level", "Osc 1 Level", 0.0f, 1.0f, 0.5f);
    audioProcessor.addParameter(osc1Level);
    
    osc1Waveform = new AudioParameterChoice("osc1_waveform", "Osc 1 Waveform",
        StringArray{"Sine", "Sawtooth", "Square", "Triangle"}, 0);
    audioProcessor.addParameter(osc1Waveform);
    
    // Oscillator 2
    osc2Level = new AudioParameterFloat("osc2_level", "Osc 2 Level", 0.0f, 1.0f, 0.5f);
    audioProcessor.addParameter(osc2Level);
    
    osc2Waveform = new AudioParameterChoice("osc2_waveform", "Osc 2 Waveform",
        StringArray{"Sine", "Sawtooth", "Square", "Triangle"}, 0);
    audioProcessor.addParameter(osc2Waveform);
    
    osc2Detune = new AudioParameterFloat("osc2_detune", "Osc 2 Detune", -100.0f, 100.0f, 0.0f);
    audioProcessor.addParameter(osc2Detune);
    
    hardSync = new AudioParameterBool("hard_sync", "Hard Sync", false);
    audioProcessor.addParameter(hardSync);

    ringMod = new AudioParameterBool("ring_mod", "Ring Mod", false);
    audioProcessor.addParameter(ringMod);

    glideTime = new AudioParameterFloat("glide_time", "Glide Time", 0.0f, 2.0f, 0.0f);
    audioProcessor.addParameter(glideTime);
    
    // DCA Envelope
    dcaAttack = new AudioParameterFloat("dca_attack", "DCA Attack", 0.001f, 5.0f, 0.01f);
    audioProcessor.addParameter(dcaAttack);
    
    dcaDecay = new AudioParameterFloat("dca_decay", "DCA Decay", 0.001f, 5.0f, 0.1f);
    audioProcessor.addParameter(dcaDecay);
    
    dcaSustain = new AudioParameterFloat("dca_sustain", "DCA Sustain", 0.0f, 1.0f, 0.7f);
    audioProcessor.addParameter(dcaSustain);
    
    dcaRelease = new AudioParameterFloat("dca_release", "DCA Release", 0.001f, 5.0f, 0.2f);
    audioProcessor.addParameter(dcaRelease);
    
    // DCW Envelope
    dcwAttack = new AudioParameterFloat("dcw_attack", "DCW Attack", 0.001f, 5.0f, 0.05f);
    audioProcessor.addParameter(dcwAttack);
    
    dcwDecay = new AudioParameterFloat("dcw_decay", "DCW Decay", 0.001f, 5.0f, 0.2f);
    audioProcessor.addParameter(dcwDecay);
    
    dcwSustain = new AudioParameterFloat("dcw_sustain", "DCW Sustain", 0.0f, 1.0f, 0.5f);
    audioProcessor.addParameter(dcwSustain);
    
    dcwRelease = new AudioParameterFloat("dcw_release", "DCW Release", 0.001f, 5.0f, 0.3f);
    audioProcessor.addParameter(dcwRelease);
    
    // Filter
    filterCutoff = new AudioParameterFloat("filter_cutoff", "Filter Cutoff", 20.0f, 20000.0f, 1000.0f);
    audioProcessor.addParameter(filterCutoff);
    
    filterResonance = new AudioParameterFloat("filter_resonance", "Filter Resonance", 0.1f, 10.0f, 0.7f);
    audioProcessor.addParameter(filterResonance);
    
    filterType = new AudioParameterChoice("filter_type", "Filter Type",
        StringArray{"Lowpass", "Highpass", "Bandpass"}, 0);
    audioProcessor.addParameter(filterType);
    
    // Delay
    delayTime = new AudioParameterFloat("delay_time", "Delay Time", 0.001f, 2.0f, 0.5f);
    audioProcessor.addParameter(delayTime);
    
    delayFeedback = new AudioParameterFloat("delay_feedback", "Delay Feedback", 0.0f, 0.95f, 0.5f);
    audioProcessor.addParameter(delayFeedback);
    
    delayMix = new AudioParameterFloat("delay_mix", "Delay Mix", 0.0f, 1.0f, 0.3f);
    audioProcessor.addParameter(delayMix);
    
    // Reverb
    reverbSize = new AudioParameterFloat("reverb_size", "Reverb Size", 0.0f, 1.0f, 0.5f);
    audioProcessor.addParameter(reverbSize);
    
    reverbMix = new AudioParameterFloat("reverb_mix", "Reverb Mix", 0.0f, 1.0f, 0.0f);
    audioProcessor.addParameter(reverbMix);

    // Chorus
    chorusRate = new AudioParameterFloat("chorus_rate", "Chorus Rate", 0.1f, 10.0f, 0.5f);
    audioProcessor.addParameter(chorusRate);

    chorusDepth = new AudioParameterFloat("chorus_depth", "Chorus Depth", 0.0f, 20.0f, 2.0f);
    audioProcessor.addParameter(chorusDepth);

    chorusMix = new AudioParameterFloat("chorus_mix", "Chorus Mix", 0.0f, 1.0f, 0.0f);
    audioProcessor.addParameter(chorusMix);
    
    // LFO
    lfoRate = new AudioParameterFloat("lfo_rate", "LFO Rate", 0.01f, 20.0f, 1.0f);
    audioProcessor.addParameter(lfoRate);
    
    lfoDepth = new AudioParameterFloat("lfo_depth", "LFO Depth", 0.0f, 1.0f, 0.0f);
    audioProcessor.addParameter(lfoDepth);
    
    lfoWaveform = new AudioParameterChoice("lfo_waveform", "LFO Waveform",
        StringArray{"Sine", "Triangle", "Sawtooth", "Square", "Random"}, 0);
    audioProcessor.addParameter(lfoWaveform);
    
    // Populate parameter map for fast lookup
    for (auto* param : audioProcessor.getParameters())
    {
        if (auto* rangedParam = dynamic_cast<juce::RangedAudioParameter*>(param))
        {
            // JUCE 7+ sometimes adds prefix, ensure we map the ID correctly
            parameterMap[rangedParam->paramID] = rangedParam;
        }
    }
}

juce::RangedAudioParameter* Parameters::getParameter(const juce::String& paramId) const
{
    auto it = parameterMap.find(paramId);
    if (it != parameterMap.end())
        return it->second;
    return nullptr;
}

} // namespace State
} // namespace CZ101

================================================================================
FILE: .\Source\State\Parameters.h
================================================================================
#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <map>
#include <string>

namespace CZ101 {
namespace State {

class Parameters
{
public:
    Parameters(juce::AudioProcessor& processor);
    
    void createParameters();
    
    // Oscillator parameters
    juce::AudioParameterFloat* osc1Level = nullptr;
    juce::AudioParameterChoice* osc1Waveform = nullptr;
    juce::AudioParameterFloat* osc2Level = nullptr;
    juce::AudioParameterChoice* osc2Waveform = nullptr;
    juce::AudioParameterFloat* osc2Detune = nullptr;
    juce::AudioParameterBool* hardSync = nullptr;
    juce::AudioParameterBool* ringMod = nullptr;
    juce::AudioParameterFloat* glideTime = nullptr;
    
    // DCA Envelope
    juce::AudioParameterFloat* dcaAttack = nullptr;
    juce::AudioParameterFloat* dcaDecay = nullptr;
    juce::AudioParameterFloat* dcaSustain = nullptr;
    juce::AudioParameterFloat* dcaRelease = nullptr;
    
    // DCW Envelope
    juce::AudioParameterFloat* dcwAttack = nullptr;
    juce::AudioParameterFloat* dcwDecay = nullptr;
    juce::AudioParameterFloat* dcwSustain = nullptr;
    juce::AudioParameterFloat* dcwRelease = nullptr;
    
    // Filter
    juce::AudioParameterFloat* filterCutoff = nullptr;
    juce::AudioParameterFloat* filterResonance = nullptr;
    juce::AudioParameterChoice* filterType = nullptr;
    
    // Effects
    juce::AudioParameterFloat* delayTime = nullptr;
    juce::AudioParameterFloat* delayFeedback = nullptr;
    juce::AudioParameterFloat* delayMix = nullptr;
    
    juce::AudioParameterFloat* reverbSize = nullptr;
    juce::AudioParameterFloat* reverbMix = nullptr;

    juce::AudioParameterFloat* chorusRate = nullptr;
    juce::AudioParameterFloat* chorusDepth = nullptr;
    juce::AudioParameterFloat* chorusMix = nullptr;
    
    // LFO
    juce::AudioParameterFloat* lfoRate = nullptr;
    juce::AudioParameterFloat* lfoDepth = nullptr; // Vibrato depth
    juce::AudioParameterChoice* lfoWaveform = nullptr;
    
    // Get parameter by ID helper
    juce::RangedAudioParameter* getParameter(const juce::String& paramId) const;
    
private:
    juce::AudioProcessor& audioProcessor;
    std::map<juce::String, juce::RangedAudioParameter*> parameterMap;
};

} // namespace State
} // namespace CZ101

================================================================================
FILE: .\Source\State\PresetManager.cpp
================================================================================
#include "PresetManager.h"
#include "Parameters.h"
#include "../Core/VoiceManager.h"

namespace CZ101 {
namespace State {

PresetManager::PresetManager(Parameters* parameters, Core::VoiceManager* vm)
    : parameters(parameters), voiceManager(vm)
{
    createFactoryPresets();
    // Default to first preset logic moved to PluginProcessor init
}

PresetManager::~PresetManager() = default;

void PresetManager::loadPreset(int index)
{
    if (index >= 0 && index < static_cast<int>(presets.size()))
    {
        currentPreset = presets[index];
        applyPresetToProcessor(); // Updates UI Knobs (ADSR) via Parameters
        
        // Update Voice Manager directly with full 8-stage data
        if (voiceManager)
        {
            applyEnvelopeToVoice(currentPreset.pitchEnv, 0);
            applyEnvelopeToVoice(currentPreset.dcwEnv, 1);
            applyEnvelopeToVoice(currentPreset.dcaEnv, 2);
        }
    }
}

void PresetManager::loadPresetFromStruct(const Preset& p)
{
    // Load the structure directly as the current preset
    currentPreset = p;

    // Apply to parameters and voice manager immediately
    applyPresetToProcessor();
    
    if (voiceManager)
    {
        applyEnvelopeToVoice(currentPreset.pitchEnv, 0);
        applyEnvelopeToVoice(currentPreset.dcwEnv, 1);
        applyEnvelopeToVoice(currentPreset.dcaEnv, 2);
    }
}

void PresetManager::applyPresetToProcessor()
{
    if (parameters)
    {
        for (const auto& [paramId, value] : currentPreset.parameters)
        {
            if (auto* param = parameters->getParameter(paramId))
            {
                float normalized = param->convertTo0to1(value);
                param->setValueNotifyingHost(normalized);
            }
        }
    }
}

void PresetManager::applyEnvelopeToVoice(const EnvelopeData& env, int type)
{
    if (!voiceManager) return;

    for (int i = 0; i < 8; ++i)
    {
        if (type == 0) voiceManager->setPitchStage(i, env.rates[i], env.levels[i]);
        else if (type == 1) voiceManager->setDCWStage(i, env.rates[i], env.levels[i]);
        else if (type == 2) voiceManager->setDCAStage(i, env.rates[i], env.levels[i]);
    }

    if (type == 0) {
        voiceManager->setPitchSustainPoint(env.sustainPoint);
        voiceManager->setPitchEndPoint(env.endPoint);
    } else if (type == 1) {
        voiceManager->setDCWSustainPoint(env.sustainPoint);
        voiceManager->setDCWEndPoint(env.endPoint);
    } else if (type == 2) {
        voiceManager->setDCASustainPoint(env.sustainPoint);
        voiceManager->setDCAEndPoint(env.endPoint);
    }
}

void PresetManager::savePreset(int index, const std::string& name)
{
    if (index >= 0 && index < static_cast<int>(presets.size()))
    {
        presets[index] = currentPreset;
        presets[index].name = name;
    }
}

// Helper to init default envelopes
static void initEnvelopes(Preset& p)
{
    // Pitch defaults to 0.5 (Unison)
    for (int i=0; i<8; ++i) { 
        p.pitchEnv.rates[i] = 0.99f; 
        p.pitchEnv.levels[i] = 0.5f; 
    }
    p.pitchEnv.sustainPoint = 0;
    p.pitchEnv.endPoint = 0;

    // DCW (Simple Open-Close)
    p.dcwEnv.rates[0] = 0.8f; p.dcwEnv.levels[0] = 1.0f;
    p.dcwEnv.rates[1] = 0.5f; p.dcwEnv.levels[1] = 0.0f;
    p.dcwEnv.sustainPoint = 0;
    p.dcwEnv.endPoint = 1; // Loop/End at 1 -> Release? 
    // CZ Logic: EndPoint is where it stops after KeyOff? No, EndPoint is end of Release?
    // Let's use standard ADSR-ish defaults.
    // Stage 0: Attack -> L1. Stage 1: Decay -> SusL. Stage 2: SusHold. Stage 3: Release -> 0.
    
    // DCW Init
    p.dcwEnv.rates[0] = 0.9f; p.dcwEnv.levels[0] = 1.0f;
    p.dcwEnv.rates[1] = 0.5f; p.dcwEnv.levels[1] = 0.5f; // Sustain
    p.dcwEnv.rates[2] = 0.9f; p.dcwEnv.levels[2] = 0.5f; // Hold
    p.dcwEnv.rates[3] = 0.5f; p.dcwEnv.levels[3] = 0.0f; // Release
    p.dcwEnv.sustainPoint = 2;
    p.dcwEnv.endPoint = 3;
    
    // DCA Init
    p.dcaEnv = p.dcwEnv; // Same shape
}

void PresetManager::createFactoryPresets()
{
    presets.clear();
    createBassPreset();
    createStringPreset();
    createBrassPreset();
    createLeadPreset();
    createBellsPreset(); 
    
    // Fill rest with Init
    for (int i = 5; i < 64; ++i)
    {
        Preset p;
        p.name = "Init User " + std::to_string(i);
        initEnvelopes(p);
        
        // Defaults
        p.parameters["osc1_waveform"] = 0.0f; p.parameters["osc1_level"] = 1.0f;
        p.parameters["osc2_waveform"] = 0.0f; p.parameters["osc2_level"] = 0.0f;
        p.parameters["osc2_detune"] = 0.0f;
        
        p.parameters["dcw_attack"] = 0.0f; p.parameters["dcw_decay"] = 0.0f; p.parameters["dcw_sustain"] = 1.0f; p.parameters["dcw_release"] = 0.0f;
        p.parameters["dca_attack"] = 0.0f; p.parameters["dca_decay"] = 0.0f; p.parameters["dca_sustain"] = 1.0f; p.parameters["dca_release"] = 0.0f;
        
        p.parameters["filter_cutoff"] = 20000.0f; p.parameters["filter_resonance"] = 0.1f;
        p.parameters["lfo_rate"] = 1.0f;
        p.parameters["delay_mix"] = 0.0f; p.parameters["reverb_mix"] = 0.0f;
        p.parameters["hard_sync"] = 0.0f;
        p.parameters["ring_mod"] = 0.0f;
        p.parameters["glide_time"] = 0.0f;
        
        // Chorus
        p.parameters["chorus_rate"] = 0.5f;
        p.parameters["chorus_depth"] = 2.0f;
        p.parameters["chorus_mix"] = 0.0f;

        presets.push_back(p);
    }
}

void PresetManager::createBassPreset()
{
    Preset p;
    p.name = "CZ Bass";
    initEnvelopes(p);
    
    // Oscillators: Saw + Square
    p.parameters["osc1_waveform"] = 1.0f; p.parameters["osc1_level"] = 1.0f;
    p.parameters["osc2_waveform"] = 2.0f; p.parameters["osc2_level"] = 0.8f;
    p.parameters["osc2_detune"] = -10.0f;
    
    // DCW (Plucky)
    p.dcwEnv.rates[0] = 0.95f; p.dcwEnv.levels[0] = 1.0f;
    p.dcwEnv.rates[1] = 0.6f;  p.dcwEnv.levels[1] = 0.2f; // Low sustain
    p.dcwEnv.rates[2] = 0.99f; p.dcwEnv.levels[2] = 0.2f; // Hold
    p.dcwEnv.rates[3] = 0.7f;  p.dcwEnv.levels[3] = 0.0f; // Release
    
    // DCA (Plucky)
    p.dcaEnv.rates[0] = 0.99f; p.dcaEnv.levels[0] = 1.0f;
    p.dcaEnv.rates[1] = 0.6f;  p.dcaEnv.levels[1] = 0.6f;
    p.dcaEnv.rates[2] = 0.99f; p.dcaEnv.levels[2] = 0.6f;
    p.dcaEnv.rates[3] = 0.6f;  p.dcaEnv.levels[3] = 0.0f;
    
    // Set parameters for UI sync
    p.parameters["dcw_attack"] = 0.01f; p.parameters["dcw_decay"] = 0.3f; p.parameters["dcw_sustain"] = 0.2f; p.parameters["dcw_release"] = 0.1f;
    p.parameters["dca_attack"] = 0.001f; p.parameters["dca_decay"] = 0.3f; p.parameters["dca_sustain"] = 0.6f; p.parameters["dca_release"] = 0.2f;

    // Filter
    p.parameters["filter_cutoff"] = 2000.0f;
    p.parameters["filter_resonance"] = 0.5f;

    // LFO
    p.parameters["lfo_rate"] = 0.5f;
    
    // Effects
    p.parameters["delay_time"] = 0.4f; p.parameters["delay_feedback"] = 0.3f; p.parameters["delay_mix"] = 0.1f;
    p.parameters["reverb_size"] = 0.3f; p.parameters["reverb_mix"] = 0.1f;
    
    p.parameters["hard_sync"] = 0.0f; // Off
    p.parameters["ring_mod"] = 0.0f; // Off
    p.parameters["glide_time"] = 0.0f;

    presets.push_back(p);
}

void PresetManager::createStringPreset()
{
    Preset p;
    p.name = "Vintage Strings";
    initEnvelopes(p);
    
    // Osc
    p.parameters["osc1_waveform"] = 1.0f; p.parameters["osc1_level"] = 0.7f; // Saw
    p.parameters["osc2_waveform"] = 1.0f; p.parameters["osc2_level"] = 0.7f; // Saw
    p.parameters["osc2_detune"] = 12.0f;
    
    // DCW: Slow Rise -> Dip -> Sustain
    // Gives a "bowing" friction articulation
    p.dcwEnv.rates[0] = 0.4f; p.dcwEnv.levels[0] = 0.8f; // Slow attack to bright
    p.dcwEnv.rates[1] = 0.3f; p.dcwEnv.levels[1] = 0.6f; // Fade slightly
    p.dcwEnv.rates[2] = 0.99f;p.dcwEnv.levels[2] = 0.6f; // Sustain
    p.dcwEnv.sustainPoint = 2;
    p.dcwEnv.endPoint = 3;
    
    // Release
    p.dcwEnv.rates[3] = 0.3f; p.dcwEnv.levels[3] = 0.0f; // Slow release

    
    // DCA: Similar shape but smoother
    p.dcaEnv = p.dcwEnv; 
    p.dcaEnv.rates[0] = 0.35f; p.dcaEnv.levels[0] = 1.0f;
    p.dcaEnv.rates[1] = 0.4f;  p.dcaEnv.levels[1] = 0.9f;
    p.dcaEnv.rates[2] = 0.99f; p.dcaEnv.levels[2] = 0.9f;
    p.dcaEnv.rates[3] = 0.3f; // Release matches DCW
    
    p.dcaEnv.sustainPoint = 2;
    p.dcaEnv.endPoint = 3;

    p.parameters["dcw_attack"] = 0.5f; p.parameters["dcw_decay"] = 0.5f; p.parameters["dcw_sustain"] = 0.6f; p.parameters["dcw_release"] = 0.8f;
    p.parameters["dca_attack"] = 0.6f; p.parameters["dca_decay"] = 0.5f; p.parameters["dca_sustain"] = 0.9f; p.parameters["dca_release"] = 0.8f;

    // Filter
    p.parameters["filter_cutoff"] = 8000.0f; // Open
    p.parameters["filter_resonance"] = 0.3f;

    // LFO (Vibrato)
    p.parameters["lfo_rate"] = 5.0f;
    p.parameters["lfo_depth"] = 0.1f; // Slight vibrato
    
    // Effects
    p.parameters["delay_time"] = 0.3f; p.parameters["delay_feedback"] = 0.5f; p.parameters["delay_mix"] = 0.4f;
    p.parameters["reverb_size"] = 0.8f; p.parameters["reverb_mix"] = 0.5f; // Lush reverb

    p.parameters["hard_sync"] = 0.0f;
    p.parameters["ring_mod"] = 0.0f;
    p.parameters["glide_time"] = 0.0f;

    presets.push_back(p);
}

void PresetManager::createBrassPreset()
{
    Preset p;
    p.name = "Synth Brass";
    initEnvelopes(p);
    
    p.parameters["osc1_waveform"] = 1.0f; p.parameters["osc1_level"] = 1.0f;
    p.parameters["osc2_waveform"] = 3.0f; p.parameters["osc2_level"] = 0.6f; // Triangle for body
    p.parameters["osc2_detune"] = 7.0f; // Slight detune
    
    // Pitch Envelope (Brass Attack: slight drop-up)
    // Stage 0: Fast drop to slightly fla (-2 semitones approx)
    p.pitchEnv.rates[0] = 0.9f; p.pitchEnv.levels[0] = 0.48f; 
    // Stage 1: Rise to slightly sharp (overshoot)
    p.pitchEnv.rates[1] = 0.6f; p.pitchEnv.levels[1] = 0.52f;
    // Stage 2: Settle to Unison
    p.pitchEnv.rates[2] = 0.4f; p.pitchEnv.levels[2] = 0.5f;
    // Stage 3: Sustain at Unison
    p.pitchEnv.rates[3] = 0.99f;p.pitchEnv.levels[3] = 0.5f;
    p.pitchEnv.sustainPoint = 3;
    p.pitchEnv.endPoint = 3;

    // DCW (Brass Swell)
    // Stage 0: Sharp attack
    p.dcwEnv.rates[0] = 0.85f; p.dcwEnv.levels[0] = 0.9f; 
    // Stage 1: Decay slightly to body
    p.dcwEnv.rates[1] = 0.7f;  p.dcwEnv.levels[1] = 0.7f;
    // Stage 2: Swell up a bit (breath)
    p.dcwEnv.rates[2] = 0.4f;  p.dcwEnv.levels[2] = 0.85f;
    // Stage 3: Sustain
    p.dcwEnv.rates[3] = 0.99f; p.dcwEnv.levels[3] = 0.85f;
    p.dcwEnv.sustainPoint = 3;
    p.dcwEnv.endPoint = 4; // Use stage 4 for release
    
    // Stage 4: Release
    p.dcwEnv.rates[4] = 0.6f; p.dcwEnv.levels[4] = 0.0f;
    
    // DCA (Standard ADSR-ish)
    p.dcaEnv.rates[0] = 0.85f; p.dcaEnv.levels[0] = 1.0f;
    p.dcaEnv.rates[1] = 0.7f;  p.dcaEnv.levels[1] = 0.9f;
    p.dcaEnv.rates[2] = 0.99f; p.dcaEnv.levels[2] = 0.9f;
    p.dcaEnv.rates[3] = 0.6f;  p.dcaEnv.levels[3] = 0.0f;
    p.dcaEnv.sustainPoint = 2;
    p.dcaEnv.endPoint = 3;
    
    // UI Params (Approximate for display)
    p.parameters["dcw_attack"] = 0.2f; p.parameters["dcw_decay"] = 0.3f; p.parameters["dcw_sustain"] = 0.8f; p.parameters["dcw_release"] = 0.4f;
    p.parameters["dca_attack"] = 0.1f; p.parameters["dca_decay"] = 0.2f; p.parameters["dca_sustain"] = 0.9f; p.parameters["dca_release"] = 0.4f;

    // Filter
    p.parameters["filter_cutoff"] = 5000.0f;
    p.parameters["filter_resonance"] = 0.6f;

    // LFO
    p.parameters["lfo_rate"] = 0.5f;
    
    // Effects
    p.parameters["delay_time"] = 0.0f; p.parameters["delay_feedback"] = 0.0f; p.parameters["delay_mix"] = 0.0f;
    p.parameters["reverb_size"] = 0.6f; p.parameters["reverb_mix"] = 0.3f;
    
    p.parameters["hard_sync"] = 0.0f;
    p.parameters["ring_mod"] = 0.0f;
    p.parameters["glide_time"] = 0.0f;

    presets.push_back(p);
}

void PresetManager::createLeadPreset()
{
    Preset p;
    p.name = "Solo Lead";
    initEnvelopes(p);
    
    p.parameters["osc1_waveform"] = 2.0f; p.parameters["osc1_level"] = 1.0f;
    p.parameters["osc2_waveform"] = 2.0f; p.parameters["osc2_level"] = 0.6f;
    p.parameters["osc2_detune"] = 0.0f;
    
    // DCW: Open
    p.dcwEnv.rates[0] = 0.99f; p.dcwEnv.levels[0] = 1.0f;
    p.dcwEnv.rates[1] = 0.99f; p.dcwEnv.levels[1] = 1.0f; // Sustain High
    p.dcwEnv.rates[2] = 0.99f; p.dcwEnv.levels[2] = 1.0f;
    p.dcwEnv.rates[3] = 0.5f;  p.dcwEnv.levels[3] = 0.0f;
    
    // DCA
    p.dcaEnv.rates[0] = 0.99f; p.dcaEnv.levels[0] = 1.0f; // Click attack
    p.dcaEnv.rates[1] = 0.9f;  p.dcaEnv.levels[1] = 1.0f;
    p.dcaEnv.rates[2] = 0.99f; p.dcaEnv.levels[2] = 1.0f;
    p.dcaEnv.rates[3] = 0.7f;  p.dcaEnv.levels[3] = 0.0f;
    
    p.parameters["dcw_attack"] = 0.0f; p.parameters["dcw_decay"] = 0.0f; p.parameters["dcw_sustain"] = 1.0f; p.parameters["dcw_release"] = 0.1f;
    p.parameters["dca_attack"] = 0.001f; p.parameters["dca_decay"] = 0.1f; p.parameters["dca_sustain"] = 1.0f; p.parameters["dca_release"] = 0.2f;
    
    // Filter
    p.parameters["filter_cutoff"] = 20000.0f;
    p.parameters["filter_resonance"] = 0.1f;

    // LFO
    p.parameters["lfo_rate"] = 4.0f;
    
    // Effects
    p.parameters["delay_time"] = 0.4f; p.parameters["delay_feedback"] = 0.5f; p.parameters["delay_mix"] = 0.4f;
    p.parameters["reverb_size"] = 0.4f; p.parameters["reverb_mix"] = 0.2f;
    
    p.parameters["hard_sync"] = 1.0f; // ENABLE HARD SYNC FOR LEAD
    p.parameters["ring_mod"] = 0.0f;
    p.parameters["glide_time"] = 0.2f; // ENABLE GLIDE FOR LEAD!
    p.parameters["chorus_rate"] = 0.5f; p.parameters["chorus_depth"] = 2.0f; p.parameters["chorus_mix"] = 0.0f;
    p.parameters["chorus_rate"] = 0.5f; p.parameters["chorus_depth"] = 2.0f; p.parameters["chorus_mix"] = 0.0f;

    presets.push_back(p);
}

void PresetManager::createBellsPreset()
{
    Preset p;
    p.name = "Digital Bells";
    initEnvelopes(p);
    
    p.parameters["osc1_waveform"] = 0.0f; p.parameters["osc1_level"] = 1.0f;
    p.parameters["osc2_waveform"] = 0.0f; p.parameters["osc2_level"] = 1.0f;
    p.parameters["osc2_detune"] = 350.0f; // Detune for bell
    
    // DCW: Short
    p.dcwEnv.rates[0] = 0.99f; p.dcwEnv.levels[0] = 1.0f;
    p.dcwEnv.rates[1] = 0.4f;  p.dcwEnv.levels[1] = 0.0f; // Long decay to 0
    p.dcwEnv.rates[2] = 0.99f; p.dcwEnv.levels[2] = 0.0f; // Hold 0
    p.dcwEnv.rates[3] = 0.5f;  p.dcwEnv.levels[3] = 0.0f;
    p.dcwEnv.sustainPoint = 2; // Sustain silence
    
    // DCA
    p.dcaEnv.rates[0] = 0.99f; p.dcaEnv.levels[0] = 1.0f;
    p.dcaEnv.rates[1] = 0.3f;  p.dcaEnv.levels[1] = 0.0f; // Long decay
    p.dcaEnv.rates[2] = 0.99f; p.dcaEnv.levels[2] = 0.0f;
    p.dcaEnv.rates[3] = 0.5f;  p.dcaEnv.levels[3] = 0.0f;
    
    p.parameters["dcw_attack"] = 0.0f; p.parameters["dcw_decay"] = 0.8f; p.parameters["dcw_sustain"] = 0.0f; p.parameters["dcw_release"] = 0.5f;
    p.parameters["dca_attack"] = 0.0f; p.parameters["dca_decay"] = 1.5f; p.parameters["dca_sustain"] = 0.0f; p.parameters["dca_release"] = 1.0f;

    // Filter
    p.parameters["filter_cutoff"] = 12000.0f;
    p.parameters["filter_resonance"] = 0.2f;

    // LFO
    p.parameters["lfo_rate"] = 6.0f;
    
    // Effects
    p.parameters["delay_time"] = 0.0f; p.parameters["delay_feedback"] = 0.0f; p.parameters["delay_mix"] = 0.0f;
    p.parameters["reverb_size"] = 0.9f; p.parameters["reverb_mix"] = 0.4f; // Spacey
    
    p.parameters["hard_sync"] = 0.0f;
    p.parameters["ring_mod"] = 1.0f; // ENABLE RING MOD FOR BELLS
    p.parameters["glide_time"] = 0.0f;

    presets.push_back(p);
}

} // namespace State
} // namespace CZ101
================================================================================
FILE: .\Source\State\PresetManager.h
================================================================================
#pragma once

#include <string>
#include <vector>
#include <map>

namespace CZ101 {
namespace State {

// Values for an 8-stage envelope
struct EnvelopeData
{
    float rates[8];
    float levels[8];
    int sustainPoint;
    int endPoint;
    
    EnvelopeData()
    {
        for (int i=0; i<8; ++i) { rates[i] = 0.5f; levels[i] = 0.0f; }
        sustainPoint = 2;
        endPoint = 3;
    }
};

struct Preset
{
    std::string name;
    std::map<std::string, float> parameters;
    
    // 8-Stage Data
    EnvelopeData dcwEnv;
    EnvelopeData dcaEnv;
    EnvelopeData pitchEnv;
    
    Preset() : name("Init") {}
    Preset(const std::string& n) : name(n) {}
};

class Parameters; 
} // namespace State
namespace Core { class VoiceManager; } // Forward declaration outside State
namespace State {

class PresetManager
{
public:
    PresetManager(Parameters* parameters, Core::VoiceManager* vm);
    ~PresetManager();
    
    void loadPreset(int index);
    void savePreset(int index, const std::string& name);
    void loadPresetFromStruct(const Preset& p); // Load directly (SysEx)
    
    const Preset& getCurrentPreset() const { return currentPreset; }
    const std::vector<Preset>& getPresets() const { return presets; }
    
private:
    std::vector<Preset> presets;
    Preset currentPreset;
    Parameters* parameters = nullptr;
    Core::VoiceManager* voiceManager = nullptr;
    
    void createFactoryPresets();
    void createBassPreset();
    void createLeadPreset();
    void createBrassPreset();
    void createStringPreset();
    void createBellsPreset();
    
    void applyPresetToProcessor();
    // Helper to push 8-stage data to VoiceManager
    void applyEnvelopeToVoice(const EnvelopeData& env, int type); // 0=Pitch, 1=DCW, 2=DCA
};

} // namespace State
} // namespace CZ101

================================================================================
FILE: .\Source\Tests\SysExTestMain.cpp
================================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <iomanip>

// Mocking dependencies via include path manipulation (handled in CMake or manually here for simplicity if allowed)
// Since we want to test "SysExManager.cpp" logic, we need to satisfy its include of "SysExManager.h" which includes "PresetManager.h"
// We will rely on CMake to PRIORITIZE "Source/Tests/Mocks" in include path.

#include "../MIDI/SysExManager.h"
#include <juce_core/juce_core.h>

// Minimal Mock for PresetManager (definition, since we link against it)
namespace CZ101 {
namespace State {

// Static storage for test verification
static Preset capturedPreset;
static bool presetWasLoaded = false;

PresetManager::PresetManager(Parameters*, Core::VoiceManager*) {}
void PresetManager::loadPreset(int) {}
void PresetManager::savePreset(int, const std::string&) {}
void PresetManager::createFactoryPresets() {}
void PresetManager::createBassPreset() {}
void PresetManager::createLeadPreset() {}
void PresetManager::createBrassPreset() {}
void PresetManager::createStringPreset() {}
void PresetManager::createBellsPreset() {}
void PresetManager::applyPresetToProcessor() {}
void PresetManager::applyEnvelopeToVoice(const EnvelopeData&, int) {}

// The critical method we are testing
void PresetManager::loadPresetFromStruct(const Preset& p) 
{
    capturedPreset = p;
    presetWasLoaded = true;
    std::cout << "[Test] Preset Loaded: " << p.name << std::endl;
}

PresetManager::~PresetManager() {} // Destructor now declared in header

}
}

// Stub for Parameters (if needed by linker, but PresetManager stub doesn't use it)
namespace CZ101 { namespace State { class Parameters {}; } }
namespace CZ101 { namespace Core { class VoiceManager {}; } }


int main(int argc, char* argv[])
{
    std::cout << "========================================" << std::endl;
    std::cout << "      CZ-101 SysEx Logic Test" << std::endl;
    std::cout << "========================================" << std::endl;

    if (argc < 2) {
        std::cerr << "Usage: CZ101SysExTest <path_to_syx_file>" << std::endl;
        return 1;
    }

    std::string filePath = argv[1];
    std::cout << "Loading file: " << filePath << std::endl;

    std::ifstream file(filePath, std::ios::binary | std::ios::ate);
    if (!file) {
        std::cerr << "Error: Could not open file." << std::endl;
        return 1;
    }

    std::streamsize size = file.tellg();
    file.seekg(0, std::ios::beg);

    std::vector<char> buffer(size);
    if (!file.read(buffer.data(), size)) {
        std::cerr << "Error: Could not read file." << std::endl;
        return 1;
    }

    std::cout << "Read " << size << " bytes." << std::endl;

    // Initialize mock dependencies
    CZ101::State::PresetManager mockPM(nullptr, nullptr);
    CZ101::MIDI::SysExManager sysExManager(mockPM);

    // Run Parsing
    sysExManager.handleSysEx(buffer.data(), (int)size);

    if (CZ101::State::presetWasLoaded) {
        std::cout << "SUCCESS: Preset decoded!" << std::endl;
        std::cout << "  Name: " << CZ101::State::capturedPreset.name << std::endl;
        
        // Brief Envelope Dump
        auto dumpEnv = [](const char* name, const CZ101::State::EnvelopeData& env) {
            std::cout << "  " << name << " Env:" << std::endl;
            for(int i=0; i<8; ++i) {
                if (env.levels[i] > 0.0f || env.rates[i] > 0.0f)
                    std::cout << "    Step " << i << ": R=" << env.rates[i] << " L=" << env.levels[i];
                if (i == env.sustainPoint) std::cout << " [SUS]";
                if (i == env.endPoint) std::cout << " [END]";
                if (env.levels[i] > 0.0f || env.rates[i] > 0.0f) std::cout << std::endl;
            }
        };

        dumpEnv("DCA", CZ101::State::capturedPreset.dcaEnv);
        dumpEnv("DCW", CZ101::State::capturedPreset.dcwEnv);
        dumpEnv("DCO", CZ101::State::capturedPreset.pitchEnv);
        
        return 0;
    } else {
        std::cerr << "FAILURE: handleSysEx did not trigger loadPresetFromStruct." << std::endl;
        // Maybe file wasn't recognized?
        return 1;
    }
}

================================================================================
FILE: .\Source\Tests\Mocks\State\PresetManager.h
================================================================================
#pragma once
#include <string>
#include <vector>
#include <map>

// Structs must match original
namespace CZ101 {
namespace State {

struct EnvelopeData
{
    float rates[8];
    float levels[8];
    int sustainPoint;
    int endPoint;
    EnvelopeData() {
        for (int i=0; i<8; ++i) { rates[i] = 0.5f; levels[i] = 0.0f; }
        sustainPoint = 2; endPoint = 3;
    }
};

struct Preset
{
    std::string name;
    std::map<std::string, float> parameters;
    EnvelopeData dcwEnv;
    EnvelopeData dcaEnv;
    EnvelopeData pitchEnv;
    Preset() : name("Init") {}
    Preset(const std::string& n) : name(n) {}
};

class Parameters; 
} 
namespace Core { class VoiceManager; } 
namespace State {

class PresetManager
{
public:
    PresetManager(Parameters* parameters, Core::VoiceManager* vm);
    ~PresetManager(); // Add destr
    
    void loadPreset(int index);
    void savePreset(int index, const std::string& name);
    void loadPresetFromStruct(const Preset& p); // Load directly (SysEx)
    
    // Stub getters
    const Preset& getCurrentPreset() const { return currentPreset; }
    const std::vector<Preset>& getPresets() const { return presets; }
    
private:
    std::vector<Preset> presets;
    Preset currentPreset;
    
    void createFactoryPresets();
    void createBassPreset();
    void createLeadPreset();
    void createBrassPreset();
    void createStringPreset();
    void createBellsPreset();
    
    void applyPresetToProcessor();
    void applyEnvelopeToVoice(const EnvelopeData& env, int type);
};

} 
} 

================================================================================
FILE: .\Source\UI\CZ101LookAndFeel.cpp
================================================================================
#include "CZ101LookAndFeel.h"

namespace CZ101 {
namespace UI {

CZ101LookAndFeel::CZ101LookAndFeel()
{
    primaryColour = juce::Colour(0xff2a2a2a);
    secondaryColour = juce::Colour(0xff4a9eff);
    textColour = juce::Colours::white;
    
    setColour(juce::Slider::thumbColourId, secondaryColour);
    setColour(juce::Slider::rotarySliderFillColourId, secondaryColour);
    setColour(juce::Slider::rotarySliderOutlineColourId, primaryColour);
}

void CZ101LookAndFeel::drawRotarySlider(juce::Graphics& g,
                                       int x, int y, int width, int height,
                                       float sliderPos,
                                       float rotaryStartAngle,
                                       float rotaryEndAngle,
                                       juce::Slider& slider)
{
    juce::ignoreUnused(slider);
    auto radius = juce::jmin(width / 2, height / 2) - 4.0f;
    auto centreX = x + width * 0.5f;
    auto centreY = y + height * 0.5f;
    auto rx = centreX - radius;
    auto ry = centreY - radius;
    auto rw = radius * 2.0f;
    auto angle = rotaryStartAngle + sliderPos * (rotaryEndAngle - rotaryStartAngle);
    
    // Fill
    g.setColour(primaryColour);
    g.fillEllipse(rx, ry, rw, rw);
    
    // Outline
    g.setColour(secondaryColour);
    g.drawEllipse(rx, ry, rw, rw, 2.0f);
    
    // Pointer
    juce::Path p;
    auto pointerLength = radius * 0.6f;
    auto pointerThickness = 3.0f;
    p.addRectangle(-pointerThickness * 0.5f, -radius, pointerThickness, pointerLength);
    p.applyTransform(juce::AffineTransform::rotation(angle).translated(centreX, centreY));
    
    g.setColour(secondaryColour);
    g.fillPath(p);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\CZ101LookAndFeel.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>

namespace CZ101 {
namespace UI {

class CZ101LookAndFeel : public juce::LookAndFeel_V4
{
public:
    CZ101LookAndFeel();
    
    void drawRotarySlider(juce::Graphics& g,
                         int x, int y, int width, int height,
                         float sliderPos,
                         float rotaryStartAngle,
                         float rotaryEndAngle,
                         juce::Slider& slider) override;
    
private:
    juce::Colour primaryColour;
    juce::Colour secondaryColour;
    juce::Colour textColour;
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\LCDDisplay.h
================================================================================
/*
  ==============================================================================

    LCDDisplay.h
    Created: 15 Dec 2025
    Author:  Antigravity

  ==============================================================================
*/

#pragma once

#include <juce_gui_basics/juce_gui_basics.h>

namespace CZ101 {
namespace UI {

class LCDDisplay : public juce::Component
{
public:
    LCDDisplay()
    {
        setOpaque(true);
    }

    void setText(const juce::String& line1, const juce::String& line2)
    {
        m_line1 = line1;
        m_line2 = line2;
        repaint();
    }

    void paint(juce::Graphics& g) override
    {
        auto bounds = getLocalBounds().toFloat();
        
        // Background (Dark Blue/Black)
        g.setFillType(juce::Colour(0xFF101520)); 
        g.fillRoundedRectangle(bounds, 4.0f);
        
        // Inner Bezel / Glow
        g.setColour(juce::Colour(0xFF203040));
        g.drawRoundedRectangle(bounds.reduced(1.0f), 4.0f, 2.0f);
        
        // Text (LCD Blue)
        g.setColour(juce::Colour(0xFF00BFFF));
        g.setFont(juce::FontOptions("Courier New", 16.0f, juce::Font::bold));
        
        // Draw lines
        g.drawText(m_line1, bounds.reduced(10, 0).removeFromTop(bounds.getHeight() / 2), juce::Justification::centredLeft, true);
        g.drawText(m_line2, bounds.reduced(10, 0).removeFromBottom(bounds.getHeight() / 2), juce::Justification::centredLeft, true);
        
        // Imitate pixel grid (optional scanlines)
        g.setColour(juce::Colours::black.withAlpha(0.1f));
        for (int y = 0; y < getHeight(); y += 2)
            g.fillRect(0, y, getWidth(), 1);
    }

private:
    juce::String m_line1 = "CZ-101 EMULATOR";
    juce::String m_line2 = "V1.1 READY";
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\EnvelopeEditor.cpp
================================================================================
#include "EnvelopeEditor.h"

namespace CZ101 {
namespace UI {

EnvelopeEditor::EnvelopeEditor(CZ101AudioProcessor& processor, EnvelopeType type)
    : audioProcessor(processor), envType(type)
{
    // Initialize with dummy default data
    for (int i = 0; i < 8; ++i)
    {
        rates[i] = 0.5f;
        levels[i] = (i % 2 == 0) ? 1.0f : 0.0f;
    }
    
    updateData();
}

EnvelopeEditor::~EnvelopeEditor()
{
}

void EnvelopeEditor::updateData()
{
    auto& vm = audioProcessor.getVoiceManager();
    
    for (int i = 0; i < 8; ++i)
    {
        float r = 0.5f;
        float l = 0.0f;
        
        if (envType == EnvelopeType::DCA)
            vm.getDCAStage(i, r, l);
        else if (envType == EnvelopeType::DCW)
            vm.getDCWStage(i, r, l);
        else if (envType == EnvelopeType::PITCH)
            vm.getPitchStage(i, r, l);
            
        rates[i] = r;
        levels[i] = l;
    }
    
    if (envType == EnvelopeType::DCA)
    {
        sustainPoint = vm.getDCASustainPoint();
        endPoint = vm.getDCAEndPoint();
    }
    else if (envType == EnvelopeType::DCW)
    {
        sustainPoint = vm.getDCWSustainPoint();
        endPoint = vm.getDCWEndPoint();
    }
    else if (envType == EnvelopeType::PITCH)
    {
        sustainPoint = vm.getPitchSustainPoint();
        endPoint = vm.getPitchEndPoint();
    }
    
    repaint();
}

void EnvelopeEditor::paint(juce::Graphics& g)
{
    // Background
    g.fillAll(juce::Colours::black.withAlpha(0.8f));
    g.setColour(juce::Colours::darkgrey);
    g.drawRect(getLocalBounds(), 1);
    
    auto bounds = getLocalBounds().toFloat();
    float w = bounds.getWidth();
    float h = bounds.getHeight();
    
    // Draw grid/guides
    g.setColour(juce::Colours::white.withAlpha(0.1f));
    for (int i = 0; i < 8; ++i)
    {
        float x = w * (static_cast<float>(i) / 8.0f);
        g.drawVerticalLine(static_cast<int>(x), 0.0f, h);
    }
    
    // Draw Path
    juce::Colour pathColour;
    if (envType == EnvelopeType::DCA) pathColour = juce::Colours::cyan;
    else if (envType == EnvelopeType::DCW) pathColour = juce::Colours::orange;
    else pathColour = juce::Colours::magenta; // PITCH

    g.setColour(pathColour);
    juce::Path p;
    
    // Start at 0,0 (bottom left-ish logic, but CZ starts at previous level. Assume 0 for start)
    // Actually CZ starts at 'Level' of current step? No, it moves TO Level.
    // Stage I: Start Level -> Target Level at Rate.
    // We need to simulate the path for visualization.
    
    float currentX = 0.0f;
    float currentY = h; // 0 level is bottom
    
    p.startNewSubPath(currentX, currentY);
    
    // We visualize cumulative time on X axis?
    // Or constant width per stage? 
    // Constant width per stage is easier to edit. Time-based is hard if rate is 0 (long time).
    // Let's use constant width for editing (CZ-101 LCD style).
    
    float stepWidth = w / 8.0f;
    
    for (int i = 0; i < 8; ++i)
    {
        float nextX = (i + 1) * stepWidth;
        // Level 0..1 -> h..0
        float val = levels[i];
        float nextY = h - (val * h);
        
        // Rate affects slope, but here X is fixed stages. 
        // We can visualize Rate as the steepness? No, X is time.
        // Let's draw the target point.
        
        p.lineTo(nextX, nextY);
        
        // Dotted line for sustain point
        if (i == sustainPoint)
        {
            g.setColour(juce::Colours::yellow);
            g.drawVerticalLine(static_cast<int>(nextX), 0.0f, h);
            g.drawText("SUS", static_cast<int>(nextX) - 20, 0, 40, 15, juce::Justification::centred);
        }
        if (i == endPoint)
        {
            g.setColour(juce::Colours::red);
            g.drawVerticalLine(static_cast<int>(nextX), 0.0f, h);
            g.drawText("END", static_cast<int>(nextX) - 20, 15, 40, 15, juce::Justification::centred);
        }
        
        // Draw Handle
        g.setColour(i == selectedStage ? juce::Colours::white : juce::Colours::lightgrey);
        g.fillEllipse(nextX - 4, nextY - 4, 8, 8);
        
        // Revert color for path
        // Revert color for path
        g.setColour(pathColour);
    }
    
    g.strokePath(p, juce::PathStrokeType(2.0f));
}

void EnvelopeEditor::resized()
{
}

void EnvelopeEditor::mouseDown(const juce::MouseEvent& e)
{
    float w = static_cast<float>(getWidth());
    float stepWidth = w / 8.0f;
    
    // Find clicked stage
    int stage = static_cast<int>(e.position.x / stepWidth);
    if (stage >= 0 && stage < 8)
    {
        selectedStage = stage;
        repaint();
    }
}

void EnvelopeEditor::mouseDrag(const juce::MouseEvent& e)
{
    if (selectedStage >= 0 && selectedStage < 8)
    {
        // Y controls Level
        float y = std::clamp(e.position.y / static_cast<float>(getHeight()), 0.0f, 1.0f);
        levels[selectedStage] = 1.0f - y; // Invert because screen Y is top-down
        
        // X dragging within the slot could control Rate? 
        // Or Shift+Drag?
        // Let's say drag Up/Down = Level.
        // Drag Left/Right = Rate.
        
        // It's tricky to map X to rate if X is also stage index.
        // Let's treat Rate as a separate control for now? 
        // No, let's use vertical drag for level, horizontal delta for rate?
        // Simplest: Drag Y = Level. 
        // Rate is hard to visualize in fixed-width mode without textual feedback.
        // Let's assume Drag Y = Level for now.
        
        sendUpdateToProcessor(selectedStage);
        repaint();
    }
}

void EnvelopeEditor::mouseUp(const juce::MouseEvent& e)
{
    juce::ignoreUnused(e);
}

void EnvelopeEditor::sendUpdateToProcessor(int stageIndex)
{
    // Update Voice Manager directly
    // Note: In a real plugin we should use parameters to support automation
    // But we are in "Prototype / Phase 2" to verify engine.
    
    float lvl = levels[stageIndex];
    float rate = rates[stageIndex]; // Fixed for now
    
    auto& vm = audioProcessor.getVoiceManager(); // We need to expose this getter in Processor!
    
    if (envType == EnvelopeType::DCA)
    {
        vm.setDCAStage(stageIndex, rate, lvl);
    }
    else if (envType == EnvelopeType::DCW)
    {
        vm.setDCWStage(stageIndex, rate, lvl);
    }
    else if (envType == EnvelopeType::PITCH)
    {
        vm.setPitchStage(stageIndex, rate, lvl);
    }
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\EnvelopeEditor.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>
#include "../../PluginProcessor.h"

namespace CZ101 {
namespace UI {

class EnvelopeEditor : public juce::Component
{
public:
    enum class EnvelopeType { DCW, DCA, PITCH };
    
    EnvelopeEditor(CZ101AudioProcessor& processor, EnvelopeType type);
    ~EnvelopeEditor() override;
    
    void paint(juce::Graphics& g) override;
    void resized() override;
    
    // Updates local data from processor/preset
    void updateData(); 
    
    // Drag handlers
    void mouseDown(const juce::MouseEvent& e) override;
    void mouseDrag(const juce::MouseEvent& e) override;
    void mouseUp(const juce::MouseEvent& e) override;

private:
    CZ101AudioProcessor& audioProcessor;
    EnvelopeType envType;
    
    // Local copy of stage data for drawing/editing
    // 8 stages, rate (0-1), level (0-1)
    struct Point { float x; float y; };
    std::array<float, 8> rates;
    std::array<float, 8> levels;
    int sustainPoint = 2;
    int endPoint = 3;
    
    int selectedStage = -1;
    
    // Helper to map Rate(0-1)/Level(0-1) to screen coordinates
    juce::Point<float> getScreenPoint(int stageIndex, float w, float h);
    
    void sendUpdateToProcessor(int stageIndex);
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\Knob.cpp
================================================================================
#include "Knob.h"

namespace CZ101 {
namespace UI {

Knob::Knob(const juce::String& name)
    : juce::Slider(name)
{
    setSliderStyle(juce::Slider::RotaryHorizontalVerticalDrag);
    setTextBoxStyle(juce::Slider::TextBoxBelow, false, 50, 14);
    
    label.setText(name, juce::dontSendNotification);
    label.setJustificationType(juce::Justification::centred);
    label.setColour(juce::Label::textColourId, juce::Colours::white);
    label.setFont(juce::Font(12.0f));
    addAndMakeVisible(label);
}

void Knob::paint(juce::Graphics& g)
{
    juce::Slider::paint(g);
}

void Knob::resized()
{
    auto bounds = getLocalBounds();
    // Label at Top
    auto labelArea = bounds.removeFromTop(14);
    label.setBounds(labelArea);
    
    // Slider takes the rest (and puts TextBox at bottom)
    juce::Slider::resized();
}

void Knob::setLabel(const juce::String& text)
{
    labelText = text;
    label.setText(text, juce::dontSendNotification);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\Knob.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>

namespace CZ101 {
namespace UI {

class Knob : public juce::Slider
{
public:
    Knob(const juce::String& name);
    
    void paint(juce::Graphics& g) override;
    void resized() override;
    
    void setLabel(const juce::String& text);
    
private:
    juce::String labelText;
    juce::Label label;
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\MIDIActivityIndicator.cpp
================================================================================
#include "MIDIActivityIndicator.h"

namespace CZ101 {
namespace UI {

MIDIActivityIndicator::MIDIActivityIndicator()
{
    startTimer(30);
}

void MIDIActivityIndicator::paint(juce::Graphics& g)
{
    auto bounds = getLocalBounds().toFloat();
    
    g.setColour(juce::Colour(0xff2a2a2a));
    g.fillEllipse(bounds);
    
    if (brightness > 0.0f)
    {
        auto colour = juce::Colour(0xff4a9eff).withAlpha(brightness);
        g.setColour(colour);
        g.fillEllipse(bounds.reduced(2.0f));
    }
}

void MIDIActivityIndicator::timerCallback()
{
    if (isActive)
    {
        brightness = 1.0f;
        isActive = false;
    }
    else
    {
        brightness -= FADE_SPEED;
        if (brightness < 0.0f)
            brightness = 0.0f;
    }
    
    repaint();
}

void MIDIActivityIndicator::triggerActivity()
{
    isActive = true;
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\MIDIActivityIndicator.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>

namespace CZ101 {
namespace UI {

class MIDIActivityIndicator : public juce::Component, public juce::Timer
{
public:
    MIDIActivityIndicator();
    
    void paint(juce::Graphics& g) override;
    void timerCallback() override;
    
    void triggerActivity();
    
private:
    bool isActive = false;
    float brightness = 0.0f;
    
    static constexpr float FADE_SPEED = 0.1f;
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\PresetBrowser.cpp
================================================================================
#include "PresetBrowser.h"

namespace CZ101 {
namespace UI {

PresetBrowser::PresetBrowser()
{
    addAndMakeVisible(presetCombo);
    addAndMakeVisible(prevButton);
    addAndMakeVisible(nextButton);
    
    prevButton.setButtonText("<");
    nextButton.setButtonText(">");
    
    // updatePresetList() cannot be called here yet as manager is null
    
    presetCombo.onChange = [this]()
    {
        selectPreset(presetCombo.getSelectedItemIndex());
    };
    
    prevButton.onClick = [this]()
    {
        int current = presetCombo.getSelectedItemIndex();
        if (current > 0)
            presetCombo.setSelectedItemIndex(current - 1);
    };
    
    nextButton.onClick = [this]()
    {
        int current = presetCombo.getSelectedItemIndex();
        if (current < presetCombo.getNumItems() - 1)
            presetCombo.setSelectedItemIndex(current + 1);
    };
}

void PresetBrowser::setPresetManager(State::PresetManager* pm)
{
    presetManager = pm;
    if (presetManager)
        updatePresetList();
}

void PresetBrowser::paint(juce::Graphics& g)
{
    g.fillAll(juce::Colour(0xff2a2a2a));
}

void PresetBrowser::resized()
{
    auto bounds = getLocalBounds().reduced(5);
    
    prevButton.setBounds(bounds.removeFromLeft(30));
    bounds.removeFromLeft(5);
    nextButton.setBounds(bounds.removeFromRight(30));
    bounds.removeFromRight(5);
    
    presetCombo.setBounds(bounds);
}

void PresetBrowser::updatePresetList()
{
    presetCombo.clear();
    
    if (presetManager == nullptr) return;
    
    const auto& presets = presetManager->getPresets();
    for (size_t i = 0; i < presets.size(); ++i)
    {
        presetCombo.addItem(presets[i].name, static_cast<int>(i) + 1);
    }
    
    presetCombo.setSelectedItemIndex(0);
}

void PresetBrowser::selectPreset(int index)
{
    if (presetManager)
        presetManager->loadPreset(index);

    if (onPresetSelected)
        onPresetSelected(index);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\PresetBrowser.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>
#include "../../State/PresetManager.h"

namespace CZ101 {
namespace UI {

class PresetBrowser : public juce::Component
{
public:
    PresetBrowser();
    void setPresetManager(State::PresetManager* pm);
    
    void paint(juce::Graphics& g) override;
    void resized() override;
    
    std::function<void(int)> onPresetSelected;
    
private:
    State::PresetManager* presetManager = nullptr;
    juce::ComboBox presetCombo;
    juce::TextButton prevButton;
    juce::TextButton nextButton;
    
    void updatePresetList();
    void selectPreset(int index);
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\WaveformDisplay.cpp
================================================================================
#include "WaveformDisplay.h"
#include <cmath>

namespace CZ101 {
namespace UI {

WaveformDisplay::WaveformDisplay()
{
    waveformData.resize(256);
    generateWaveform();
    startTimer(50);
}

void WaveformDisplay::paint(juce::Graphics& g)
{
    auto bounds = getLocalBounds().toFloat();
    
    g.fillAll(juce::Colour(0xff1a1a1a));
    
    g.setColour(juce::Colour(0xff2a2a2a));
    g.drawRect(bounds, 2.0f);
    
    juce::Path path;
    auto width = bounds.getWidth();
    auto height = bounds.getHeight();
    auto centerY = bounds.getCentreY();
    
    path.startNewSubPath(bounds.getX(), centerY);
    
    for (size_t i = 0; i < waveformData.size(); ++i)
    {
        float x = bounds.getX() + (i / static_cast<float>(waveformData.size())) * width;
        float y = centerY - waveformData[i] * (height * 0.4f);
        path.lineTo(x, y);
    }
    
    g.setColour(juce::Colour(0xff4a9eff));
    g.strokePath(path, juce::PathStrokeType(2.0f));
}

void WaveformDisplay::timerCallback()
{
    repaint();
}

void WaveformDisplay::setWaveform(int waveformType)
{
    currentWaveform = waveformType;
    generateWaveform();
}

void WaveformDisplay::generateWaveform()
{
    constexpr float TWO_PI = 6.28318530718f;
    
    for (size_t i = 0; i < waveformData.size(); ++i)
    {
        float phase = i / static_cast<float>(waveformData.size());
        
        switch (currentWaveform)
        {
            case 0: // Sine
                waveformData[i] = std::sin(TWO_PI * phase);
                break;
            case 1: // Sawtooth
                waveformData[i] = 2.0f * phase - 1.0f;
                break;
            case 2: // Square
                waveformData[i] = (phase < 0.5f) ? 1.0f : -1.0f;
                break;
            case 3: // Triangle
                if (phase < 0.25f)
                    waveformData[i] = 4.0f * phase;
                else if (phase < 0.75f)
                    waveformData[i] = 2.0f - 4.0f * phase;
                else
                    waveformData[i] = 4.0f * phase - 4.0f;
                break;
            default:
                waveformData[i] = 0.0f;
        }
    }
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\WaveformDisplay.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>
#include <vector>

namespace CZ101 {
namespace UI {

class WaveformDisplay : public juce::Component, public juce::Timer
{
public:
    WaveformDisplay();
    
    void paint(juce::Graphics& g) override;
    void timerCallback() override;
    
    void setWaveform(int waveformType);
    
private:
    std::vector<float> waveformData;
    int currentWaveform = 0;
    
    void generateWaveform();
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\DSPHelpers.h
================================================================================
#pragma once

#include <cmath>
#include <algorithm>

namespace CZ101 {
namespace Utils {

class DSPHelpers
{
public:
    static float dbToGain(float db)
    {
        return std::pow(10.0f, db / 20.0f);
    }
    
    static float gainToDb(float gain)
    {
        return 20.0f * std::log10(std::max(gain, 0.00001f));
    }
    
    static float midiNoteToFrequency(int midiNote)
    {
        return 440.0f * std::pow(2.0f, (midiNote - 69) / 12.0f);
    }
    
    static int frequencyToMidiNote(float frequency)
    {
        return static_cast<int>(69 + 12 * std::log2(frequency / 440.0f));
    }
    
    static float lerp(float a, float b, float t)
    {
        return a + t * (b - a);
    }
    
    static float clamp(float value, float min, float max)
    {
        return std::clamp(value, min, max);
    }
    
    static float mapRange(float value, float inMin, float inMax, float outMin, float outMax)
    {
        return outMin + (value - inMin) * (outMax - outMin) / (inMax - inMin);
    }
};

} // namespace Utils
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\PerformanceMonitor.cpp
================================================================================
#include "PerformanceMonitor.h"
#include <algorithm>

namespace CZ101 {
namespace Utils {

PerformanceMonitor::PerformanceMonitor()
{
}

void PerformanceMonitor::startMeasurement()
{
    startTime = std::chrono::high_resolution_clock::now();
}

void PerformanceMonitor::stopMeasurement()
{
    endTime = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(endTime - startTime);
    double timeMs = duration.count() / 1000.0;
    
    totalTime += timeMs;
    peakTime = std::max(peakTime, timeMs);
    measurementCount++;
}

double PerformanceMonitor::getAverageCpuUsage() const
{
    if (measurementCount == 0)
        return 0.0;
    
    return totalTime / measurementCount;
}

double PerformanceMonitor::getPeakCpuUsage() const
{
    return peakTime;
}

int PerformanceMonitor::getVoiceCount() const
{
    return currentVoiceCount;
}

void PerformanceMonitor::setVoiceCount(int count)
{
    currentVoiceCount = count;
}

void PerformanceMonitor::reset()
{
    totalTime = 0.0;
    peakTime = 0.0;
    measurementCount = 0;
}

} // namespace Utils
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\PerformanceMonitor.h
================================================================================
#pragma once

#include <chrono>
#include <string>

namespace CZ101 {
namespace Utils {

class PerformanceMonitor
{
public:
    PerformanceMonitor();
    
    void startMeasurement();
    void stopMeasurement();
    
    double getAverageCpuUsage() const;
    double getPeakCpuUsage() const;
    int getVoiceCount() const;
    
    void setVoiceCount(int count);
    void reset();
    
private:
    std::chrono::high_resolution_clock::time_point startTime;
    std::chrono::high_resolution_clock::time_point endTime;
    
    double totalTime = 0.0;
    double peakTime = 0.0;
    int measurementCount = 0;
    int currentVoiceCount = 0;
};

} // namespace Utils
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\SmoothedValue.h
================================================================================
#pragma once

#include <cmath>

namespace CZ101 {
namespace Utils {

template<typename FloatType>
class SmoothedValue
{
public:
    SmoothedValue() = default;
    
    void reset(FloatType initialValue) noexcept
    {
        currentValue = initialValue;
        target = initialValue;
    }
    
    void setTargetValue(FloatType newTarget) noexcept
    {
        target = newTarget;
    }
    
    void setSmoothingTime(FloatType timeInSeconds, double sampleRate) noexcept
    {
        auto numSamples = static_cast<int>(timeInSeconds * sampleRate);
        setNumSteps(numSamples);
    }
    
    void setNumSteps(int numSteps) noexcept
    {
        stepsToTarget = numSteps;
        countdown = stepsToTarget;
        
        if (countdown > 0)
            step = (target - currentValue) / static_cast<FloatType>(countdown);
        else
            step = 0;
    }
    
    FloatType getNextValue() noexcept
    {
        if (countdown <= 0)
        {
            currentValue = target;
            return currentValue;
        }
        
        --countdown;
        currentValue += step;
        return currentValue;
    }
    
    FloatType getCurrentValue() const noexcept
    {
        return currentValue;
    }
    
    FloatType getTargetValue() const noexcept
    {
        return target;
    }
    
    bool isSmoothing() const noexcept
    {
        return countdown > 0;
    }

private:
    FloatType currentValue = 0;
    FloatType target = 0;
    FloatType step = 0;
    int countdown = 0;
    int stepsToTarget = 0;
};

} // namespace Utils
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\StringHelpers.h
================================================================================
#pragma once

#include <string>
#include <sstream>
#include <iomanip>

namespace CZ101 {
namespace Utils {

class StringHelpers
{
public:
    static std::string formatFrequency(float hz)
    {
        std::ostringstream oss;
        if (hz >= 1000.0f)
            oss << std::fixed << std::setprecision(2) << (hz / 1000.0f) << " kHz";
        else
            oss << std::fixed << std::setprecision(1) << hz << " Hz";
        return oss.str();
    }
    
    static std::string formatTime(float seconds)
    {
        std::ostringstream oss;
        if (seconds >= 1.0f)
            oss << std::fixed << std::setprecision(2) << seconds << " s";
        else
            oss << std::fixed << std::setprecision(1) << (seconds * 1000.0f) << " ms";
        return oss.str();
    }
    
    static std::string formatPercentage(float value)
    {
        std::ostringstream oss;
        oss << std::fixed << std::setprecision(1) << (value * 100.0f) << "%";
        return oss.str();
    }
    
    static std::string formatDecibels(float db)
    {
        std::ostringstream oss;
        oss << std::fixed << std::setprecision(1) << db << " dB";
        return oss.str();
    }
};

} // namespace Utils
} // namespace CZ101
