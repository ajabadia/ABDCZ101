
================================================================================
FILE: .\Source\PluginEditor.cpp
================================================================================
#include "PluginProcessor.h"
#include "PluginEditor.h"

CZ101AudioProcessorEditor::CZ101AudioProcessorEditor(CZ101AudioProcessor& p)
    : AudioProcessorEditor(&p), audioProcessor(p),
      // Inicializar todas las secciones y componentes principales
      oscSection(p),
      effectsSection(p),
      filterLfoSection(p),
      pitchEditor(p, CZ101::UI::EnvelopeEditor::EnvelopeType::PITCH),
      dcwEditor(p, CZ101::UI::EnvelopeEditor::EnvelopeType::DCW),
      dcaEditor(p, CZ101::UI::EnvelopeEditor::EnvelopeType::DCA),
      keyboardComponent(keyboardState, juce::MidiKeyboardComponent::horizontalKeyboard)
{
    juce::LookAndFeel::setDefaultLookAndFeel(&customLookAndFeel);
    openGLContext.attachTo(*this);

    // Hacer visibles todos los componentes y secciones
    addAndMakeVisible(oscSection);
    addAndMakeVisible(effectsSection);
    addAndMakeVisible(filterLfoSection);
    addAndMakeVisible(waveformDisplay);
    addAndMakeVisible(keyboardComponent);
    addAndMakeVisible(lcdDisplay);
    addAndMakeVisible(envelopeTabs);
    
    // Header Components
    addAndMakeVisible(presetBrowser);
    presetBrowser.setPresetManager(&audioProcessor.getPresetManager());
    
    // Wire Mode Switching
    auto& lcdMgr = audioProcessor.getLCDStateManager();
    presetBrowser.onSystemModeRequested = [&lcdMgr]() { lcdMgr.setMode(CZ101::UI::LCDStateManager::Mode::SYSTEM); };
    
    presetBrowser.onInitRequested = [this](int id) {
        auto s = InitSection::ALL;
        if (id == 101) s = InitSection::DCO;
        else if (id == 102) s = InitSection::DCW;
        else if (id == 103) s = InitSection::DCA;
        else if (id == 104) s = InitSection::VIBRATO;
        else if (id == 105) s = InitSection::ALL;
        
        audioProcessor.initializeSection(s);
    };
    
    // Optional: Switch to Normal/Edit when preset loaded?
    // Let's stick to current mode or default to EDIT for now as requested.
    // implementation: presetBrowser.onPresetSelected = ... (already handled inside?)
    
    addAndMakeVisible(midiIndicator);
    addAndMakeVisible(loadSysExButton);
    addAndMakeVisible(saveSysExButton);
    addAndMakeVisible(protectButton);
    addAndMakeVisible(midiOutputSelector);

    // Protect Button Styling
    protectButton.setColour(juce::ToggleButton::tickColourId, juce::Colours::red);
    protectButton.setColour(juce::ToggleButton::tickDisabledColourId, juce::Colours::grey);
    protectButton.setButtonText("Protect");
    
    // Attachment
    protectAttachment = std::make_unique<juce::AudioProcessorValueTreeState::ButtonAttachment>(
        audioProcessor.getParameters().getAPVTS(), "PROTECT_SWITCH", protectButton);
    
    // LCD Buttons
    addAndMakeVisible(cursorLeft);
    addAndMakeVisible(cursorRight);
    addAndMakeVisible(valueUp);
    addAndMakeVisible(valueDown);
    
    // Connect LCD State Manager
    // auto& lcdMgr = audioProcessor.getLCDStateManager(); // Removed redefinition
    lcdDisplay.setStateManager(&lcdMgr);
    
    cursorLeft.onClick  = [&lcdMgr]() { lcdMgr.onCursorLeft(); };
    cursorRight.onClick = [&lcdMgr]() { lcdMgr.onCursorRight(); };
    valueUp.onClick     = [&lcdMgr]() { lcdMgr.onValueUp(); };
    valueDown.onClick   = [&lcdMgr]() { lcdMgr.onValueDown(); };

    // Conexiones y Listeners
    keyboardState.addListener(this);
    // ... (otros listeners)

    // Tabs de Envolventes
    envelopeTabs.addTab("PITCH", juce::Colours::magenta, &pitchEditor, false);
    envelopeTabs.addTab("DCW", juce::Colours::orange, &dcwEditor, false);
    envelopeTabs.addTab("DCA", juce::Colours::cyan, &dcaEditor, false);

    // Widen UI
    setSize(1024, 768); 
    startTimerHz(60);
}

CZ101AudioProcessorEditor::~CZ101AudioProcessorEditor()
{
    stopTimer();
    keyboardState.removeListener(this);
    openGLContext.detach();
    juce::LookAndFeel::setDefaultLookAndFeel(nullptr);
}

void CZ101AudioProcessorEditor::paint(juce::Graphics& g) { g.fillAll(juce::Colour(0xff0a0e14)); }

// --- LAYOUT FINAL REVISADO ---
void CZ101AudioProcessorEditor::resized()
{
    auto area = getLocalBounds();
    keyboardComponent.setBounds(area.removeFromBottom(80));
    
    // Header (Wider)
    auto headerArea = area.removeFromTop(60); // Increased height for buttons
    
    // Preset Browser (Left)
    presetBrowser.setBounds(headerArea.removeFromLeft(220).reduced(5));
    
    // SysEx & MIDI (Right)
    // SysEx & MIDI (Right)
    auto headerRight = headerArea.removeFromRight(380); // Increased from 300 to 380
    loadSysExButton.setBounds(headerRight.removeFromLeft(70).reduced(5));
    saveSysExButton.setBounds(headerRight.removeFromLeft(70).reduced(5));
    protectButton.setBounds(headerRight.removeFromLeft(80).reduced(5)); // Added Protect
    midiOutputSelector.setBounds(headerRight.removeFromLeft(100).reduced(5));
    midiIndicator.setBounds(headerRight.reduced(5)); 
    
    // Center: LCD + Buttons
    // LCD takes remaining left, Buttons take right-most of center
    auto centerArea = headerArea;
    auto buttonsArea = centerArea.removeFromRight(60); // Space for 2 cols of buttons
    
    lcdDisplay.setBounds(centerArea.reduced(5)); 
    
    // Button Layout (2x2 Grid)
    auto topRow = buttonsArea.removeFromTop(buttonsArea.getHeight()/2);
    cursorLeft.setBounds(topRow.removeFromLeft(30).reduced(2));
    cursorRight.setBounds(topRow.reduced(2));
    
    auto botRow = buttonsArea;
    valueUp.setBounds(botRow.removeFromLeft(30).reduced(2));
    valueDown.setBounds(botRow.reduced(2));

    auto mainArea = area.reduced(10);

    // Dividir en 3 columnas
    auto leftColumn = mainArea.removeFromLeft(300).reduced(5); // Fixed width for Osc
    auto rightColumn = mainArea.removeFromRight(300).reduced(5); // Fixed width for Effects
    auto centerColumn = mainArea.reduced(5); // Flexible Center (Envelopes)

    // --- Columna Izquierda ---
    oscSection.setBounds(leftColumn.removeFromTop(320));
    waveformDisplay.setBounds(leftColumn.withTrimmedTop(10));

    // --- Columna Central ---
    envelopeTabs.setBounds(centerColumn);

    // --- Columna Derecha ---
    filterLfoSection.setBounds(rightColumn.removeFromTop(180));
    effectsSection.setBounds(rightColumn.withTrimmedTop(10));
}

// --- MÃ‰TODOS CON LÃ“GICA RESTAURADA (versiÃ³n corta) ---
void CZ101AudioProcessorEditor::timerCallback()
{
    // Update MIDI Indicator
    if (audioProcessor.getMidiProcessor().hasRecentActivity())
    {
        midiIndicator.triggerActivity();
        audioProcessor.getMidiProcessor().clearActivityFlag();
    }
    
    // Update Waveform Display
    auto& buffer = audioProcessor.getVisBuffer();
    auto& fifo = audioProcessor.getVisFifo();
    // Variables already declared above
    if (fifo.getNumReady() > 0)
    {
        int start1, size1, start2, size2;
        fifo.prepareToRead(fifo.getNumReady(), start1, size1, start2, size2);
        
        if (size1 > 0)
        {
            // Create a temporary buffer for the slice
            juce::AudioBuffer<float> temp(1, size1);
            temp.copyFrom(0, 0, buffer, 0, start1, size1);
            waveformDisplay.pushBuffer(temp);
        }
        
        if (size2 > 0)
        {
             juce::AudioBuffer<float> temp(1, size2);
             temp.copyFrom(0, 0, buffer, 0, start2, size2);
             waveformDisplay.pushBuffer(temp);
        }
        
        fifo.finishedRead(size1 + size2);
    }
    
    waveformDisplay.repaint();
}

void CZ101AudioProcessorEditor::handleNoteOn(juce::MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity)
{
    auto m = juce::MidiMessage::noteOn(midiChannel, midiNoteNumber, velocity);
    audioProcessor.getMidiProcessor().processMessage(m);
}

void CZ101AudioProcessorEditor::handleNoteOff(juce::MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity)
{
    auto m = juce::MidiMessage::noteOff(midiChannel, midiNoteNumber, velocity);
    audioProcessor.getMidiProcessor().processMessage(m);
}

void CZ101AudioProcessorEditor::refreshMidiOutputs()
{
    midiOutputSelector.clear();
    midiOutputSelector.addItem("None", 1);
    auto devices = juce::MidiOutput::getAvailableDevices();
    for (int i = 0; i < devices.size(); ++i)
        midiOutputSelector.addItem(devices[i].name, i + 2);
}

void CZ101AudioProcessorEditor::loadSysExFile()
{
    fileChooser = std::make_unique<juce::FileChooser>("Select a CZ-101 SysEx file (.syx)..." ,
                                                       juce::File::getSpecialLocation(juce::File::userHomeDirectory),
                                                       "*.syx");
    
    fileChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
                              [this](const juce::FileChooser& fc)
    {
        auto file = fc.getResult();
        if (file.existsAsFile())
        {
            juce::MemoryBlock data;
            file.loadFileAsData(data);
            audioProcessor.getSysExManager().handleSysEx(data.getData(), (int)data.getSize(), file.getFileName());
        }
    });
}

void CZ101AudioProcessorEditor::saveSysExFile()
{
    fileChooser = std::make_unique<juce::FileChooser>("Save Current Patch as SysEx (.syx)..." ,
                                                       juce::File::getSpecialLocation(juce::File::userHomeDirectory),
                                                       "*.syx");
    
    fileChooser->launchAsync(juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles,
                              [this](const juce::FileChooser& fc)
    {
        auto file = fc.getResult();
        if (file != juce::File())
        {
            // Trigger SysEx Dump from Processor and save
            // This is a placeholder for the actual dump logic
        }
    });
}

bool CZ101AudioProcessorEditor::isInterestedInFileDrag(const juce::StringArray& files)
{
    for (auto f : files) if (f.endsWithIgnoreCase(".syx")) return true;
    return false;
}

void CZ101AudioProcessorEditor::filesDropped(const juce::StringArray& files, int x, int y)
{
    for (auto f : files)
    {
        if (f.endsWithIgnoreCase(".syx"))
        {
            juce::File file(f);
            juce::MemoryBlock data;
            file.loadFileAsData(data);
            audioProcessor.getSysExManager().handleSysEx(data.getData(), (int)data.getSize(), file.getFileName());
            break; // Handle only one for now
        }
    }
}

================================================================================
FILE: .\Source\PluginEditor.h
================================================================================
#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include "PluginProcessor.h"
#include "UI/CZ101LookAndFeel.h"
#include "UI/Sections/OscillatorSection.h"
#include "UI/Sections/EffectsSection.h"
#include "UI/Sections/FilterLfoSection.h"
#include "UI/Components/EnvelopeEditor.h"
#include "UI/Components/WaveformDisplay.h"
#include "UI/LCDDisplay.h"
#include "UI/Components/PresetBrowser.h"
#include "UI/Components/MIDIActivityIndicator.h"
#include "UI/Overlays/NameEditorOverlay.h"

class CZ101AudioProcessorEditor : public juce::AudioProcessorEditor,
                                   private juce::MidiKeyboardState::Listener,
                                   private juce::Timer,
                                   public juce::FileDragAndDropTarget // <-- AÃ‘ADIDO
{
public:
    CZ101AudioProcessorEditor(CZ101AudioProcessor&);
    ~CZ101AudioProcessorEditor() override;

    void paint(juce::Graphics&) override;
    void resized() override;
    
private:
    // --- MÃ©todos de LÃ³gica y Eventos ---
    void timerCallback() override;
    void handleNoteOn(juce::MidiKeyboardState*, int, int, float) override;
    void handleNoteOff(juce::MidiKeyboardState*, int, int, float) override;
    void refreshMidiOutputs();
    void loadSysExFile();
    void saveSysExFile();
    bool isInterestedInFileDrag(const juce::StringArray& files) override;
    void filesDropped(const juce::StringArray& files, int x, int y) override;

    CZ101AudioProcessor& audioProcessor;
    CZ101::UI::CZ101LookAndFeel customLookAndFeel;
    juce::OpenGLContext openGLContext;
    
    // --- Componentes Principales y Secciones UI ---
    juce::MidiKeyboardState keyboardState;
    juce::MidiKeyboardComponent keyboardComponent;
    
    // Header
    CZ101::UI::LCDDisplay lcdDisplay;
    CZ101::UI::PresetBrowser presetBrowser;
    CZ101::UI::MIDIActivityIndicator midiIndicator;
    juce::ComboBox midiOutputSelector;
    juce::TextButton loadSysExButton { "LOAD SYX" };
    juce::TextButton saveSysExButton { "SAVE" };
    juce::ToggleButton protectButton { "PROTECT" }; // Authentic Memory Protect
    std::unique_ptr<juce::AudioProcessorValueTreeState::ButtonAttachment> protectAttachment;
    
    std::unique_ptr<juce::MidiOutput> activeMidiOutput;
    std::unique_ptr<juce::FileChooser> fileChooser;

    // Secciones del Cuerpo
    CZ101::UI::OscillatorSection oscSection;
    CZ101::UI::EffectsSection effectsSection;
    CZ101::UI::FilterLfoSection filterLfoSection;
    CZ101::UI::WaveformDisplay waveformDisplay;
    
    // LCD Navigation
    juce::ArrowButton cursorLeft { "Left", 0.5f, juce::Colours::cyan };
    juce::ArrowButton cursorRight { "Right", 0.0f, juce::Colours::cyan };
    juce::ArrowButton valueUp { "Up", 0.25f, juce::Colours::orange };
    juce::ArrowButton valueDown { "Down", 0.75f, juce::Colours::orange };
    
    // Envolventes
    juce::TabbedComponent envelopeTabs { juce::TabbedButtonBar::TabsAtTop };
    CZ101::UI::EnvelopeEditor pitchEditor, dcwEditor, dcaEditor;
    
    // Overlays
    CZ101::UI::NameEditorOverlay nameOverlay;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(CZ101AudioProcessorEditor)
};

================================================================================
FILE: .\Source\PluginProcessor.cpp
================================================================================
#include "PluginProcessor.h"
#include "PluginEditor.h"

// --- CONSTRUCTOR ---
CZ101AudioProcessor::CZ101AudioProcessor()
    : AudioProcessor(BusesProperties()
                     .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      voiceManager(),
      parameters(*this),
      presetManager(&parameters, &voiceManager),
      midiProcessor(voiceManager, presetManager),
      sysExManager()
{
    // Setup File Logger
    auto logFile = juce::File::getSpecialLocation(juce::File::userDocumentsDirectory)
                   .getChildFile("CZ101Emulator")
                   .getChildFile("cz101_debug.log");
                   
    fileLogger = std::make_unique<juce::FileLogger>(logFile, "CZ-101 Emulator Log");
    juce::Logger::setCurrentLogger(fileLogger.get());
    juce::Logger::writeToLog("Logger initialized at: " + logFile.getFullPathName());
    
    // Bind SysEx Callback
    sysExManager.onPresetParsed = [this](const CZ101::State::Preset& p) {
        presetManager.loadPresetFromStruct(p);
        applyPresetToVoiceEngine(p);
    };
    
    midiProcessor.setSysExManager(&sysExManager);
    
    // Initialize LCD State Manager here to ensure it persists and avoids dangling references
    lcdStateManager = std::make_unique<CZ101::UI::LCDStateManager>(parameters.getAPVTS());
}

CZ101AudioProcessor::~CZ101AudioProcessor() 
{ 
    juce::Logger::setCurrentLogger(nullptr); 
}

// --- APPLY PRESET TO VOICE ENGINE ---
void CZ101AudioProcessor::applyPresetToVoiceEngine(const CZ101::State::Preset& preset)
{
    // Envelopes: These update the VoiceManager directly as they are not mapped to APVTS parameters for performance reasons
    for (int i = 0; i < 8; ++i) {
        voiceManager.setPitchStage(i, preset.pitchEnv.rates[i], preset.pitchEnv.levels[i]);
        voiceManager.setDCWStage(i, preset.dcwEnv.rates[i], preset.dcwEnv.levels[i]);
        voiceManager.setDCAStage(i, preset.dcaEnv.rates[i], preset.dcaEnv.levels[i]);
    }
    voiceManager.setPitchSustainPoint(preset.pitchEnv.sustainPoint);
    voiceManager.setPitchEndPoint(preset.pitchEnv.endPoint);
    voiceManager.setDCWSustainPoint(preset.dcwEnv.sustainPoint);
    voiceManager.setDCWEndPoint(preset.dcwEnv.endPoint);
    voiceManager.setDCASustainPoint(preset.dcaEnv.sustainPoint);
    voiceManager.setDCAEndPoint(preset.dcaEnv.endPoint);

    // APVTS parameters are updated by PresetManager::applyPresetToProcessor() called during load.
    // We only need to ensure the VoiceManager has the full Envelope data which might exceed APVTS simple ADSR.
}

// --- BASIC PLUGIN INFO ---
const juce::String CZ101AudioProcessor::getName() const { return JucePlugin_Name; }
bool CZ101AudioProcessor::acceptsMidi() const { return true; }
bool CZ101AudioProcessor::producesMidi() const { return false; }
bool CZ101AudioProcessor::isMidiEffect() const { return false; }
double CZ101AudioProcessor::getTailLengthSeconds() const { return 0.0; }
int CZ101AudioProcessor::getNumPrograms() { return 1; }
int CZ101AudioProcessor::getCurrentProgram() { return 0; }
void CZ101AudioProcessor::setCurrentProgram(int index) { juce::ignoreUnused(index); }
const juce::String CZ101AudioProcessor::getProgramName(int index) { juce::ignoreUnused(index); return {}; }
void CZ101AudioProcessor::changeProgramName(int, const juce::String&) {}

// --- EDITOR ---
bool CZ101AudioProcessor::hasEditor() const { return true; }
juce::AudioProcessorEditor* CZ101AudioProcessor::createEditor() { return new CZ101AudioProcessorEditor(*this); }

// --- PREPARE TO PLAY ---
void CZ101AudioProcessor::prepareToPlay(double sr, int samplesPerBlock) 
{
    voiceManager.setSampleRate(sr);
    delayL.setSampleRate(sr);
    delayR.setSampleRate(sr);
    reverb.setSampleRate(sr);
    chorus.prepare(sr);
    
    juce::File presetsDir = juce::File::getSpecialLocation(juce::File::userDocumentsDirectory).getChildFile("CZ101Emulator");
    if (!presetsDir.exists()) presetsDir.createDirectory();
    juce::File bankFile = presetsDir.getChildFile("userbank.json");
    
    if (bankFile.existsAsFile()) {
        presetManager.loadBank(bankFile);
        if (presetManager.getPresets().empty()) presetManager.createFactoryPresets();
    } else {
        presetManager.createFactoryPresets();
        presetManager.saveBank(bankFile);
    }
    
    presetManager.loadPreset(0);
}

void CZ101AudioProcessor::releaseResources() {}

bool CZ101AudioProcessor::isBusesLayoutSupported(const BusesLayout& layouts) const
{
    return layouts.getMainOutputChannelSet() == juce::AudioChannelSet::stereo();
}

// --- PROCESS BLOCK ---
void CZ101AudioProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    juce::ScopedNoDenormals noDenormals;
    performanceMonitor.startMeasurement();
    
    for (int i = getTotalNumInputChannels(); i < getTotalNumOutputChannels(); ++i) 
        buffer.clear(i, 0, buffer.getNumSamples());
    
    processEnvelopeUpdates();
    updateParameters();
    
    midiProcessor.processMidiBuffer(midiMessages);
    
    auto* channelDataL = buffer.getWritePointer(0);
    auto* channelDataR = buffer.getWritePointer(1);
    
    voiceManager.renderNextBlock(channelDataL, channelDataR, buffer.getNumSamples());
    
    chorus.process(channelDataL, channelDataR, buffer.getNumSamples());
    reverb.processStereo(channelDataL, channelDataR, buffer.getNumSamples());
    
    // Visualization logic
    if (visFifo.getFreeSpace() >= buffer.getNumSamples())
    {
        int start1, size1, start2, size2;
        visFifo.prepareToWrite(buffer.getNumSamples(), start1, size1, start2, size2);
        auto* l = buffer.getReadPointer(0);
        auto* r = (buffer.getNumChannels() > 1) ? buffer.getReadPointer(1) : l;
        
        if (size1 > 0) visBuffer.copyFrom(0, start1, buffer, 0, 0, size1);
        if (size2 > 0) visBuffer.copyFrom(0, start2, buffer, 0, size1, size2);
        visFifo.finishedWrite(size1 + size2);
    }
    
    performanceMonitor.stopMeasurement();
}

// --- UPDATE PARAMETERS (Centralized Logic) ---
void CZ101AudioProcessor::updateParameters()
{
    // Retrieve base values from APVTS
    int lineSel = parameters.lineSelect ? parameters.lineSelect->getIndex() : 2; 
    float l1 = parameters.osc1Level->get();
    float l2 = parameters.osc2Level->get();
    int w1_1 = parameters.osc1Waveform->getIndex();
    int w1_2 = parameters.osc1Waveform2 ? (parameters.osc1Waveform2->getIndex() == 0 ? 8 : parameters.osc1Waveform2->getIndex() - 1) : 8;
    int w2_1 = parameters.osc2Waveform->getIndex();
    int w2_2 = parameters.osc2Waveform2 ? (parameters.osc2Waveform2->getIndex() == 0 ? 8 : parameters.osc2Waveform2->getIndex() - 1) : 8;

    // 1. Line Select Muting Logic
    if (lineSel == 0) l2 = 0.0f; // Line 1 Only
    if (lineSel == 1) l1 = 0.0f; // Line 2 Only

    // 2. Line Select 1+1' Logic (Copy Line 1 to Line 2)
    if (lineSel == 2) { 
        w2_1 = w1_1;
        w2_2 = w1_2;
    }

    // 3. Update VoiceManager engine
    voiceManager.setOsc1Level(l1);
    voiceManager.setOsc2Level(l2);
    voiceManager.setOsc1Waveforms(w1_1, w1_2);
    voiceManager.setOsc2Waveforms(w2_1, w2_2);
    
    voiceManager.setOsc2Detune(parameters.osc2Detune->get());
    if (parameters.hardSync) voiceManager.setHardSync(parameters.hardSync->get());
    if (parameters.ringMod) voiceManager.setRingMod(parameters.ringMod->get());
    if (parameters.glideTime) voiceManager.setGlideTime(parameters.glideTime->get());

    // Envelope Parameters (These are secondary controls, primary is via applyPreset)
    if (parameters.dcwAttack) voiceManager.setDCWAttack(parameters.dcwAttack->get());
    if (parameters.dcwDecay) voiceManager.setDCWDecay(parameters.dcwDecay->get());
    if (parameters.dcwSustain) voiceManager.setDCWSustain(parameters.dcwSustain->get());
    if (parameters.dcwRelease) voiceManager.setDCWRelease(parameters.dcwRelease->get());

    if (parameters.dcaAttack) voiceManager.setDCAAttack(parameters.dcaAttack->get());
    if (parameters.dcaDecay) voiceManager.setDCADecay(parameters.dcaDecay->get());
    if (parameters.dcaSustain) voiceManager.setDCASustain(parameters.dcaSustain->get());
    if (parameters.dcaRelease) voiceManager.setDCARelease(parameters.dcaRelease->get());

    // LFO / Vibrato
    if (parameters.lfoRate) voiceManager.setLFOFrequency(parameters.lfoRate->get());
    if (parameters.lfoWaveform) voiceManager.setLFOWaveform(static_cast<CZ101::DSP::LFO::Waveform>(parameters.lfoWaveform->getIndex()));
    if (parameters.lfoDepth) voiceManager.setVibratoDepth(parameters.lfoDepth->get());
    if (parameters.lfoDelay) voiceManager.setLFODelay(parameters.lfoDelay->get());

    // 4. Update Effects
    if (parameters.chorusRate) chorus.setRate(parameters.chorusRate->get());
    if (parameters.chorusDepth) chorus.setDepth(parameters.chorusDepth->get());
    if (parameters.chorusMix) chorus.setMix(parameters.chorusMix->get());
    
    if (parameters.reverbSize && parameters.reverbMix)
    {
        reverbParams.roomSize = parameters.reverbSize->get();
        reverbParams.damping = 0.5f;
        reverbParams.wetLevel = parameters.reverbMix->get();
        reverbParams.dryLevel = 1.0f - (parameters.reverbMix->get() * 0.5f);
        reverbParams.width = 1.0f;
        reverb.setParameters(reverbParams);
    }

    // 5. Update SysEx Protection State
    bool isProtected = parameters.protectSwitch ? parameters.protectSwitch->get() : true;
    bool isPrgEnabled = parameters.systemPrg ? parameters.systemPrg->get() : false;
    sysExManager.setProtectionState(isProtected, isPrgEnabled);
}

// --- THREAD-SAFE ENVELOPE QUEUE ---
void CZ101AudioProcessor::scheduleEnvelopeUpdate(const EnvelopeUpdateCommand& cmd)
{
    int start1, size1, start2, size2;
    commandFifo.prepareToWrite(1, start1, size1, start2, size2);
    if (size1 > 0) commandBuffer[start1] = cmd;
    else if (size2 > 0) commandBuffer[start2] = cmd;
    commandFifo.finishedWrite(size1 + size2);
}

void CZ101AudioProcessor::processEnvelopeUpdates()
{
    int start1, size1, start2, size2;
    commandFifo.prepareToRead(100, start1, size1, start2, size2);
    
    auto processRange = [&](int start, int size) {
        for (int i = 0; i < size; ++i) {
            auto& cmd = commandBuffer[start + i];
            switch (cmd.type) {
                case EnvelopeUpdateCommand::DCA_STAGE: voiceManager.setDCAStage(cmd.index, cmd.rate, cmd.level); break;
                case EnvelopeUpdateCommand::DCA_SUSTAIN: voiceManager.setDCASustainPoint(cmd.index); break;
                case EnvelopeUpdateCommand::DCA_END: voiceManager.setDCAEndPoint(cmd.index); break;
                case EnvelopeUpdateCommand::DCW_STAGE: voiceManager.setDCWStage(cmd.index, cmd.rate, cmd.level); break;
                case EnvelopeUpdateCommand::DCW_SUSTAIN: voiceManager.setDCWSustainPoint(cmd.index); break;
                case EnvelopeUpdateCommand::DCW_END: voiceManager.setDCWEndPoint(cmd.index); break;
                case EnvelopeUpdateCommand::PITCH_STAGE: voiceManager.setPitchStage(cmd.index, cmd.rate, cmd.level); break;
                case EnvelopeUpdateCommand::PITCH_SUSTAIN: voiceManager.setPitchSustainPoint(cmd.index); break;
                case EnvelopeUpdateCommand::PITCH_END: voiceManager.setPitchEndPoint(cmd.index); break;
            }
        }
    };

    if (size1 > 0) processRange(start1, size1);
    if (size2 > 0) processRange(start2, size2);
    commandFifo.finishedRead(size1 + size2);
}

// --- PERSISTENCE ---
void CZ101AudioProcessor::getStateInformation(juce::MemoryBlock& destData) 
{
    auto state = parameters.getAPVTS().copyState();
    std::unique_ptr<juce::XmlElement> xml(state.createXml());
    copyXmlToBinary(*xml, destData);
}

void CZ101AudioProcessor::setStateInformation(const void* data, int sizeInBytes) 
{
    std::unique_ptr<juce::XmlElement> xmlState(getXmlFromBinary(data, sizeInBytes));
    if (xmlState != nullptr)
        if (xmlState->hasTagName(parameters.getAPVTS().state.getType()))
            parameters.getAPVTS().replaceState(juce::ValueTree::fromXml(*xmlState));
}

// --- AUTHENTIC INITIALIZE ---
void CZ101AudioProcessor::initializeSection(InitSection section)
{
    if (section == InitSection::WAVEFORM || section == InitSection::ALL) {
        if (parameters.osc1Waveform) parameters.osc1Waveform->setValueNotifyingHost(0.0f);
        if (parameters.osc1Waveform2) parameters.osc1Waveform2->setValueNotifyingHost(0.0f);
        if (parameters.osc2Waveform) parameters.osc2Waveform->setValueNotifyingHost(0.0f);
        if (parameters.osc2Waveform2) parameters.osc2Waveform2->setValueNotifyingHost(0.0f);
    }

    if (section == InitSection::VIBRATO || section == InitSection::ALL) {
        if (parameters.lfoRate) parameters.lfoRate->setValueNotifyingHost(0.0f);
        if (parameters.lfoDepth) parameters.lfoDepth->setValueNotifyingHost(0.0f);
        if (parameters.lfoDelay) parameters.lfoDelay->setValueNotifyingHost(0.0f);
        if (parameters.lfoWaveform) parameters.lfoWaveform->setValueNotifyingHost(0.0f);
    }
    
    if (section == InitSection::DCA || section == InitSection::DCW || section == InitSection::ALL) {
        bool doDCW = (section == InitSection::DCW || section == InitSection::ALL);
        bool doDCA = (section == InitSection::DCA || section == InitSection::ALL);
        
        if (doDCW) {
             scheduleEnvelopeUpdate({EnvelopeUpdateCommand::DCW_STAGE, 0, 99.0f, 1.0f});
             scheduleEnvelopeUpdate({EnvelopeUpdateCommand::DCW_STAGE, 1, 99.0f, 0.0f});
             scheduleEnvelopeUpdate({EnvelopeUpdateCommand::DCW_SUSTAIN, 0, 0.0f, 0.0f});
             scheduleEnvelopeUpdate({EnvelopeUpdateCommand::DCW_END, 1, 0.0f, 0.0f});
        }
        
        if (doDCA) {
             scheduleEnvelopeUpdate({EnvelopeUpdateCommand::DCA_STAGE, 0, 99.0f, 1.0f});
             scheduleEnvelopeUpdate({EnvelopeUpdateCommand::DCA_STAGE, 1, 99.0f, 0.0f});
             scheduleEnvelopeUpdate({EnvelopeUpdateCommand::DCA_SUSTAIN, 0, 0.0f, 0.0f});
             scheduleEnvelopeUpdate({EnvelopeUpdateCommand::DCA_END, 1, 0.0f, 0.0f});
        }
    }
    
    if (section == InitSection::DCO || section == InitSection::ALL) {
        scheduleEnvelopeUpdate({EnvelopeUpdateCommand::PITCH_STAGE, 0, 50.0f, 0.5f});
        scheduleEnvelopeUpdate({EnvelopeUpdateCommand::PITCH_STAGE, 1, 50.0f, 0.5f});
        scheduleEnvelopeUpdate({EnvelopeUpdateCommand::PITCH_SUSTAIN, 0, 0.0f, 0.0f});
        scheduleEnvelopeUpdate({EnvelopeUpdateCommand::PITCH_END, 1, 0.0f, 0.0f});
    }
    
    if (section == InitSection::OCTAVE || section == InitSection::ALL) {
        if (parameters.osc2Detune) parameters.osc2Detune->setValueNotifyingHost(parameters.osc2Detune->convertTo0to1(0.0f));
    }
}

juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter() { return new CZ101AudioProcessor(); }

================================================================================
FILE: .\Source\PluginProcessor.h
================================================================================
#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_core/juce_core.h>
#include <memory>
#include "Utils/PerformanceMonitor.h"
#include "Core/VoiceManager.h"
#include "MIDI/MIDIProcessor.h"
#include "MIDI/SysExManager.h"
#include "State/Parameters.h"
#include "State/PresetManager.h"

#include "DSP/Effects/Delay.h"
#include "DSP/Effects/Chorus.h"
#include "DSP/Effects/Reverb.h"
#include "DSP/Modulation/LFO.h"
#include "UI/LCDStateManager.h" // Added Logic Header

// Command Pattern for Thread Safety
enum class InitSection { WAVEFORM, DCO, DCW, DCA, VIBRATO, OCTAVE, ALL, SYSTEM_ALL };

struct EnvelopeUpdateCommand
{
    enum Type { DCA_STAGE, DCW_STAGE, PITCH_STAGE, 
                DCA_SUSTAIN, DCW_SUSTAIN, PITCH_SUSTAIN,
                DCA_END, DCW_END, PITCH_END };
    Type type;
    int index = 0;
    float rate = 0.0f;
    float level = 0.0f;
};

class CZ101AudioProcessor : public juce::AudioProcessor
{
public:
    CZ101AudioProcessor();
    ~CZ101AudioProcessor() override;

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;

    bool isBusesLayoutSupported(const BusesLayout& layouts) const override;

    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override;

    const juce::String getName() const override;

    bool acceptsMidi() const override;
    bool producesMidi() const override;
    bool isMidiEffect() const override;
    double getTailLengthSeconds() const override;
    int getNumPrograms() override;
    int getCurrentProgram() override;
    void setCurrentProgram(int index) override;
    const juce::String getProgramName(int index) override;
    void changeProgramName(int index, const juce::String& newName) override;
    
    void saveCurrentPreset(const juce::String& name); // New Save Method
    void applyPresetToVoiceEngine(const CZ101::State::Preset& preset); // SysEx Helper
    void initializeSection(InitSection section); // Authentic Initialization

    void getStateInformation(juce::MemoryBlock& destData) override;
    void setStateInformation(const void* data, int sizeInBytes) override;
    CZ101::State::PresetManager& getPresetManager() { return presetManager; }
    CZ101::MIDI::SysExManager& getSysExManager() { return sysExManager; }
    CZ101::MIDI::MIDIProcessor& getMidiProcessor() { return midiProcessor; }
    CZ101::State::Parameters& getParameters() { return parameters; }
    CZ101::Core::VoiceManager& getVoiceManager() { return voiceManager; }
    CZ101::Utils::PerformanceMonitor& getPerformanceMonitor() { return performanceMonitor; }
    
    // For Editor Visualization
    // juce::AudioVisualiserComponent& getVisualiser() { return visualiser; } 
    
    // For Editor Visualization
    // juce::AudioVisualiserComponent& getVisualiser() { return visualiser; } 
    
    juce::AudioBuffer<float>& getVisBuffer() { return visBuffer; }
    juce::AbstractFifo& getVisFifo() { return visFifo; }
    
    // CASIO CZ COMMAND QUEUE (Thread-Safe UI -> Audio)
    void scheduleEnvelopeUpdate(const EnvelopeUpdateCommand& cmd);

    // --- UI State Management ---
    std::unique_ptr<CZ101::UI::LCDStateManager> lcdStateManager;
    CZ101::UI::LCDStateManager& getLCDStateManager() { return *lcdStateManager; }

private:
    // ...
    // Visualisation
    juce::AudioBuffer<float> visBuffer { 1, 1024 }; // Mono, 1024 samples ring buffer
    juce::AbstractFifo visFifo { 1024 };
    CZ101::Core::VoiceManager voiceManager;
    CZ101::MIDI::MIDIProcessor midiProcessor;
    CZ101::State::Parameters parameters;
    CZ101::State::PresetManager presetManager;
    CZ101::MIDI::SysExManager sysExManager;
    

    CZ101::DSP::Effects::Delay delayL;
    CZ101::DSP::Effects::Delay delayR;
    
    juce::Reverb reverb;
    juce::Reverb::Parameters reverbParams;
    CZ101::DSP::Effects::Chorus chorus;
    
    // UI Update Tracking
    CZ101::Utils::PerformanceMonitor performanceMonitor;
    
    // Command Queue Data
    static constexpr int COMMAND_QUEUE_SIZE = 1024;
    juce::AbstractFifo commandFifo { COMMAND_QUEUE_SIZE };
    std::array<EnvelopeUpdateCommand, COMMAND_QUEUE_SIZE> commandBuffer;
    
    void processEnvelopeUpdates();
    
    void updateParameters();

    std::unique_ptr<juce::FileLogger> fileLogger;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(CZ101AudioProcessor)
};

================================================================================
FILE: .\Source\Core\BuildVersion.h
================================================================================
#pragma once

#define CZ_BUILD_VERSION "41"
#define CZ_BUILD_TIMESTAMP "2026-01-11 20:43:47"


================================================================================
FILE: .\Source\Core\Voice.cpp
================================================================================
#include <JuceHeader.h>
#include "Voice.h"
#include <cmath>
#include "../DSP/Envelopes/ADSRtoStage.h"

namespace CZ101 {
namespace Core {

Voice::Voice()
{
}

void Voice::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
    osc1.setSampleRate(sr);
    osc2.setSampleRate(sr);
    dcwEnvelope.setSampleRate(sr);
    dcaEnvelope.setSampleRate(sr);
    pitchEnvelope.setSampleRate(sr);
    lfoModule.setSampleRate(sr); // Added LFO initialization

    // Re-calculate envelopes with new sample rate
    updateDCWEnvelopeFromADSR();
    updateDCAEnvelopeFromADSR();
    updatePitchEnvelopeFromADSR();
}

void Voice::noteOn(int midiNote, float velocity) noexcept
{
    // Frequency
    currentNote = midiNote;
    currentVelocity = velocity;
    
    // Convert note
    baseFrequency = midiNoteToFrequency(midiNote);
    targetFrequency = baseFrequency;
    currentFrequency = baseFrequency; // Start at note (glide handles transition)
    
    // Reset phase if hard sync or just standard gate behavior
    // CZ-101 resets on note on usually
    osc1.reset();
    osc2.reset();
    lfoModule.reset(); // Added LFO reset (triggers delay)
    
    // Envelopes
    dcwEnvelope.noteOn();
    dcaEnvelope.noteOn();
    pitchEnvelope.noteOn();
}

void Voice::noteOff() noexcept
{
    dcwEnvelope.noteOff();
    dcaEnvelope.noteOff();
    pitchEnvelope.noteOff();
}

void Voice::reset() noexcept
{
    dcwEnvelope.reset();
    dcaEnvelope.reset();
    pitchEnvelope.reset();
    lfoModule.reset();
}

// ... Oscillators ...

void Voice::setOsc1Waveforms(DSP::PhaseDistOscillator::CzWaveform f, DSP::PhaseDistOscillator::CzWaveform s) noexcept 
{ 
    osc1.setWaveforms(f, s); 
}
void Voice::setOsc1Level(float level) noexcept { osc1Level = level; }

void Voice::setOsc2Waveforms(DSP::PhaseDistOscillator::CzWaveform f, DSP::PhaseDistOscillator::CzWaveform s) noexcept 
{ 
    osc2.setWaveforms(f, s); 
}
void Voice::setOsc2Level(float level) noexcept { osc2Level = level; }
void Voice::setOsc2Detune(float cents) noexcept 
{ 
    osc2Detune = cents; 
    currentDetuneFactor =std::pow(2.0f, cents / 1200.0f);
}

void Voice::setHardSync(bool enabled) noexcept { isHardSyncEnabled = enabled; }
void Voice::setRingMod(bool enabled) noexcept { isRingModEnabled = enabled; }
void Voice::setGlideTime(float seconds) noexcept { glideTime = seconds; }

// ... DCW Envelope ...
void Voice::setVibratoDepth(float semitones) noexcept { vibratoDepth = semitones; }
// void setLFOValue deleted.
void Voice::setLFOFrequency(float hz) noexcept { lfoModule.setFrequency(hz); }
void Voice::setLFOWaveform(DSP::LFO::Waveform w) noexcept { lfoModule.setWaveform(w); }
void Voice::setLFODelay(float s) noexcept { lfoModule.setDelay(s); }

void Voice::setPitchBend(float semitones) noexcept { pitchBendFactor = std::pow(2.0f, semitones / 12.0f); }
void Voice::setMasterTune(float semitones) noexcept { masterTuneFactor = std::pow(2.0f, semitones / 12.0f); }

// ============================================================================
// DCW ENVELOPE - IMPLEMENTACIÃ“N MEJORADA
// ============================================================================

void Voice::setDCWAttack(float seconds) noexcept
{
    double ms = static_cast<double>(seconds) * 1000.0;
    dcwADSR.attackMs = static_cast<float>(std::clamp(ms, 0.5, 8000.0));
    updateDCWEnvelopeFromADSR();
}

void Voice::setDCWDecay(float seconds) noexcept
{
    double ms = static_cast<double>(seconds) * 1000.0;
    dcwADSR.decayMs = static_cast<float>(std::clamp(ms, 0.5, 8000.0));
    updateDCWEnvelopeFromADSR();
}

void Voice::setDCWSustain(float level) noexcept
{
    dcwADSR.sustainLevel = std::clamp(level, 0.0f, 1.0f);
    updateDCWEnvelopeFromADSR();
}

void Voice::setDCWRelease(float seconds) noexcept
{
    double ms = static_cast<double>(seconds) * 1000.0;
    dcwADSR.releaseMs = static_cast<float>(std::clamp(ms, 0.5, 8000.0));
    updateDCWEnvelopeFromADSR();
}

void Voice::setDCWStage(int i, float r, float l) noexcept { dcwEnvelope.setStage(i, r, l); }
void Voice::setDCWSustainPoint(int i) noexcept { dcwEnvelope.setSustainPoint(i); }
void Voice::setDCWEndPoint(int i) noexcept { dcwEnvelope.setEndPoint(i); }

void Voice::getDCWStage(int i, float& r, float& l) const noexcept { r = dcwEnvelope.getStageRate(i); l = dcwEnvelope.getStageLevel(i); }
int Voice::getDCWSustainPoint() const noexcept { return dcwEnvelope.getSustainPoint(); }
int Voice::getDCWEndPoint() const noexcept { return dcwEnvelope.getEndPoint(); }

// ============================================================================
// DCA ENVELOPE - IMPLEMENTACIÃ“N MEJORADA
// ============================================================================

void Voice::setDCAAttack(float seconds) noexcept
{
    double ms = static_cast<double>(seconds) * 1000.0;
    dcaADSR.attackMs = static_cast<float>(std::clamp(ms, 0.5, 8000.0));
    updateDCAEnvelopeFromADSR();
}

void Voice::setDCADecay(float seconds) noexcept
{
    double ms = static_cast<double>(seconds) * 1000.0;
    dcaADSR.decayMs = static_cast<float>(std::clamp(ms, 0.5, 8000.0));
    updateDCAEnvelopeFromADSR();
}

void Voice::setDCASustain(float level) noexcept
{
    dcaADSR.sustainLevel = std::clamp(level, 0.0f, 1.0f);
    updateDCAEnvelopeFromADSR();
}

void Voice::setDCARelease(float seconds) noexcept
{
    double ms = static_cast<double>(seconds) * 1000.0;
    dcaADSR.releaseMs = static_cast<float>(std::clamp(ms, 0.5, 8000.0));
    updateDCAEnvelopeFromADSR();
}

void Voice::setDCAStage(int i, float r, float l) noexcept { dcaEnvelope.setStage(i, r, l); }
void Voice::setDCASustainPoint(int i) noexcept { dcaEnvelope.setSustainPoint(i); }
void Voice::setDCAEndPoint(int i) noexcept { dcaEnvelope.setEndPoint(i); }

void Voice::getDCAStage(int i, float& r, float& l) const noexcept { r = dcaEnvelope.getStageRate(i); l = dcaEnvelope.getStageLevel(i); }
int Voice::getDCASustainPoint() const noexcept { return dcaEnvelope.getSustainPoint(); }
int Voice::getDCAEndPoint() const noexcept { return dcaEnvelope.getEndPoint(); }

// ... Pitch Envelope ...

void Voice::setPitchStage(int i, float r, float l) noexcept { pitchEnvelope.setStage(i, r, l); }
void Voice::setPitchSustainPoint(int i) noexcept { pitchEnvelope.setSustainPoint(i); }
void Voice::setPitchEndPoint(int i) noexcept { pitchEnvelope.setEndPoint(i); }

void Voice::getPitchStage(int i, float& r, float& l) const noexcept { r = pitchEnvelope.getStageRate(i); l = pitchEnvelope.getStageLevel(i); }
int Voice::getPitchSustainPoint() const noexcept { return pitchEnvelope.getSustainPoint(); }
int Voice::getPitchEndPoint() const noexcept { return pitchEnvelope.getEndPoint(); }

// ===== HELPER METHODS FOR ADSR CONSISTENCY =====

void Voice::updateDCWEnvelopeFromADSR() noexcept
{
    std::array<float, 8> rates, levels;
    int sus, end;
    
    DSP::ADSRtoStageConverter::convertADSR(
        dcwADSR.attackMs,
        dcwADSR.decayMs,
        dcwADSR.sustainLevel,
        dcwADSR.releaseMs,
        rates, levels, sus, end,
        sampleRate
    );
    
    // Aplicar todos los stages a la vez
    for (int i = 0; i < 4; ++i) {
        dcwEnvelope.setStage(i, rates[i], levels[i]);
    }
    dcwEnvelope.setSustainPoint(sus);
    dcwEnvelope.setEndPoint(end);
}

void Voice::updateDCAEnvelopeFromADSR() noexcept
{
    std::array<float, 8> rates, levels;
    int sus, end;
    
    DSP::ADSRtoStageConverter::convertADSR(
        dcaADSR.attackMs,
        dcaADSR.decayMs,
        dcaADSR.sustainLevel,
        dcaADSR.releaseMs,
        rates, levels, sus, end,
        sampleRate
    );
    
    for (int i = 0; i < 4; ++i) {
        dcaEnvelope.setStage(i, rates[i], levels[i]);
    }
    dcaEnvelope.setSustainPoint(sus);
    dcaEnvelope.setEndPoint(end);
}

void Voice::updatePitchEnvelopeFromADSR() noexcept
{
    std::array<float, 8> rates, levels;
    int sus, end;
    
    DSP::ADSRtoStageConverter::convertADSR(
        pitchADSR.attackMs,
        pitchADSR.decayMs,
        pitchADSR.sustainLevel,
        pitchADSR.releaseMs,
        rates, levels, sus, end,
        sampleRate
    );
    
    for (int i = 0; i < 4; ++i) {
        pitchEnvelope.setStage(i, rates[i], levels[i]);
    }
    pitchEnvelope.setSustainPoint(sus);
    pitchEnvelope.setEndPoint(end);
}

float Voice::renderNextSample() noexcept
{
    if (!dcaEnvelope.isActive()) return 0.0f;
    
    // === ENVELOPE VALUES ===
    float dcwValue = dcwEnvelope.getNextValue();         // Timbre (0-1)
    float dcaValue = dcaEnvelope.getNextValue();         // Amplitud (0-1)
    float pitchEnvVal = pitchEnvelope.getNextValue();    // Pitch mod (0-1)
    
    // === PITCH MODULATION ===
    // Pitch envelope: 0.0 = -1 octava, 0.5 = unison, 1.0 = +1 octava
    float semitones = (pitchEnvVal - 0.5f) * 100.0f;     // Â±50 semitones
    float pitchMod = std::pow(2.0f, semitones / 12.0f);
    
    // === GLIDE (PORTAMENTO) ===
    if (glideTime > 0.001f && currentFrequency != targetFrequency) {
        float alpha = 1.0f / (float)(sampleRate * (glideTime + 0.001f));
        float diff = targetFrequency - currentFrequency;
        currentFrequency += diff * alpha * 4.0f;
        
        if (std::abs(diff) < 0.1f) currentFrequency = targetFrequency;
    } else {
        currentFrequency = targetFrequency;
    }
    
    // === LFO VIBRATO ===
    float vibratoMod = 1.0f;
    if (vibratoDepth > 0.001f) {
        // Use local LFO Module!
        float currentLFO = lfoModule.getNextValue();
        float lfoSemitones = currentLFO * vibratoDepth;
        vibratoMod = std::pow(2.0f, lfoSemitones / 12.0f);
    }
    
    // === FINAL FREQUENCY ===
    // Combina: Pitch Env + Vibrato + Pitch Bend + Master Tune
    float finalFreq = currentFrequency * pitchMod * vibratoMod 
                    * pitchBendFactor * masterTuneFactor;
    
    osc1.setFrequency(finalFreq);
    osc2.setFrequency(finalFreq * currentDetuneFactor);
    
    // === OSCILLATOR RENDERING ===
    bool osc1Wrapped = false;
    float osc1Sample = osc1.renderNextSample(dcwValue, &osc1Wrapped);
    
    // Hard Sync: reset osc2 cuando osc1 wraps
    if (isHardSyncEnabled && osc1Wrapped) {
        osc2.reset();
    }
    
    float osc2Sample = osc2.renderNextSample(dcwValue);
    
    // Ring Modulation: osc2_out = osc1 * osc2
    if (isRingModEnabled) {
        osc2Sample = osc1Sample * osc2Sample;
    }
    
    // === OSCILLATOR MIX WITH NORMALIZATION âœ… ===
    // Importante: Evitar overshooting si osc1Level + osc2Level > 1.0
    float totalLevel = osc1Level + osc2Level;
    float normalizer = (totalLevel > 1.0f) ? (1.0f / totalLevel) : 1.0f;
    
    float mix = (osc1Sample * osc1Level + osc2Sample * osc2Level) * normalizer;
    
    // === FINAL OUTPUT WITH SAFETY ===
    // 0.9f headroom para prevenir clipping de efectos posteriores
    float output = mix * dcaValue * currentVelocity * 0.9f;
    
    // Clamp final para ultra-seguridad
    return std::clamp(output, -1.0f, 1.0f);
}

float Voice::midiNoteToFrequency(int midiNote) const noexcept
{
    return 440.0f * std::pow(2.0f, (midiNote - 69) / 12.0f);
}

} // namespace Core
} // namespace CZ101

================================================================================
FILE: .\Source\Core\Voice.h
================================================================================
#pragma once

#include "../DSP/Oscillators/PhaseDistOsc.h"
#include "../DSP/Envelopes/MultiStageEnv.h"
#include "../DSP/Modulation/LFO.h"
#include <array>

namespace CZ101 {
namespace Core {

/**
 * @brief Voice - Complete synthesizer voice
 * 
 * Integrates oscillators and envelopes to create the CZ-101 sound.
 * Architecture: DCO (oscillators) â†’ DCW (timbre envelope) â†’ DCA (amplitude envelope)
 */
class Voice
{
public:
    Voice();
    
    void setSampleRate(double sampleRate) noexcept;
    
    // Note control
    void noteOn(int midiNote, float velocity) noexcept;
    void noteOff() noexcept;
    void reset() noexcept;
    
    // Oscillator 1 parameters
    // Oscillator 1 parameters
    void setOsc1Waveforms(DSP::PhaseDistOscillator::CzWaveform first, DSP::PhaseDistOscillator::CzWaveform second) noexcept;
    void setOsc1Level(float level) noexcept;
    
    // Oscillator 2 parameters
    void setOsc2Waveforms(DSP::PhaseDistOscillator::CzWaveform first, DSP::PhaseDistOscillator::CzWaveform second) noexcept;
    void setOsc2Level(float level) noexcept;
    void setOsc2Detune(float cents) noexcept;  // -100 to +100 cents
    
    /**
     * @brief Enable/Disable Hard Sync (Osc2 resets when Osc1 wraps)
     */
    void setHardSync(bool enabled) noexcept;

    /**
     * @brief Enable/Disable Ring Modulation (Osc2 output = Osc1 * Osc2)
     */
    /**
     * @brief Enable/Disable Ring Modulation (Osc2 output = Osc1 * Osc2)
     */
    void setRingMod(bool enabled) noexcept;

    /**
     * @brief Set Glide (Portamento) Time in seconds
     * @param seconds Slide time (0.0 to ~2.0)
     */
    void setGlideTime(float seconds) noexcept;

    // --- Modulation (LFO) ---
    void setVibratoDepth(float semitones) noexcept;
    
    // Config LFO (Per-Voice)
    void setLFOFrequency(float hz) noexcept;
    void setLFOWaveform(DSP::LFO::Waveform waveform) noexcept;
    void setLFODelay(float seconds) noexcept;
    
    // --- Global Pitch ---
    void setPitchBend(float semitones) noexcept;
    void setMasterTune(float semitones) noexcept;

    // --- Pitch Envelope Controls ---
    
    // DCW Envelope (Legacy ADSR Wrappers)
    void setDCWAttack(float seconds) noexcept;
    void setDCWDecay(float seconds) noexcept;
    void setDCWSustain(float level) noexcept;
    void setDCWRelease(float seconds) noexcept;
    
    // DCW 8-Stage Control
    void setDCWStage(int index, float rate, float level) noexcept;
    void setDCWSustainPoint(int index) noexcept;
    void setDCWEndPoint(int index) noexcept;
    
    void getDCWStage(int index, float& rate, float& level) const noexcept;
    int getDCWSustainPoint() const noexcept;
    int getDCWEndPoint() const noexcept;
    
    // DCA Envelope (Legacy ADSR Wrappers)
    void setDCAAttack(float seconds) noexcept;
    void setDCADecay(float seconds) noexcept;
    void setDCASustain(float level) noexcept;
    void setDCARelease(float seconds) noexcept;

    // DCA 8-Stage Control
    void setDCAStage(int index, float rate, float level) noexcept;
    void setDCASustainPoint(int index) noexcept;
    void setDCAEndPoint(int index) noexcept;

    void getDCAStage(int index, float& rate, float& level) const noexcept;
    int getDCASustainPoint() const noexcept;
    int getDCAEndPoint() const noexcept;

    // Pitch Envelope (DCO) 8-Stage Control
    void setPitchStage(int index, float rate, float level) noexcept;
    void setPitchSustainPoint(int index) noexcept;
    void setPitchEndPoint(int index) noexcept;
    
    void getPitchStage(int index, float& rate, float& level) const noexcept;
    int getPitchSustainPoint() const noexcept;
    int getPitchEndPoint() const noexcept;
    
    // Rendering
    float renderNextSample() noexcept;
    
    bool isActive() const noexcept { return dcaEnvelope.isActive(); }
    int getCurrentNote() const noexcept { return currentNote; }
    
private:
    // Oscillators
    DSP::PhaseDistOscillator osc1;
    DSP::PhaseDistOscillator osc2;
    
    // Envelopes
    DSP::MultiStageEnvelope dcwEnvelope;  // Digital Controlled Wave (timbre)
    DSP::MultiStageEnvelope dcaEnvelope;  // Digital Controlled Amplifier (volume)
    DSP::MultiStageEnvelope pitchEnvelope; // DCO Pitch Envelope (new)
    
    // State
    int currentNote = -1;
    float currentVelocity = 1.0f;
    
    // Mix levels
    float osc1Level = 0.5f;
    float osc2Level = 0.5f;
    float osc2Detune = 0.0f;
    
    // Pitch Modulation State (Optimization)
    float baseFrequency = 440.0f;
    float currentDetuneFactor = 1.0f;
    
    bool isHardSyncEnabled = false;
    bool isRingModEnabled = false;
    
    float glideTime = 0.0f;
    float currentFrequency = 440.0f;
    float targetFrequency = 440.0f;
    
    // LFO State
    DSP::LFO lfoModule;
    float vibratoDepth = 0.0f;
    
    // Pitch Bend
    float pitchBendFactor = 1.0f;
    float masterTuneFactor = 1.0f;
    
    // Helper
    float midiNoteToFrequency(int midiNote) const noexcept;

private:
    // ===== ADSR STATE (NEW) =====
    struct ADSRParams {
        float attackMs = 10.0f;
        float decayMs = 200.0f;
        float sustainLevel = 0.5f;
        float releaseMs = 100.0f;
    };
    
    ADSRParams dcwADSR;  // DCW envelope state
    ADSRParams dcaADSR;  // DCA envelope state
    ADSRParams pitchADSR;  // Pitch envelope state
    
    // Helper to update envelopes from ADSR using stored sampleRate
    void updateDCWEnvelopeFromADSR() noexcept;
    void updateDCAEnvelopeFromADSR() noexcept;
    void updatePitchEnvelopeFromADSR() noexcept;

    double sampleRate = 44100.0;

};
} // namespace Core
} // namespace CZ101

================================================================================
FILE: .\Source\Core\VoiceManager.cpp
================================================================================
#include "VoiceManager.h"
#include "../DSP/Modulation/LFO.h"
#include <algorithm>

namespace CZ101 {
namespace Core {

VoiceManager::VoiceManager()
{
    voices.resize(MAX_VOICES);
}

void VoiceManager::setSampleRate(double sampleRate) noexcept
{
    for (auto& voice : voices)
        voice.setSampleRate(sampleRate);
}

// Optimization: Use a macro or template if this gets too repetitive, 
// but for clarity we'll implement explicit loopers.

void VoiceManager::setOsc1Waveforms(int firstIndex, int secondIndex) noexcept
{
    auto f = static_cast<DSP::PhaseDistOscillator::CzWaveform>(firstIndex);
    auto s = static_cast<DSP::PhaseDistOscillator::CzWaveform>(secondIndex);
    for (auto& voice : voices) voice.setOsc1Waveforms(f, s);
}

void VoiceManager::setOsc1Level(float level) noexcept
{
    for (auto& voice : voices) voice.setOsc1Level(level);
}

void VoiceManager::setOsc2Waveforms(int firstIndex, int secondIndex) noexcept
{
    auto f = static_cast<DSP::PhaseDistOscillator::CzWaveform>(firstIndex);
    auto s = static_cast<DSP::PhaseDistOscillator::CzWaveform>(secondIndex);
    for (auto& voice : voices) voice.setOsc2Waveforms(f, s);
}

void VoiceManager::setOsc2Level(float level) noexcept
{
    for (auto& voice : voices) voice.setOsc2Level(level);
}

void VoiceManager::setOsc2Detune(float cents) noexcept
{
    for (auto& voice : voices) voice.setOsc2Detune(cents);
}

void VoiceManager::setDCWAttack(float seconds) noexcept { for (auto& v : voices) v.setDCWAttack(seconds); }
void VoiceManager::setDCWDecay(float seconds) noexcept { for (auto& v : voices) v.setDCWDecay(seconds); }
void VoiceManager::setDCWSustain(float level) noexcept { for (auto& v : voices) v.setDCWSustain(level); }
void VoiceManager::setDCWRelease(float seconds) noexcept { for (auto& v : voices) v.setDCWRelease(seconds); }

void VoiceManager::setDCAAttack(float seconds) noexcept { for (auto& v : voices) v.setDCAAttack(seconds); }
void VoiceManager::setDCADecay(float seconds) noexcept { for (auto& v : voices) v.setDCADecay(seconds); }
void VoiceManager::setDCASustain(float level) noexcept { for (auto& v : voices) v.setDCASustain(level); }
void VoiceManager::setDCARelease(float seconds) noexcept { for (auto& v : voices) v.setDCARelease(seconds); }

// 8-Stage Control
void VoiceManager::setDCWStage(int index, float rate, float level) noexcept { for (auto& v : voices) v.setDCWStage(index, rate, level); }
void VoiceManager::setDCWSustainPoint(int index) noexcept { for (auto& v : voices) v.setDCWSustainPoint(index); }
void VoiceManager::setDCWEndPoint(int index) noexcept { for (auto& v : voices) v.setDCWEndPoint(index); }

void VoiceManager::setDCAStage(int index, float rate, float level) noexcept { for (auto& v : voices) v.setDCAStage(index, rate, level); }
void VoiceManager::setDCASustainPoint(int index) noexcept { for (auto& v : voices) v.setDCASustainPoint(index); }
void VoiceManager::setDCAEndPoint(int index) noexcept { for (auto& v : voices) v.setDCAEndPoint(index); }

// Pitch Envelope
void VoiceManager::setPitchStage(int index, float rate, float level) noexcept { for (auto& v : voices) v.setPitchStage(index, rate, level); }
void VoiceManager::setPitchSustainPoint(int index) noexcept { for (auto& v : voices) v.setPitchSustainPoint(index); }
void VoiceManager::setPitchEndPoint(int index) noexcept { for (auto& v : voices) v.setPitchEndPoint(index); }

void VoiceManager::getDCWStage(int index, float& rate, float& level) const noexcept { voices[0].getDCWStage(index, rate, level); }
int VoiceManager::getDCWSustainPoint() const noexcept { return voices[0].getDCWSustainPoint(); }
int VoiceManager::getDCWEndPoint() const noexcept { return voices[0].getDCWEndPoint(); }

void VoiceManager::getDCAStage(int index, float& rate, float& level) const noexcept { voices[0].getDCAStage(index, rate, level); }
int VoiceManager::getDCASustainPoint() const noexcept { return voices[0].getDCASustainPoint(); }
int VoiceManager::getDCAEndPoint() const noexcept { return voices[0].getDCAEndPoint(); }

void VoiceManager::getPitchStage(int index, float& rate, float& level) const noexcept { voices[0].getPitchStage(index, rate, level); }
int VoiceManager::getPitchSustainPoint() const noexcept { return voices[0].getPitchSustainPoint(); }
int VoiceManager::getPitchEndPoint() const noexcept { return voices[0].getPitchEndPoint(); }

void VoiceManager::setHardSync(bool enabled) noexcept { for (auto& v : voices) v.setHardSync(enabled); }
void VoiceManager::setRingMod(bool enabled) noexcept { for (auto& v : voices) v.setRingMod(enabled); }
void VoiceManager::setGlideTime(float seconds) noexcept { for (auto& v : voices) v.setGlideTime(seconds); }
void VoiceManager::setMasterTune(float semitones) noexcept { for (auto& v : voices) v.setMasterTune(semitones); }
void VoiceManager::setPitchBend(float semitones) noexcept { for (auto& v : voices) v.setPitchBend(semitones); }

// LFO Control
void VoiceManager::setVibratoDepth(float semitones) noexcept { for (auto& v : voices) v.setVibratoDepth(semitones); }
void VoiceManager::setLFOFrequency(float hz) noexcept { for (auto& v : voices) v.setLFOFrequency(hz); }
void VoiceManager::setLFOWaveform(DSP::LFO::Waveform w) noexcept { for (auto& v : voices) v.setLFOWaveform(w); }
void VoiceManager::setLFODelay(float s) noexcept { for (auto& v : voices) v.setLFODelay(s); }

void VoiceManager::noteOn(int midiNote, float velocity) noexcept
{
    lastMidiNote = midiNote;

    // Check if any voice is already playing this note (e.g. still in release phase)
    // If so, steal it (monophonic retrigger per key) to prevent duplicate voices for same note
    int voiceIndex = findVoicePlayingNote(midiNote);
    
    if (voiceIndex < 0)
        voiceIndex = findFreeVoice();
    
    if (voiceIndex < 0)
        voiceIndex = findVoiceToSteal();
    
    if (voiceIndex >= 0)
        voices[voiceIndex].noteOn(midiNote, velocity);
}

void VoiceManager::noteOff(int midiNote) noexcept
{
    // Safely turn off ALL voices playing this note (just in case multiple exist)
    for (auto& voice : voices)
    {
        if (voice.isActive() && voice.getCurrentNote() == midiNote)
        {
            voice.noteOff();
        }
    }
}

void VoiceManager::allNotesOff() noexcept
{
    for (auto& voice : voices)
        voice.noteOff();
}


void VoiceManager::renderNextBlock(float* outputL, float* outputR, int numSamples) noexcept
{
    // LFO is now internal!
    
    for (int i = 0; i < numSamples; ++i)
    {
        float sample = 0.0f;
        for (auto& voice : voices)
        {
            if (voice.isActive()) // Optimization: Only render active voices
                sample += voice.renderNextSample();
        }
        
        outputL[i] = sample;
        outputR[i] = sample;
    }
}

int VoiceManager::getActiveVoiceCount() const noexcept
{
    int count = 0;
    for (const auto& voice : voices)
        if (voice.isActive())
            ++count;
    return count;
}

int VoiceManager::findFreeVoice() const noexcept
{
    for (size_t i = 0; i < voices.size(); ++i)
        if (!voices[i].isActive())
            return static_cast<int>(i);
    return -1;
}

int VoiceManager::findVoiceToSteal() const noexcept
{
    // Simple: steal first active voice (oldest)
    for (size_t i = 0; i < voices.size(); ++i)
        if (voices[i].isActive())
            return static_cast<int>(i);
    return 0;
}

int VoiceManager::findVoicePlayingNote(int midiNote) const noexcept
{
    for (size_t i = 0; i < voices.size(); ++i)
        if (voices[i].getCurrentNote() == midiNote)
            return static_cast<int>(i);
    return -1;
}

} // namespace Core
} // namespace CZ101

================================================================================
FILE: .\Source\Core\VoiceManager.h
================================================================================
#pragma once

#include "Voice.h"
#include <vector>

namespace CZ101 {

namespace DSP { class LFO; } // Forward declaration of LFO

namespace Core {

class VoiceManager
{
public:
    static constexpr int MAX_VOICES = 8;
    
    enum VoiceStealingMode
    {
        NONE,
        OLDEST,
        QUIETEST,
        RELEASE_PHASE
    };
    
    VoiceManager();
    
    void setSampleRate(double sampleRate) noexcept;
    void setVoiceStealingMode(VoiceStealingMode mode) noexcept { stealingMode = mode; }
    
    // Parameter Control (Proxy to all voices)
    // Oscillator 1
    // Oscillator 1
    void setOsc1Waveforms(int firstIndex, int secondIndex) noexcept;
    void setOsc1Level(float level) noexcept;
    
    // Oscillator 2
    void setOsc2Waveforms(int firstIndex, int secondIndex) noexcept;
    void setOsc2Level(float level) noexcept;
    void setOsc2Detune(float cents) noexcept;
    
    // DCW Envelope
    void setDCWAttack(float seconds) noexcept;
    void setDCWDecay(float seconds) noexcept;
    void setDCWSustain(float level) noexcept;
    void setDCWRelease(float seconds) noexcept;
    
    // DCA Envelope
    void setDCAAttack(float seconds) noexcept;
    void setDCADecay(float seconds) noexcept;
    void setDCASustain(float level) noexcept;
    void setDCARelease(float seconds) noexcept;
    
    // 8-Stage Envelope Control
    void setDCWStage(int index, float rate, float level) noexcept;
    void setDCWSustainPoint(int index) noexcept;
    void setDCWEndPoint(int index) noexcept;

    // Getters for UI
    void getDCWStage(int index, float& rate, float& level) const noexcept;
    int getDCWSustainPoint() const noexcept;
    int getDCWEndPoint() const noexcept;

    void getDCAStage(int index, float& rate, float& level) const noexcept;
    int getDCASustainPoint() const noexcept;
    int getDCAEndPoint() const noexcept;
    
    void getPitchStage(int index, float& rate, float& level) const noexcept;
    int getPitchSustainPoint() const noexcept;
    int getPitchEndPoint() const noexcept;
    
    void setDCAStage(int index, float rate, float level) noexcept;
    void setDCASustainPoint(int index) noexcept;
    void setDCAEndPoint(int index) noexcept;

    // Pitch Envelope (DCO)
    void setPitchStage(int index, float rate, float level) noexcept;
    void setPitchSustainPoint(int index) noexcept;
    void setPitchEndPoint(int index) noexcept;

    // Hard Sync
    void setHardSync(bool enabled) noexcept;

    // Ring Mod
    void setRingMod(bool enabled) noexcept;

    // Glide
    void setGlideTime(float seconds) noexcept;
    void setMasterTune(float semitones) noexcept;
    void setPitchBend(float semitones) noexcept;
    
    // LFO Control
    void setVibratoDepth(float semitones) noexcept;
    void setLFOFrequency(float hz) noexcept;
    void setLFOWaveform(DSP::LFO::Waveform waveform) noexcept;
    void setLFODelay(float seconds) noexcept;

    void noteOn(int midiNote, float velocity) noexcept;
    void noteOff(int midiNote) noexcept;
    void allNotesOff() noexcept;
    
    // Audio Processing
    // LFO is now internal to Voices
    void renderNextBlock(float* outputL, float* outputR, int numSamples) noexcept;
    
    int getActiveVoiceCount() const noexcept;
    int getCurrentNote() const noexcept { return lastMidiNote; }

private:
    std::vector<Voice> voices; // Dynamic vector for voice pool
    VoiceStealingMode stealingMode = RELEASE_PHASE;
    int lastMidiNote = -1;
    
    int findFreeVoice() const noexcept;
    int findVoiceToSteal() const noexcept;
    int findVoicePlayingNote(int midiNote) const noexcept;
};

} // namespace Core
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Chorus.cpp
================================================================================
#include "Chorus.h"
#include <cmath>

namespace CZ101 {
namespace DSP {
namespace Effects {

Chorus::Chorus()
{
    // Max delay depth 20ms usually enough (Allocating 50ms for safety)
    // 50ms at 192kHz ~= 9600 samples
    bufferSize = 16384; 
    delayBufferL.resize(bufferSize, 0.0f);
    delayBufferR.resize(bufferSize, 0.0f);
}

void Chorus::prepare(double sr)
{
    sampleRate = sr;
    setRate(rate); // Recalc increment
    reset();
}

void Chorus::reset()
{
    std::fill(delayBufferL.begin(), delayBufferL.end(), 0.0f);
    std::fill(delayBufferR.begin(), delayBufferR.end(), 0.0f);
    writeIndex = 0;
    lfoPhase = 0.0f;
}

void Chorus::setRate(float rateHz)
{
    rate = rateHz;
    // Inc per sample = Rate / SR
    // 2PI for sin? Or 0-1 phasor? Using 0-1
    lfoIncrement = rate / static_cast<float>(sampleRate);
}

void Chorus::setDepth(float depthMs)
{
    depth = depthMs;
}

void Chorus::setMix(float mix0to1)
{
    mix = std::clamp(mix0to1, 0.0f, 1.0f);
}

float Chorus::getInterpolatedSample(const std::vector<float>& buffer, float readIndex) const
{
    // Linear Interpolation
    int index1 = static_cast<int>(readIndex);
    int index2 = (index1 + 1) % bufferSize;
    float fraction = readIndex - index1;
    
    float s1 = buffer[index1];
    float s2 = buffer[index2];
    
    return s1 + fraction * (s2 - s1);
}

void Chorus::process(float* leftChannel, float* rightChannel, int numSamples)
{
    if (mix < 0.01f) return; // Bypass efficiency
    
    const float depthSamples = (depth / 1000.0f) * static_cast<float>(sampleRate);
    // Base delay for Chorus usually slightly more than depth excursion
    const float baseDelay = depthSamples * 1.5f + 100.0f; // Offset to avoid crossing write pointer
    
    for (int i = 0; i < numSamples; ++i)
    {
        // Update LFO
        lfoPhase += lfoIncrement;
        if (lfoPhase >= 1.0f) lfoPhase -= 1.0f;
        
        // Calculate LFO values
        // Left: Sin(phase)
        // Right: Cos(phase) or Sin(phase + 90) -> Separation
        float lfoValL = std::sin(lfoPhase * 2.0f * juce::MathConstants<float>::pi);
        float lfoValR = std::cos(lfoPhase * 2.0f * juce::MathConstants<float>::pi);
        
        // Calculate read positions
        // Delay = Base + Depth * LFO
        float delayL = baseDelay + (depthSamples * lfoValL);
        float delayR = baseDelay + (depthSamples * lfoValR);
        
        // Circular buffer read pointers
        float readPosL = static_cast<float>(writeIndex) - delayL;
        if (readPosL < 0.0f) readPosL += bufferSize;
        
        float readPosR = static_cast<float>(writeIndex) - delayR;
        if (readPosR < 0.0f) readPosR += bufferSize;
        
        // Read wet samples
        float wetL = getInterpolatedSample(delayBufferL, readPosL);
        float wetR = getInterpolatedSample(delayBufferR, readPosR);
        
        // Write inputs to buffer
        delayBufferL[writeIndex] = leftChannel[i];
        delayBufferR[writeIndex] = rightChannel[i];
        
        // Mix
        leftChannel[i] = (leftChannel[i] * (1.0f - mix * 0.5f)) + (wetL * mix);
        rightChannel[i] = (rightChannel[i] * (1.0f - mix * 0.5f)) + (wetR * mix);
        
        // Advance write pointer
        writeIndex++;
        if (writeIndex >= bufferSize) writeIndex = 0;
    }
}

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Chorus.h
================================================================================
#pragma once

#include <vector>
#include <cmath>
#include <JuceHeader.h>

namespace CZ101 {
namespace DSP {
namespace Effects {

class Chorus {
public:
    Chorus();
    
    void prepare(double sampleRate);
    void reset();
    
    void setRate(float rateHz);
    void setDepth(float depthMs);
    void setMix(float mix0to1);
    
    void process(float* leftChannel, float* rightChannel, int numSamples);
    
private:
    double sampleRate = 44100.0;
    
    // Parameters
    float rate = 0.5f;
    float depth = 2.0f; // ms
    float mix = 0.0f;
    
    // Delay lines
    std::vector<float> delayBufferL;
    std::vector<float> delayBufferR;
    int writeIndex = 0;
    int bufferSize = 0;
    
    // LFO state
    float lfoPhase = 0.0f;
    float lfoIncrement = 0.0f;
    
    // Helpers
    float getInterpolatedSample(const std::vector<float>& buffer, float readIndex) const;
};

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Delay.cpp
================================================================================
#include "Delay.h"

namespace CZ101 {
namespace DSP {
namespace Effects {

Delay::Delay()
{
    buffer.fill(0.0f);
}

void Delay::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
}

void Delay::setDelayTime(float seconds) noexcept
{
    seconds = std::clamp(seconds, 0.001f, 2.0f);
    delayInSamples = static_cast<int>(seconds * sampleRate);
    delayInSamples = std::min(delayInSamples, MAX_DELAY_SAMPLES - 1);
}

void Delay::setFeedback(float amount) noexcept
{
    feedback = std::clamp(amount, 0.0f, 0.95f);
}

void Delay::setMix(float amount) noexcept
{
    mix = std::clamp(amount, 0.0f, 1.0f);
}

void Delay::reset() noexcept
{
    buffer.fill(0.0f);
    writePos = 0;
}

float Delay::processSample(float input) noexcept
{
    int readPos = writePos - delayInSamples;
    if (readPos < 0)
        readPos += MAX_DELAY_SAMPLES;
    
    float delayed = buffer[readPos];
    buffer[writePos] = input + delayed * feedback;
    
    writePos = (writePos + 1) % MAX_DELAY_SAMPLES;
    
    return input * (1.0f - mix) + delayed * mix;
}

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Delay.h
================================================================================
#pragma once

#include <array>
#include <algorithm>

namespace CZ101 {
namespace DSP {
namespace Effects {
    
class Delay
{
public:
    Delay();
    
    void setSampleRate(double sampleRate) noexcept;
    void setDelayTime(float seconds) noexcept;
    void setFeedback(float amount) noexcept;
    void setMix(float amount) noexcept;
    void reset() noexcept;
    
    float processSample(float input) noexcept;
    
private:
    static constexpr int MAX_DELAY_SAMPLES = 88200;  // 2 seconds @ 44.1kHz
    
    std::array<float, MAX_DELAY_SAMPLES> buffer;
    double sampleRate = 44100.0;
    int delayInSamples = 22050;
    int writePos = 0;
    float feedback = 0.5f;
    float mix = 0.3f;
};

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Reverb.cpp
================================================================================
#include "Reverb.h"

namespace CZ101 {
namespace DSP {

Reverb::Reverb()
{
    // Set default parameters
    params.roomSize = 0.5f;
    params.damping = 0.5f;
    params.wetLevel = 0.33f;
    params.dryLevel = 1.0f; // Normally we control mix differently, but juce::Reverb has explicit wet/dry
    params.width = 1.0f;
    params.freezeMode = 0.0f;
    
    reverb.setParameters(params);
}

void Reverb::prepare(double sampleRate, int samplesPerBlock)
{
    currentSampleRate = sampleRate;
    reverb.setSampleRate(sampleRate);
    reverb.reset();
    (void)samplesPerBlock;
}

void Reverb::reset()
{
    reverb.reset();
}

void Reverb::setParameters(float roomSize, float damping, float wetLevel, float dryLevel, float width)
{
    params.roomSize = roomSize;
    params.damping = damping;
    params.wetLevel = wetLevel;
    params.dryLevel = dryLevel;
    params.width = width;
    
    reverb.setParameters(params);
}

void Reverb::process(juce::AudioBuffer<float>& buffer)
{
    // juce::Reverb processes stereo buffers naturally
    if (buffer.getNumChannels() == 2)
    {
        reverb.processStereo(buffer.getWritePointer(0), buffer.getWritePointer(1), buffer.getNumSamples());
    }
    else if (buffer.getNumChannels() == 1)
    {
        reverb.processMono(buffer.getWritePointer(0), buffer.getNumSamples());
    }
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Reverb.h
================================================================================
#pragma once

#include <juce_audio_basics/juce_audio_basics.h>

namespace CZ101 {
namespace DSP {

class Reverb
{
public:
    Reverb();
    
    void prepare(double sampleRate, int samplesPerBlock);
    void reset();
    
    void setParameters(float roomSize, float damping, float wetLevel, float dryLevel, float width);
    
    void process(juce::AudioBuffer<float>& buffer);
    
private:
    juce::Reverb reverb;
    juce::Reverb::Parameters params;
    
    double currentSampleRate = 44100.0;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\StereoChorus.cpp
================================================================================
#include "StereoChorus.h"

namespace CZ101 {
namespace DSP {
namespace Effects {

StereoChorus::StereoChorus() {
    // Set LFOs to be 90 degrees out of phase for stereo width
    lfoR.setPhaseOffset(0.25f); // 0.25 of a cycle is 90 degrees
}

void StereoChorus::prepare(double sampleRate) {
    sr = sampleRate;
    lfoL.setSampleRate(sr);
    lfoR.setSampleRate(sr);
    
    // Max delay of ~50ms should be plenty for a chorus
    int bufferSize = (int)(sr * 0.05);
    delayBufferL.setSize(bufferSize);
    delayBufferR.setSize(bufferSize);
    delayBufferL.clear();
    delayBufferR.clear();
}

void StereoChorus::process(float* left, float* right, int numSamples) {
    for (int i = 0; i < numSamples; ++i) {
        // Get LFO values (range -1 to 1)
        float lfoValL = lfoL.getNextValue();
        float lfoValR = lfoR.getNextValue();

        // Map LFO to a delay time perturbation
        // Example: 10ms base delay, modulated by +/- 5ms
        float baseDelayMs = 15.0f;
        float modulationDepthMs = 10.0f * depth;

        float delayMsL = baseDelayMs + modulationDepthMs * lfoValL;
        float delayMsR = baseDelayMs + modulationDepthMs * lfoValR;
        
        float delaySamplesL = (float)(sr * delayMsL / 1000.0);
        float delaySamplesR = (float)(sr * delayMsR / 1000.0);

        // Get delayed samples
        float delayedL = delayBufferL.getInterpolated(delaySamplesL);
        float delayedR = delayBufferR.getInterpolated(delaySamplesR);
        
        // Write current dry sample to buffer for future reads
        delayBufferL.push(left[i]);
        delayBufferR.push(right[i]);

        // Mix dry and wet signals
        left[i]  = (1.0f - mix) * left[i]  + mix * delayedL;
        right[i] = (1.0f - mix) * right[i] + mix * delayedR;
    }
}

void StereoChorus::setRate(float rateHz) {
    rate = rateHz;
    lfoL.setFrequency(rate);
    lfoR.setFrequency(rate);
}

void StereoChorus::setDepth(float d) {
    depth = juce::jlimit(0.0f, 1.0f, d);
}

void StereoChorus::setMix(float m) {
    mix = juce::jlimit(0.0f, 1.0f, m);
}

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\StereoChorus.h
================================================================================
#pragma once

#include <JuceHeader.h>
// Corregido para usar una ruta de inclusiÃ³n directa desde la raÃ­z de 'Source'
#include "Utils/CircularBuffer.h"
#include "../Modulation/LFO.h"

namespace CZ101 {
namespace DSP {
namespace Effects {

class StereoChorus {
public:
    StereoChorus();

    void prepare(double sampleRate);
    void process(float* left, float* right, int numSamples);
    
    void setRate(float rateHz);
    void setDepth(float depth);
    void setMix(float mix);

private:
    double sr = 44100.0;
    LFO lfoL, lfoR;
    Utils::CircularBuffer<float> delayBufferL, delayBufferR;
    float rate = 1.0f;
    float depth = 0.5f;
    float mix = 0.5f;
};

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Envelopes\ADSREnvelope.cpp
================================================================================
#include "ADSREnvelope.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

ADSREnvelope::ADSREnvelope()
{
}

void ADSREnvelope::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
}

void ADSREnvelope::setAttackTime(float seconds) noexcept
{
    attackTime = std::clamp(seconds, 0.001f, 10.0f);
}

void ADSREnvelope::setDecayTime(float seconds) noexcept
{
    decayTime = std::clamp(seconds, 0.001f, 10.0f);
}

void ADSREnvelope::setSustainLevel(float level) noexcept
{
    sustainLevel = std::clamp(level, 0.0f, 1.0f);
}

void ADSREnvelope::setReleaseTime(float seconds) noexcept
{
    releaseTime = std::clamp(seconds, 0.001f, 10.0f);
}

void ADSREnvelope::noteOn() noexcept
{
    currentStage = ATTACK;
    stageProgress = 0.0f;
}

void ADSREnvelope::noteOff() noexcept
{
    if (currentStage != IDLE)
    {
        currentStage = RELEASE;
        stageProgress = 0.0f;
    }
}

void ADSREnvelope::reset() noexcept
{
    currentStage = IDLE;
    currentValue = 0.0f;
    stageProgress = 0.0f;
}

float ADSREnvelope::getNextValue() noexcept
{
    if (currentStage == IDLE)
        return 0.0f;
    
    float stageDuration = 0.0f;
    float targetValue = 0.0f;
    float startValue = currentValue;
    
    switch (currentStage)
    {
        case ATTACK:
            stageDuration = attackTime;
            targetValue = 1.0f;
            startValue = 0.0f;
            break;
            
        case DECAY:
            stageDuration = decayTime;
            targetValue = sustainLevel;
            startValue = 1.0f;
            break;
            
        case SUSTAIN:
            return sustainLevel;
            
        case RELEASE:
            stageDuration = releaseTime;
            targetValue = 0.0f;
            startValue = currentValue;
            break;
            
        default:
            return 0.0f;
    }
    
    // Calculate progress increment
    float increment = 1.0f / (stageDuration * static_cast<float>(sampleRate));
    stageProgress += increment;
    
    // Apply exponential curve
    float curvedProgress = calculateExponentialCurve(stageProgress);
    
    // Interpolate between start and target
    currentValue = startValue + (targetValue - startValue) * curvedProgress;
    
    // Check if stage is complete
    if (stageProgress >= 1.0f)
    {
        currentValue = targetValue;
        advanceStage();
    }
    
    return currentValue;
}

float ADSREnvelope::calculateExponentialCurve(float t) const noexcept
{
    // Exponential curve: 1 - e^(-factor * t)
    // This creates a natural-sounding envelope
    t = std::clamp(t, 0.0f, 1.0f);
    return 1.0f - std::exp(-CURVE_FACTOR * t);
}

void ADSREnvelope::advanceStage() noexcept
{
    stageProgress = 0.0f;
    
    switch (currentStage)
    {
        case ATTACK:
            currentStage = DECAY;
            break;
            
        case DECAY:
            currentStage = SUSTAIN;
            break;
            
        case SUSTAIN:
            // Stay in sustain until noteOff
            break;
            
        case RELEASE:
            currentStage = IDLE;
            currentValue = 0.0f;
            break;
            
        default:
            break;
    }
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Envelopes\ADSREnvelope.h
================================================================================
#pragma once

#include <cmath>

namespace CZ101 {
namespace DSP {

/**
 * @brief ADSR Envelope Generator
 * 
 * Classic Attack-Decay-Sustain-Release envelope with exponential curves.
 * Used for both amplitude (DCA) and filter/timbre (DCW) modulation.
 */
class ADSREnvelope
{
public:
    enum Stage
    {
        IDLE = 0,
        ATTACK,
        DECAY,
        SUSTAIN,
        RELEASE,
        NUM_STAGES
    };
    
    ADSREnvelope();
    
    void setSampleRate(double sampleRate) noexcept;
    
    // Parameters in seconds
    void setAttackTime(float seconds) noexcept;
    void setDecayTime(float seconds) noexcept;
    void setSustainLevel(float level) noexcept;  // [0.0, 1.0]
    void setReleaseTime(float seconds) noexcept;
    
    void noteOn() noexcept;
    void noteOff() noexcept;
    void reset() noexcept;
    
    /**
     * @brief Get next envelope value
     * @return Envelope value [0.0, 1.0]
     */
    float getNextValue() noexcept;
    
    Stage getCurrentStage() const noexcept { return currentStage; }
    bool isActive() const noexcept { return currentStage != IDLE; }
    
private:
    double sampleRate = 44100.0;
    
    // Parameters
    float attackTime = 0.01f;    // 10ms
    float decayTime = 0.1f;      // 100ms
    float sustainLevel = 0.7f;   // 70%
    float releaseTime = 0.2f;    // 200ms
    
    // State
    Stage currentStage = IDLE;
    float currentValue = 0.0f;
    float stageProgress = 0.0f;  // [0.0, 1.0]
    
    // Exponential curve factor (higher = more exponential)
    static constexpr float CURVE_FACTOR = 4.0f;
    
    float calculateExponentialCurve(float t) const noexcept;
    void advanceStage() noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Envelopes\ADSRtoStage.h
================================================================================
#pragma once

#include <cmath>
#include <array>
#include <algorithm>

namespace CZ101 {
namespace DSP {

/**
 * @brief ConversiÃ³n ADSR â†’ 8-stage envelope rates
 * 
 * Mapea parÃ¡metros ADSR (milisegundos) a coeficientes de stage
 * usando aproximaciÃ³n logarÃ­tmica basada en tiempo de caÃ­da 60dB
 */
struct ADSRtoStageConverter {
    
    /**
     * @brief Convertir ADSR a 8 stages
     * 
     * @param attackMs      Attack time (0-8000ms)
     * @param decayMs       Decay time (0-8000ms)
     * @param sustainLevel  Sustain level (0-1.0)
     * @param releaseMs     Release time (0-8000ms)
     * @param outRates      [OUT] array de 8 coeficientes de rate
     * @param outLevels     [OUT] array de 8 niveles objetivo
     * @param outSustainPoint [OUT] Ã­ndice de sustain
     * @param outEndPoint   [OUT] Ã­ndice de fin
     * @param sampleRate    Sample rate (default 44100)
     */
    static void convertADSR(
        float attackMs,
        float decayMs,
        float sustainLevel,
        float releaseMs,
        std::array<float, 8>& outRates,
        std::array<float, 8>& outLevels,
        int& outSustainPoint,
        int& outEndPoint,
        double sampleRate = 44100.0
    ) {
        // Validar y clampear inputs
        attackMs = std::clamp(attackMs, 0.0f, 8000.0f);
        decayMs = std::clamp(decayMs, 0.0f, 8000.0f);
        sustainLevel = std::clamp(sustainLevel, 0.0f, 1.0f);
        releaseMs = std::clamp(releaseMs, 0.0f, 8000.0f);
        
        // FunciÃ³n interna: convertir milisegundos â†’ coeficiente de decay
        auto msToRateCoeff = [sampleRate](float ms) -> float {
            if (ms < 1.0f) ms = 1.0f;
            if (ms > 8000.0f) ms = 8000.0f;
            
            // Convertir a segundos
            float sec = ms / 1000.0f;
            
            // Exponential decay: e^(-k*t)
            // Para 60dB en tiempo T: k = 5.5 / T
            float k = 5.5f / (sec * static_cast<float>(sampleRate));
            
            // Coeficiente per-sample: rate = e^(-k)
            float coeff = std::exp(-k);
            
            // Clamp para estabilidad numÃ©rica
            return std::clamp(coeff, 0.001f, 0.99f);
        };
        
        // ===== STAGE 0: ATTACK =====
        // Rampa desde 0 hacia 1.0
        outRates[0] = msToRateCoeff(attackMs);
        outLevels[0] = 1.0f;
        
        // ===== STAGE 1: DECAY =====
        // Rampa desde 1.0 hacia sustain
        outRates[1] = msToRateCoeff(decayMs);
        outLevels[1] = sustainLevel;
        
        // ===== STAGE 2: SUSTAIN HOLD =====
        // Mantiene nivel de sustain (sin decaimiento)
        outRates[2] = 0.99f;
        outLevels[2] = sustainLevel;
        
        // ===== STAGE 3: RELEASE =====
        // Rampa desde sustain hacia 0
        outRates[3] = msToRateCoeff(releaseMs);
        outLevels[3] = 0.0f;
        
        // ===== STAGES 4-7: UNUSED =====
        for (int i = 4; i < 8; ++i) {
            outRates[i] = 0.99f;
            outLevels[i] = 0.0f;
        }
        
        // Puntos de control de sustain y fin
        outSustainPoint = 2;  // Sustain en stage 2
        outEndPoint = 3;      // Release en stage 3
    }
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Envelopes\MultiStageEnv.cpp
================================================================================
#include "MultiStageEnv.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

MultiStageEnvelope::MultiStageEnvelope()
{
    // Default: Simple ADSR-like shape using 8 stages
    // Stage 0: Attack to 1.0
    setStage(0, 0.9f, 1.0f);
    // Stage 1: Decay to 0.5
    setStage(1, 0.8f, 0.5f);
    // Stage 2: Sustain at 0.5
    setStage(2, 0.99f, 0.5f);
    
    // Sets sustain point at Stage 2
    setSustainPoint(2);
    
    // Stage 3: Release to 0
    setStage(3, 0.8f, 0.0f);
    
    // End point at Stage 3
    setEndPoint(3);
}

void MultiStageEnvelope::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
}

void MultiStageEnvelope::setStage(int index, float rate, float level) noexcept
{
    if (index >= 0 && index < MAX_STAGES)
    {
        stages[index].rate = std::clamp(rate, 0.0f, 1.0f);
        stages[index].level = std::clamp(level, 0.0f, 1.0f);
    }
}

void MultiStageEnvelope::setSustainPoint(int stageIndex) noexcept
{
    if (stageIndex >= -1 && stageIndex < MAX_STAGES)
        sustainPoint = stageIndex;
}

void MultiStageEnvelope::setEndPoint(int stageIndex) noexcept
{
    if (stageIndex >= 0 && stageIndex < MAX_STAGES)
        endPoint = stageIndex;
}

void MultiStageEnvelope::noteOn() noexcept
{
    currentStage = 0;
    active = true;
    released = false;
    
    // Start from 0
    float startVal = 0.0f;
    smoother.setCurrentAndTargetValue(startVal);
    
    // Setup first stage
    float seconds = rateToSeconds(stages[0].rate);
    smoother.reset(sampleRate, seconds > 0.001f ? seconds : 0.001f); 
    smoother.setCurrentAndTargetValue(startVal);
    smoother.setTargetValue(stages[0].level);
}

void MultiStageEnvelope::noteOff() noexcept
{
    released = true;
    
    // AUTHENTIC CZ BEHAVIOR: "Dampening" / Jump to End Point
    // When key is released, regardless of current stage (even if before sustain),
    // the envelope immediately targets the End Point Level using the End Point Rate.
    if (active)
    {
        // Jump state to End Point
        // Note: In CZ, the "End Point" step IS the release phase.
        currentStage = endPoint;

        // Verify validity
        if (currentStage < MAX_STAGES)
        {
            // Retarget smoother from current value to End Point Level
            float currentVal = smoother.getCurrentValue();
            float seconds = rateToSeconds(stages[currentStage].rate);
            
            smoother.reset(sampleRate, seconds > 0.001f ? seconds : 0.001f);
            smoother.setCurrentAndTargetValue(currentVal);
            smoother.setTargetValue(stages[currentStage].level);
        }
        else
        {
            active = false;
        }
    }
}

void MultiStageEnvelope::reset() noexcept
{
    active = false;
    currentStage = 0;
    smoother.setCurrentAndTargetValue(0.0f);
}

float MultiStageEnvelope::getNextValue() noexcept
{
    if (!active) return 0.0f;
    
    float val = smoother.getNextValue();
    
    // Check if stage finished
    if (!smoother.isSmoothing())
    {
        val = smoother.getTargetValue(); // Ensure snap
        
        // Are we at Sustain Point?
        if (currentStage == sustainPoint && !released)
        {
            // Hold here until Note Off
            // Do nothing, just return val
        }
        else if (currentStage >= endPoint)
        {
            // End of envelope
            // If released or no sustain, we are done
            // If we are sustaining at end (unlikely for CZ architecture, end is end), disable.
            active = false;
        }
        else
        {
            // Move to next stage
            currentStage++;
            
            if (currentStage < MAX_STAGES)
            {
                float currentVal = val;
                float seconds = rateToSeconds(stages[currentStage].rate);
                smoother.reset(sampleRate, seconds > 0.001f ? seconds : 0.001f);
                smoother.setCurrentAndTargetValue(currentVal);
                smoother.setTargetValue(stages[currentStage].level);
            }
            else
            {
                active = false;
            }
        }
    }
    
    return val;
}

float MultiStageEnvelope::rateToSeconds(float rate) const noexcept
{
    // CZ-101 Rate approximation
    // Rate 0.0 (slow) -> ~3 seconds (can be longer on real hardware)
    // Rate 1.0 (fast) -> ~1 ms
    
    // Using exponential curve
    // Invert rate: 1.0 is slow, 0.0 is fast for calculation
    float r = 1.0f - rate;
    
    // Base 30s max time
    return 0.001f + (std::pow(r, 4.0f) * 30.0f);
}

float MultiStageEnvelope::getStageRate(int index) const noexcept
{
    if (index >= 0 && index < MAX_STAGES)
        return stages[index].rate;
    return 0.0f;
}

float MultiStageEnvelope::getStageLevel(int index) const noexcept
{
    if (index >= 0 && index < MAX_STAGES)
        return stages[index].level;
    return 0.0f;
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Envelopes\MultiStageEnv.h
================================================================================
#pragma once

#include <array>
#include <cmath>
#include <juce_audio_basics/juce_audio_basics.h>

namespace CZ101 {
namespace DSP {

/**
 * @brief Multi-Stage Envelope Generator (8 stages)
 * 
 * Authentic CZ-101 Envelope Architecture:
 * - 8 Steps per envelope
 * - Each step has a Rate (speed) and Level (target)
 * - Sustain Point: The step where the envelope holds while key is pressed.
 * - End Point: The final step of the envelope.
 */
class MultiStageEnvelope
{
public:
    static constexpr int MAX_STAGES = 8;
    
    struct Stage
    {
        float level = 0.0f;      // Target level [0.0, 1.0]
        float rate = 0.5f;       // Speed to reach level [0.0, 1.0] (1.0 = fast, 0.0 = slow)
    };
    
    MultiStageEnvelope();
    
    void setSampleRate(double sampleRate) noexcept;
    
    // Configuration
    void setStage(int index, float rate, float level) noexcept;
    void setSustainPoint(int stageIndex) noexcept;
    void setEndPoint(int stageIndex) noexcept;
    
    // Runtime
    void noteOn() noexcept;
    void noteOff() noexcept;
    void reset() noexcept;
    
    float getNextValue() noexcept;
    
    // Getters for adapter logic
    float getStageRate(int index) const noexcept;
    float getStageLevel(int index) const noexcept;
    
    bool isActive() const noexcept { return active; }
    int getCurrentStage() const noexcept { return currentStage; }
    
    int getSustainPoint() const noexcept { return sustainPoint; }
    int getEndPoint() const noexcept { return endPoint; }
    
private:
    double sampleRate = 44100.0;
    std::array<Stage, MAX_STAGES> stages;
    
    // Envelope Smoother
    juce::LinearSmoothedValue<float> smoother;
    
    int currentStage = 0;
    // Removed manual currentValue/Increment/targetValue as smoother handles it
    
    int sustainPoint = -1;  // -1 = no sustain (or one-shot)
    int endPoint = 7;       // Default to using all 8 stages
    
    bool active = false;
    bool released = false;
    
    // CZ-101 Rate to Time conversion (internal helper)
    // Rate 0-99 mapped to ms
    float rateToSeconds(float rate) const noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Filters\ResonantFilter.cpp
================================================================================
#include "ResonantFilter.h"

namespace CZ101 {
namespace DSP {

ResonantFilter::ResonantFilter()
{
    updateCoefficients();
}

void ResonantFilter::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
    updateCoefficients();
}

void ResonantFilter::setType(Type type) noexcept
{
    filterType = type;
    updateCoefficients();
}

void ResonantFilter::setCutoff(float frequency) noexcept
{
    cutoffFreq = std::clamp(frequency, 20.0f, 20000.0f);
    updateCoefficients();
}

void ResonantFilter::setResonance(float q) noexcept
{
    resonance = std::clamp(q, 0.1f, 10.0f);
    updateCoefficients();
}

void ResonantFilter::reset() noexcept
{
    z1 = 0.0f;
    z2 = 0.0f;
}

float ResonantFilter::processSample(float input) noexcept
{
    float output = a0 * input + a1 * z1 + a2 * z2 - b1 * z1 - b2 * z2;
    
    z2 = z1;
    z1 = output;
    
    return output;
}

void ResonantFilter::updateCoefficients() noexcept
{
    constexpr float PI = 3.14159265358979323846f;
    
    float omega = 2.0f * PI * cutoffFreq / static_cast<float>(sampleRate);
    float sinOmega = std::sin(omega);
    float cosOmega = std::cos(omega);
    float alpha = sinOmega / (2.0f * resonance);
    
    switch (filterType)
    {
        case LOWPASS:
        {
            float b0 = (1.0f - cosOmega) / 2.0f;
            float b1_coef = 1.0f - cosOmega;
            float b2_coef = (1.0f - cosOmega) / 2.0f;
            float a0_coef = 1.0f + alpha;
            float a1_coef = -2.0f * cosOmega;
            float a2_coef = 1.0f - alpha;
            
            a0 = b0 / a0_coef;
            a1 = b1_coef / a0_coef;
            a2 = b2_coef / a0_coef;
            b1 = a1_coef / a0_coef;
            b2 = a2_coef / a0_coef;
            break;
        }
        
        case HIGHPASS:
        {
            float b0 = (1.0f + cosOmega) / 2.0f;
            float b1_coef = -(1.0f + cosOmega);
            float b2_coef = (1.0f + cosOmega) / 2.0f;
            float a0_coef = 1.0f + alpha;
            float a1_coef = -2.0f * cosOmega;
            float a2_coef = 1.0f - alpha;
            
            a0 = b0 / a0_coef;
            a1 = b1_coef / a0_coef;
            a2 = b2_coef / a0_coef;
            b1 = a1_coef / a0_coef;
            b2 = a2_coef / a0_coef;
            break;
        }
        
        case BANDPASS:
        {
            float b0 = alpha;
            float b1_coef = 0.0f;
            float b2_coef = -alpha;
            float a0_coef = 1.0f + alpha;
            float a1_coef = -2.0f * cosOmega;
            float a2_coef = 1.0f - alpha;
            
            a0 = b0 / a0_coef;
            a1 = b1_coef / a0_coef;
            a2 = b2_coef / a0_coef;
            b1 = a1_coef / a0_coef;
            b2 = a2_coef / a0_coef;
            break;
        }
        
        default:
            break;
    }
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Filters\ResonantFilter.h
================================================================================
#pragma once

#include <cmath>
#include <algorithm>

namespace CZ101 {
namespace DSP {

class ResonantFilter
{
public:
    enum Type
    {
        LOWPASS = 0,
        HIGHPASS,
        BANDPASS,
        NUM_TYPES
    };
    
    ResonantFilter();
    
    void setSampleRate(double sampleRate) noexcept;
    void setType(Type type) noexcept;
    void setCutoff(float frequency) noexcept;
    void setResonance(float q) noexcept;
    void reset() noexcept;
    
    float processSample(float input) noexcept;
    
private:
    double sampleRate = 44100.0;
    Type filterType = LOWPASS;
    float cutoffFreq = 1000.0f;
    float resonance = 0.7f;
    
    // State variables (2-pole)
    float z1 = 0.0f;
    float z2 = 0.0f;
    
    // Coefficients
    float a0 = 1.0f, a1 = 0.0f, a2 = 0.0f;
    float b1 = 0.0f, b2 = 0.0f;
    
    void updateCoefficients() noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Modulation\LFO.cpp
================================================================================
#include "LFO.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

LFO::LFO()
{
    updatePhaseIncrement();
}

void LFO::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
    updatePhaseIncrement();
}

void LFO::setFrequency(float hz) noexcept
{
    frequency = std::clamp(hz, 0.01f, 30.0f); // Range updated to 30Hz authentic/useful range
    updatePhaseIncrement();
}

void LFO::setWaveform(Waveform waveform) noexcept
{
    currentWaveform = waveform;
}

void LFO::setDelay(float seconds) noexcept
{
    delayTime = std::max(0.0f, seconds);
}

void LFO::reset() noexcept
{
    phase = 0.0f;
    delayTimer = 0.0f; // Reset delay timer on Note On
}

void LFO::updatePhaseIncrement() noexcept
{
    phaseIncrement = frequency / static_cast<float>(sampleRate);
}

void LFO::setPhaseOffset(float offset) noexcept
{
    phaseOffset = offset;
}

float LFO::getNextValue() noexcept
{
    // Handle Delay
    if (delayTimer < delayTime)
    {
        delayTimer += (1.0f / static_cast<float>(sampleRate));
        if (delayTimer < delayTime)
        {
            // Still in delay phase
            return 0.0f;
        }
        else
        {
            // Delay finished, reset phase?
            phase = 0.0f;
        }
    }
    
    // Calculate current position including offset
    float currentPos = phase + phaseOffset;
    while (currentPos >= 1.0f) currentPos -= 1.0f;
    while (currentPos < 0.0f) currentPos += 1.0f;

    float value = 0.0f;
    
    switch (currentWaveform)
    {
        case TRIANGLE: 
            if (currentPos < 0.25f) value = 4.0f * currentPos;
            else if (currentPos < 0.75f) value = 2.0f - 4.0f * currentPos;
            else value = 4.0f * currentPos - 4.0f;
            break;
            
        case SAW_UP: // Ramp Up
            value = 2.0f * currentPos - 1.0f;
            break;
            
        case SAW_DOWN: // Ramp Down
            value = 1.0f - 2.0f * currentPos;
            break;
            
        case SQUARE: // Trill
            value = (currentPos < 0.5f) ? 1.0f : -1.0f;
            break;
            
        default: value = 0.0f;
    }
    
    phase += phaseIncrement;
    if (phase >= 1.0f)
        phase -= 1.0f;
    
    return value;
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Modulation\LFO.h
================================================================================
#pragma once

#include <cmath>

namespace CZ101 {
namespace DSP {

class LFO
{
public:
    enum Waveform
    {
        TRIANGLE = 0,
        SAW_UP,
        SAW_DOWN,
        SQUARE,
        NUM_WAVEFORMS
    };
    
    LFO();
    
    void setSampleRate(double sampleRate) noexcept;
    void setFrequency(float hz) noexcept;
    void setWaveform(Waveform waveform) noexcept;
    void setDelay(float seconds) noexcept;
    void setPhaseOffset(float offset) noexcept; // For Chorus
    
    void reset() noexcept; // Resets phase AND delay timer
    
    float getNextValue() noexcept;
    
private:
    double sampleRate = 44100.0;
    float frequency = 1.0f;
    Waveform currentWaveform = TRIANGLE;
    float phase = 0.0f;
    float phaseOffset = 0.0f;
    float phaseIncrement = 0.0f;
    
    // Delay Logic
    float delayTime = 0.0f;
    float delayTimer = 0.0f;
    
    void updatePhaseIncrement() noexcept;
    float renderSine() noexcept;
    float renderTriangle() noexcept;
    float renderSawtooth() noexcept;
    float renderSquare() noexcept;
    float renderRandom() noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\PhaseDistOsc.cpp
================================================================================
#include "PhaseDistOsc.h"
#include <algorithm>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

namespace CZ101 {
namespace DSP {

PhaseDistOscillator::PhaseDistOscillator()
{
    updatePhaseIncrement();
}

void PhaseDistOscillator::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
    updatePhaseIncrement();
}

void PhaseDistOscillator::setFrequency(float freq) noexcept
{
    frequency = std::clamp(freq, 20.0f, 20000.0f);
    updatePhaseIncrement();
}

void PhaseDistOscillator::setWaveforms(CzWaveform first, CzWaveform second) noexcept
{
    firstWaveform = first;
    
    // CZ Logic: Second waveform 0-8. If 0 (caller handles mapping to NONE or we handle it here).
    // Assuming the caller passes NUM_CZ_WAVEFORMS or similar for "Off" if they converted 0->None.
    // However, the cleanest way is: if second is valid enum, it's active.
    // We will assume the caller sets 'secondWaveformActive' logic via this call.
    // For now, let's assume if second is 'NUM_CZ_WAVEFORMS' (8), it is OFF.
    // But the enum only goes up to 7 (Resonance 3).
    // Let's modify logic: if caller passes same as first, it's just mixing 2 same. 
    // We need a way to say "OFF".
    // I will use a convention: The VoiceManager will refrain from calling this if 0, 
    // or passing a specific signal.
    // Let's rely on 'secondWaveformActive' being set by checking if second != NUM_CZ_WAVEFORMS.
    
    secondWaveform = second;
    secondWaveformActive = (second != NUM_CZ_WAVEFORMS); 
}

void PhaseDistOscillator::reset() noexcept
{
    phase = 0.0f;
}

void PhaseDistOscillator::updatePhaseIncrement() noexcept
{
    phaseIncrement = static_cast<float>(frequency / sampleRate);
}

// Helper for applying PD
// Now static-like, takes waveform as arg
float PhaseDistOscillator::applyPhaseDistortion(float linearPhase, float dcwValue, CzWaveform wave) noexcept
{
    float distortedPhase = linearPhase;

    switch (wave)
    {
        case SAWTOOTH:
        {
            float distorted = (linearPhase < 0.5f) ? (linearPhase * 2.0f) : 1.0f;
            distortedPhase = linearPhase + (distorted - linearPhase) * dcwValue;
            break;
        }
        
        case SQUARE:
        {
            float distorted = (linearPhase < 0.5f) ? 0.25f : 0.75f;
            distortedPhase = linearPhase + (distorted - linearPhase) * dcwValue;
            break;
        }

        case PULSE:
        {
            float distorted = (linearPhase < 0.25f) ? 0.25f : 0.75f;
            distortedPhase = linearPhase + (distorted - linearPhase) * dcwValue;
            break;
        }

        case DOUBLE_SINE:
        {
            float distorted = linearPhase * 2.0f;
            distortedPhase = linearPhase + (distorted - linearPhase) * dcwValue;
            break;
        }

        case SAW_PULSE:
        {
            float distorted = (linearPhase < 0.5f) ? (linearPhase * 2.0f) : 0.75f;
            distortedPhase = linearPhase + (distorted - linearPhase) * dcwValue;
            break;
        }

        case RESONANCE_1:
        {
            float modFrequency = 2.0f;
            float sineMod = sin(linearPhase * 2.0f * M_PI * modFrequency);
            float maxModAmount = 0.15f; 
            float distorted = linearPhase + sineMod * maxModAmount;
            distortedPhase = linearPhase + (distorted - linearPhase) * dcwValue;
            break;
        }

        case RESONANCE_2:
        {
            float modFrequency = 4.0f;
            float sineMod = sin(linearPhase * 2.0f * M_PI * modFrequency);
            float maxModAmount = 0.20f; 
            float distorted = linearPhase + sineMod * maxModAmount;
            distortedPhase = linearPhase + (distorted - linearPhase) * dcwValue;
            break;
        }

        case RESONANCE_3:
        {
            float modFrequency = 7.0f;
            float sineMod = sin(linearPhase * 2.0f * M_PI * modFrequency);
            float maxModAmount = 0.25f; 
            float distorted = linearPhase + sineMod * maxModAmount;
            distortedPhase = linearPhase + (distorted - linearPhase) * dcwValue;
            break;
        }

        default:
            distortedPhase = linearPhase;
            break;
    }

    if (distortedPhase >= 1.0f) distortedPhase -= 1.0f;
    if (distortedPhase < 0.0f) distortedPhase += 1.0f;

    return distortedPhase;
}

// Helper for PolyBLEP
float PhaseDistOscillator::polyBLEP(float t, float dt) const noexcept
{
    if (t < dt) {
        t /= dt;
        return t + t - t * t - 1.0f;
    }
    else if (t > 1.0f - dt) {
        t = (t - 1.0f) / dt;
        return t * t + t + t + 1.0f;
    }
    return 0.0f;
}

float PhaseDistOscillator::renderNextSample(float dcwAmount, bool* outDidWrap) noexcept
{
    // --- WAVEFORM 1 ---
    float distPhase1 = applyPhaseDistortion(phase, dcwAmount, firstWaveform);
    float sample1 = waveTable.getSine(distPhase1);

    // Apply BLEP 1
    if (firstWaveform == SAWTOOTH)
    {
        sample1 -= polyBLEP(phase, phaseIncrement);
    }
    else if (firstWaveform == SQUARE)
    {
        sample1 += polyBLEP(phase, phaseIncrement);
        float ps = phase + 0.5f; if(ps>=1.0f) ps-=1.0f;
        sample1 -= polyBLEP(ps, phaseIncrement);
    }
    else if (firstWaveform == PULSE)
    {
        sample1 += polyBLEP(phase, phaseIncrement);
        float ps = phase + 0.75f; if(ps>=1.0f) ps-=1.0f;
        sample1 -= polyBLEP(ps, phaseIncrement);
    }
    else if (firstWaveform == SAW_PULSE)
    {
        sample1 += polyBLEP(phase, phaseIncrement);
        float ps = phase + 0.5f; if(ps>=1.0f) ps-=1.0f;
        sample1 -= polyBLEP(ps, phaseIncrement);
    }

    float finalSample = sample1;

    // --- WAVEFORM 2 (Mixing) ---
    if (secondWaveformActive)
    {
        float distPhase2 = applyPhaseDistortion(phase, dcwAmount, secondWaveform);
        float sample2 = waveTable.getSine(distPhase2);

        // Apply BLEP 2
        if (secondWaveform == SAWTOOTH)
        {
            sample2 -= polyBLEP(phase, phaseIncrement);
        }
        else if (secondWaveform == SQUARE)
        {
            sample2 += polyBLEP(phase, phaseIncrement);
            float ps = phase + 0.5f; if(ps>=1.0f) ps-=1.0f;
            sample2 -= polyBLEP(ps, phaseIncrement);
        }
        else if (secondWaveform == PULSE)
        {
            sample2 += polyBLEP(phase, phaseIncrement);
            float ps = phase + 0.75f; if(ps>=1.0f) ps-=1.0f;
            sample2 -= polyBLEP(ps, phaseIncrement);
        }
        else if (secondWaveform == SAW_PULSE)
        {
            sample2 += polyBLEP(phase, phaseIncrement);
            float ps = phase + 0.5f; if(ps>=1.0f) ps-=1.0f;
            sample2 -= polyBLEP(ps, phaseIncrement);
        }

        // Additive Mix (The "Painttube" analogy - simply pouring both in)
        // Authentic behavior sums them.
        finalSample += sample2;
        
        // Soft clip/Trace to avoid massive overs? 
        // Real CZ might saturate or validly output > 1.0 which DCA then scales.
        // We will leave as sum for now.
    }

    // Advance Phase
    phase += phaseIncrement;
    if (phase >= 1.0f)
    {
        phase -= 1.0f;
        if (outDidWrap) *outDidWrap = true;
    }
    else
    {
        if (outDidWrap) *outDidWrap = false;
    }
    
    return finalSample;
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\PhaseDistOsc.h
================================================================================
#pragma once

#include "WaveTable.h"
#include <cmath>

namespace CZ101 {
namespace DSP {

/**
 * @brief Phase Distortion Oscillator with PolyBLEP anti-aliasing
 * 
 * Core oscillator for CZ-101 emulation. Generates waveforms with
 * professional quality anti-aliasing using PolyBLEP technique.
 */
class PhaseDistOscillator
{
public:
    enum CzWaveform
    {
        SAWTOOTH,
        SQUARE,
        PULSE,
        DOUBLE_SINE,
        SAW_PULSE,
        RESONANCE_1,
        RESONANCE_2,
        RESONANCE_3,
        NUM_CZ_WAVEFORMS
    };
    
    PhaseDistOscillator();
    
    /**
     * @brief Set sample rate
     * @param sampleRate Sample rate in Hz (e.g., 44100.0)
     */
    void setSampleRate(double sampleRate) noexcept;
    
    /**
     * @brief Set frequency
     * @param frequency Frequency in Hz (e.g., 440.0 for A4)
     */
    void setFrequency(float frequency) noexcept;
    
    /**
     * @brief Set waveform type
     * @param waveform Waveform enum value
     */
    /**
     * @brief Set composite waveforms (Authentic CZ Behavior)
     * @param first First waveform (1-8)
     * @param second Second waveform (0-8, 0=None/Off)
     */
    void setWaveforms(CzWaveform first, CzWaveform second) noexcept;
    
    /**
     * @brief Reset phase to zero
     */
    void reset() noexcept;
    
    /**
     * @brief Render next sample with Phase Distortion simulation
     * @param dcwAmount Timbre control [0.0 = Pure Sine, 1.0 = Full Waveform]
     * @param outDidWrap Pointer to bool that will be set to true if phase wrapped (optional)
     * @return Audio sample [-1.0, 1.0]
     */
    float renderNextSample(float dcwAmount, bool* outDidWrap = nullptr) noexcept;
    
private:
    WaveTable waveTable;
    
    double sampleRate = 44100.0;
    float frequency = 440.0f;
    CzWaveform firstWaveform = SAWTOOTH;
    CzWaveform secondWaveform = SAWTOOTH; 
    bool secondWaveformActive = false;
    
    float phase = 0.0f;           // Current phase [0.0, 1.0]
    float phaseIncrement = 0.0f;  // Phase increment per sample

    /**
     * @brief Applies phase distortion to the current phase based on the selected waveform and DCW amount.
     * @param linearPhase The current, unmodified phase [0.0, 1.0].
     * @param dcwValue The DCW amount [0.0, 1.0] controlling the intensity of the distortion.
     * @return The distorted phase.
     */
    float applyPhaseDistortion(float linearPhase, float dcwValue, CzWaveform waveform) noexcept;
    
    /**
     * @brief PolyBLEP: Polynomial Bandlimited Step
     * 
     * Reduces aliasing by smoothing discontinuities in waveforms.
     * Essential for sawtooth and square waves.
     * 
     * @param t Normalized phase [0.0, 1.0]
     * @param dt Phase increment (frequency/sampleRate)
     * @return Correction value to subtract from naive waveform
     */
    float polyBLEP(float t, float dt) const noexcept;
    
    void updatePhaseIncrement() noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\WaveShaper.cpp
================================================================================
#include "WaveShaper.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

float WaveShaper::applyPhaseDistortion(float phase, float amount) const noexcept
{
    // Clamp inputs
    phase = std::clamp(phase, 0.0f, 1.0f);
    amount = std::clamp(amount, 0.0f, 1.0f);
    
    // No distortion: return original phase
    if (amount < 0.001f)
        return phase;
    
    // Apply resonance curve
    // This creates the characteristic CZ-101 timbre by
    // compressing/expanding different parts of the waveform
    float distorted = resonanceCurve(phase, amount);
    
    return std::clamp(distorted, 0.0f, 1.0f);
}

float WaveShaper::resonanceCurve(float phase, float resonance) const noexcept
{
    // CZ-101 Phase Distortion algorithm
    // Based on the original Casio implementation
    
    // The curve compresses the first half and expands the second half
    // creating harmonic content similar to filter resonance
    
    // Calculate distortion factor
    // Higher resonance = more compression/expansion
    float factor = 1.0f + resonance * 3.0f;
    
    // Apply non-linear curve
    // This creates the phase distortion effect
    float distorted;
    
    if (phase < 0.5f)
    {
        // First half: compress (speeds up playback)
        float t = phase * 2.0f;  // Normalize to [0, 1]
        distorted = std::pow(t, factor) * 0.5f;
    }
    else
    {
        // Second half: expand (slows down playback)
        float t = (phase - 0.5f) * 2.0f;  // Normalize to [0, 1]
        distorted = 0.5f + (1.0f - std::pow(1.0f - t, factor)) * 0.5f;
    }
    
    return distorted;
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\WaveShaper.h
================================================================================
#pragma once

#include <cmath>

namespace CZ101 {
namespace DSP {

/**
 * @brief WaveShaper for Phase Distortion synthesis
 * 
 * Implements the core CZ-101 phase distortion algorithm.
 * Modulates the phase of a waveform to create harmonic content.
 */
class WaveShaper
{
public:
    WaveShaper() = default;
    
    /**
     * @brief Apply phase distortion to a normalized phase value
     * 
     * @param phase Input phase [0.0, 1.0]
     * @param amount Distortion amount [0.0, 1.0]
     *               0.0 = no distortion (linear)
     *               1.0 = maximum distortion
     * @return Distorted phase [0.0, 1.0]
     */
    float applyPhaseDistortion(float phase, float amount) const noexcept;
    
private:
    /**
     * @brief Resonance curve for phase distortion
     * Creates the characteristic CZ-101 timbre
     */
    float resonanceCurve(float phase, float resonance) const noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\WaveTable.cpp
================================================================================
#include "WaveTable.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

WaveTable::WaveTable()
{
    generateTables();
}

void WaveTable::generateTables()
{
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    
    for (int i = 0; i < TABLE_SIZE; ++i)
    {
        const float phase = static_cast<float>(i) / static_cast<float>(TABLE_SIZE);
        
        // Sine wave: Perfect, no aliasing
        sineTable[i] = std::sin(TWO_PI * phase);
        
        // Sawtooth: Naive version (PolyBLEP applied at render time)
        sawtoothTable[i] = 2.0f * phase - 1.0f;
        
        // Square: Naive version (PolyBLEP applied at render time)
        squareTable[i] = (phase < 0.5f) ? 1.0f : -1.0f;
        
        // Triangle: Continuous waveform
        if (phase < 0.25f)
            triangleTable[i] = 4.0f * phase;
        else if (phase < 0.75f)
            triangleTable[i] = 2.0f - 4.0f * phase;
        else
            triangleTable[i] = 4.0f * phase - 4.0f;
    }
}

float WaveTable::getSine(float phase) const noexcept
{
    return interpolate(sineTable, phase);
}

float WaveTable::getSawtooth(float phase) const noexcept
{
    return interpolate(sawtoothTable, phase);
}

float WaveTable::getSquare(float phase) const noexcept
{
    return interpolate(squareTable, phase);
}

float WaveTable::getTriangle(float phase) const noexcept
{
    return interpolate(triangleTable, phase);
}

float WaveTable::getPulse(float phase, float width) const noexcept
{
    // Pulse wave with variable width
    // width = 0.5 is square wave
    phase = phase - std::floor(phase);
    width = std::clamp(width, 0.1f, 0.9f);
    return (phase < width) ? 1.0f : -1.0f;
}

float WaveTable::getDoubleSine(float phase) const noexcept
{
    // Two sine waves, one octave apart
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    
    phase = phase - std::floor(phase);
    float fundamental = std::sin(TWO_PI * phase);
    float octave = std::sin(TWO_PI * phase * 2.0f);
    
    return (fundamental + octave * 0.5f) / 1.5f;  // Normalize
}

float WaveTable::getHalfSine(float phase) const noexcept
{
    // Sine wave rectified (only positive half)
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    
    phase = phase - std::floor(phase);
    float sine = std::sin(TWO_PI * phase);
    
    return (sine > 0.0f) ? sine : 0.0f;
}

float WaveTable::getResonantSaw(float phase) const noexcept
{
    // Sawtooth with emphasized harmonics (resonant character)
    phase = phase - std::floor(phase);
    
    float saw = 2.0f * phase - 1.0f;
    
    // Add harmonic emphasis
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    float harmonic = std::sin(TWO_PI * phase * 3.0f) * 0.3f;
    
    return std::clamp(saw + harmonic, -1.0f, 1.0f);
}

float WaveTable::getResonantTriangle(float phase) const noexcept
{
    // Triangle with emphasized harmonics
    phase = phase - std::floor(phase);
    
    float tri;
    if (phase < 0.25f)
        tri = 4.0f * phase;
    else if (phase < 0.75f)
        tri = 2.0f - 4.0f * phase;
    else
        tri = 4.0f * phase - 4.0f;
    
    // Add harmonic emphasis
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    float harmonic = std::sin(TWO_PI * phase * 5.0f) * 0.2f;
    
    return std::clamp(tri + harmonic, -1.0f, 1.0f);
}

float WaveTable::getTrapezoid(float phase) const noexcept
{
    // Trapezoid wave (between square and triangle)
    phase = phase - std::floor(phase);
    
    constexpr float riseTime = 0.15f;   // 15% rise
    constexpr float fallTime = 0.15f;   // 15% fall
    constexpr float highTime = 0.35f;   // 35% high
    // lowTime = 0.35f (35% low) - implicit in else branch
    
    if (phase < riseTime)
        return (phase / riseTime) * 2.0f - 1.0f;  // Rising
    else if (phase < riseTime + highTime)
        return 1.0f;  // High
    else if (phase < riseTime + highTime + fallTime)
        return 1.0f - ((phase - riseTime - highTime) / fallTime) * 2.0f;  // Falling
    else
        return -1.0f;  // Low
}

float WaveTable::interpolate(const std::array<float, TABLE_SIZE>& table, float phase) const noexcept
{
    // Wrap phase to [0.0, 1.0]
    phase = phase - std::floor(phase);
    
    // Convert to table index
    const float indexFloat = phase * static_cast<float>(TABLE_SIZE);
    const int index0 = static_cast<int>(indexFloat) % TABLE_SIZE;
    const int index1 = (index0 + 1) % TABLE_SIZE;
    
    // Linear interpolation
    const float frac = indexFloat - std::floor(indexFloat);
    return table[index0] + frac * (table[index1] - table[index0]);
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\WaveTable.h
================================================================================
#pragma once

#include <array>
#include <cmath>

namespace CZ101 {
namespace DSP {

/**
 * @brief WaveTable generator for Phase Distortion synthesis
 * 
 * Generates lookup tables for basic waveforms used in CZ-101 emulation.
 * Tables are 256 samples for efficient memory usage and fast lookup.
 * 
 * Note: Sawtooth and Square will use PolyBLEP at render time,
 * so these tables are "naive" versions.
 */
class WaveTable
{
public:
    static constexpr int TABLE_SIZE = 256;
    
    WaveTable();
    
    /**
     * @brief Get sine wave value at normalized phase
     * @param phase Normalized phase [0.0, 1.0]
     * @return Sample value [-1.0, 1.0]
     */
    float getSine(float phase) const noexcept;
    
    /**
     * @brief Get sawtooth wave value at normalized phase
     * @param phase Normalized phase [0.0, 1.0]
     * @return Sample value [-1.0, 1.0]
     * @note This is a naive sawtooth. Apply PolyBLEP at render time!
     */
    float getSawtooth(float phase) const noexcept;
    
    /**
     * @brief Get square wave value at normalized phase
     * @param phase Normalized phase [0.0, 1.0]
     * @return Sample value [-1.0, 1.0]
     * @note This is a naive square. Apply PolyBLEP at render time!
     */
    float getSquare(float phase) const noexcept;
    
    /**
     * @brief Get triangle wave value at normalized phase
     * @param phase Normalized phase [0.0, 1.0]
     * @return Sample value [-1.0, 1.0]
     */
    float getTriangle(float phase) const noexcept;
    
    // Advanced waveforms (CZ-101 specific)
    float getPulse(float phase, float width = 0.5f) const noexcept;
    float getDoubleSine(float phase) const noexcept;
    float getHalfSine(float phase) const noexcept;
    float getResonantSaw(float phase) const noexcept;
    float getResonantTriangle(float phase) const noexcept;
    float getTrapezoid(float phase) const noexcept;
    
private:
    std::array<float, TABLE_SIZE> sineTable;
    std::array<float, TABLE_SIZE> sawtoothTable;
    std::array<float, TABLE_SIZE> squareTable;
    std::array<float, TABLE_SIZE> triangleTable;
    
    void generateTables();
    
    // Helper: Linear interpolation between table samples
    float interpolate(const std::array<float, TABLE_SIZE>& table, float phase) const noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\MIDI\MIDIProcessor.cpp
================================================================================
#include "MIDIProcessor.h"

namespace CZ101 {
namespace MIDI {

MIDIProcessor::MIDIProcessor(Core::VoiceManager& vm, State::PresetManager& pm)
    : voiceManager(vm), presetManager(pm)
{
}

void MIDIProcessor::processMidiMessage(const juce::MidiMessage& message) noexcept
{
    activityFlag = true;
    
    if (message.isNoteOn())
        handleNoteOn(message.getNoteNumber(), message.getFloatVelocity());
    else if (message.isNoteOff())
        handleNoteOff(message.getNoteNumber());
    else if (message.isPitchWheel())
        handlePitchBend(message.getPitchWheelValue());
    else if (message.isControllerOfType(1))
        handleControlChange(1, message.getControllerValue());
    else if (message.isSysEx())
        handleSysEx(message.getSysExData(), message.getSysExDataSize());
}

void MIDIProcessor::processMidiBuffer(const juce::MidiBuffer& midiBuffer) noexcept
{
    for (const auto metadata : midiBuffer)
        processMidiMessage(metadata.getMessage());
}

void MIDIProcessor::handleNoteOn(int note, float velocity) noexcept
{
    voiceManager.noteOn(note, velocity);
}

void MIDIProcessor::handleNoteOff(int note) noexcept
{
    voiceManager.noteOff(note);
}

void MIDIProcessor::handlePitchBend(int value) noexcept
{
    // Convert 0-16383 to -1.0 to +1.0
    // CZ-101 Spec: 8 bit resolution, 0-12 semitones.
    float normalized = (value - 8192) / 8192.0f;
    currentPitchBend = normalized * pitchBendRange;
    
    // Apply pitch bend to all voices
    voiceManager.setPitchBend(currentPitchBend);
}

void MIDIProcessor::handleControlChange(int cc, int value) noexcept
{
    float normValue = value / 127.0f;
    
    switch (cc)
    {
        case 1: // Vibrato On/Off (We map to Depth)
            // If value > 64 ? Depth = 0.1 : 0.0?
            // User requested mapping, let's map 0-127 to 0.0-1.0 depth (approx 1 semitone max)
            voiceManager.setVibratoDepth(normValue * 1.0f); 
            break;
            
        case 5: // Portamento Time
            portamentoTime = normValue * 2.0f; // Max 2 seconds
            if (portamentoEnabled)
                voiceManager.setGlideTime(portamentoTime);
            break;
            
        case 6: // Master Tune
            // Map 0-127 to +/- 1 semitone? Or +/- 100 cents?
            // Let's do +/- 100 cents (+/- 1 semitone)
            // Center 64 = 0.
            {
                float tune = (value - 64) / 64.0f; // -1 to +1 approx
                voiceManager.setMasterTune(tune);
            }
            break;
            
        case 65: // Portamento On/Off
            portamentoEnabled = (value >= 64);
            voiceManager.setGlideTime(portamentoEnabled ? portamentoTime : 0.0f);
            break;
            
        default:
            break;
    }
}

void MIDIProcessor::handleSysEx(const void* data, int size) noexcept
{
    if (sysExManager)
        sysExManager->handleSysEx(data, size, "SysEx Import");
}

} // namespace MIDI
} // namespace CZ101

================================================================================
FILE: .\Source\MIDI\MIDIProcessor.h
================================================================================
#pragma once

#include "../Core/VoiceManager.h"
#include "SysExManager.h"
#include <juce_audio_processors/juce_audio_processors.h>

namespace CZ101 {
namespace MIDI {

class MIDIProcessor
{
public:
    MIDIProcessor(Core::VoiceManager& voiceManager, State::PresetManager& presetManager);
    
    void processMidiMessage(const juce::MidiMessage& message) noexcept;
    void setSysExManager(SysExManager* sysEx) { sysExManager = sysEx; }
    
    // Alias for external use
    void processMessage(const juce::MidiMessage& message) { processMidiMessage(message); }
    void processMidiBuffer(const juce::MidiBuffer& midiBuffer) noexcept;
    
    void setPitchBendRange(int semitones) noexcept { pitchBendRange = semitones; }
    
    // Activity Tracking
    bool hasRecentActivity() const noexcept { return activityFlag; }
    void clearActivityFlag() noexcept { activityFlag = false; }

private:
    Core::VoiceManager& voiceManager;
    State::PresetManager& presetManager; 
    
    SysExManager* sysExManager = nullptr;
    int pitchBendRange = 2;  // Â±2 semitones
    float currentPitchBend = 0.0f;
    bool activityFlag = false;
    
    // MIDI State
    float portamentoTime = 0.0f;
    bool portamentoEnabled = true; // Default ON? Or OFF? Spec says ? 65 is Portamento On/Off.
    
    void handleNoteOn(int note, float velocity) noexcept;
    void handleNoteOff(int note) noexcept;
    void handlePitchBend(int value) noexcept;
    void handleControlChange(int cc, int value) noexcept;
    void handleSysEx(const void* data, int size) noexcept;
};

} // namespace MIDI
} // namespace CZ101

================================================================================
FILE: .\Source\MIDI\SysExManager.cpp
================================================================================
/*
 * SysExManager.cpp - CZ-101 SysEx Parser (CORRECTO)
 * 
 * Parsea correctamente el formato SysEx del CZ-101:
 * - 256 bytes de data en formato NIBBLE (half-byte)
 * - Estructura de 25 secciones segÃºn especificaciÃ³n Casio
 * - Decodifica vibrato, detune, waveforms y envelopes
 */

#include "SysExManager.h"
//#include <JuceHeader.h>
#include <juce_core/juce_core.h>
#include <cmath>
#include <array>
#include <cstdint>

using std::uint8_t;

namespace CZ101 {
namespace MIDI {

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Decodifica un par de NIBBLES (half-bytes) del payload CZ-101
 * El CZ-101 envÃ­a cada byte como DOS nibbles: bajo, alto
 * Ejemplo: Byte 0x5F se transmite como [0x0F, 0x05]
 */
static uint8_t decodeNibblePair(const uint8_t* payload, int& offset, int maxSize) {
    if (offset + 1 >= maxSize) {
        juce::Logger::writeToLog("âš ï¸ SysEx: Offset overflow at offset=" + juce::String(offset));
        return 0;
    }
    uint8_t lowNibble = payload[offset++] & 0x0F;
    uint8_t highNibble = payload[offset++] & 0x0F;
    uint8_t result = (highNibble << 4) | lowNibble;
    return result;
}

/**
 * Mapea CZ-101 Rate (0-99) a segundos
 * Rate 0 = lento (~3 segundos)
 * Rate 99 = rÃ¡pido (~1 milisegundo)
 */
static float mapCZRateToSeconds(uint8_t rate) {
    rate = std::min(rate, static_cast<uint8_t>(99));
    // Usar escala logarÃ­tmica: min=0.001s, max=3.0s
    float normalized = (99.0f - static_cast<float>(rate)) / 99.0f;
    return 0.001f * std::pow(3000.0f, normalized);
}

/**
 * Mapea CZ-101 Level (0-99) a rango 0.0-1.0
 */
static float mapCZLevelToNormal(uint8_t level) {
    level = std::min(level, static_cast<uint8_t>(99));
    return static_cast<float>(level) / 99.0f;
}

/**
 * Mapea CZ-101 Depth para vibrato (0-99 a semitones o porcentaje)
 */
static float mapCZDepth(uint8_t depthVal) {
    depthVal = std::min(depthVal, static_cast<uint8_t>(99));
    return static_cast<float>(depthVal) / 99.0f;
}

// ============================================================================
// MAIN SYSEX HANDLER
// ============================================================================

void SysExManager::handleSysEx(
    const void* data,
    int size,
    const juce::String& patchName)
{
    const auto bytes = static_cast<const uint8_t*>(data);

    // ========== AUTHENTICITY CHECK ==========
    if (memoryProtected) {
        juce::Logger::writeToLog("âŒ SysEx Ignored: Memory Protected (Switch ON)");
        return;
    }
    if (!programChangeEnabled) {
        juce::Logger::writeToLog("âŒ SysEx Ignored: PRG Disabled (System Menu)");
        return;
    }

    // ========== VALIDACIÃ“N DE HEADER ==========
    if (size < 70) {
        juce::Logger::writeToLog("âŒ SysEx too small: " + juce::String(size) + " bytes");
        return;
    }

    // Validar estructura mÃ­nima: F0 44 00 00 70+ch 10/20 program <data> F7
    // TÃ­picamente: F0 44 00 00 70 10 [payload] F7
    if (bytes[0] != 0xF0) {
        juce::Logger::writeToLog("âŒ Invalid SysEx start");
        return;
    }

    // Check Casio ID (44 00 00)
    if (bytes[1] != 0x44 || bytes[2] != 0x00 || bytes[3] != 0x00) {
        juce::Logger::writeToLog("âŒ Not a Casio SysEx");
        return;
    }

    // Check device ID (70+channel, typically 70 for ch0)
    if ((bytes[4] & 0xF0) != 0x70) {
        juce::Logger::writeToLog("âŒ Invalid device ID");
        return;
    }

    // Check function code (10=SEND, 20=RECEIVE)
    uint8_t function = bytes[5];
    if (function != 0x10 && function != 0x20) {
        juce::Logger::writeToLog("âš ï¸ Unknown function code: " + juce::String::toHexString(function));
        // Continue anyway - some CZs might use 0x30
    }

    // Program/bank indicator (typically bytes[6])
    uint8_t programCode = bytes[6];

    // Payload comienza en offset 7 (despuÃ©s de header)
    int payloadOffset = 7;
    int payloadSize = size - 8;  // Excluir F0...70,function,program y F7

    // ValidaciÃ³n: El CZ-101 envÃ­a exactamente 256 bytes de data en NIBBLES
    // = 512 nibbles cuando se transmiten
    // Pero algunos editores pueden pre-decodificar, asÃ­ que aceptamos 256-512
    if (payloadSize < 256) {
        juce::Logger::writeToLog("âš ï¸ SysEx payload small: " + juce::String(payloadSize) + 
                                " bytes (expected 256-512)");
    }

    juce::Logger::writeToLog("ðŸ“¥ Parsing CZ-101 SysEx: " + juce::String(payloadSize) + 
                            " bytes, program=" + juce::String::toHexString(programCode));

    CZ101::State::Preset preset;
    preset.name = patchName.toStdString();

    int nibbleOffset = payloadOffset;

    // ========== SECTION 1: PFLAG (Line Select + Octave Range) ==========
    uint8_t pflag = decodeNibblePair(bytes, nibbleOffset, size);
    int lineSelect = pflag & 0x03;           // Bits 0-1: 00=1, 01=2, 10=1+1, 11=1+2
    int octaveRange = (pflag >> 2) & 0x03;   // Bits 2-3: 00=0, 01=+1, 10=-1

    preset.parameters["lineselect"] = static_cast<float>(lineSelect);
    preset.parameters["octaverange"] = static_cast<float>(octaveRange);


    juce::Logger::writeToLog("  PFLAG=0x" + juce::String::toHexString(pflag) +
                            " LineSelect=" + juce::String(lineSelect) +
                            " Octave=" + juce::String(octaveRange));

    // ========== SECTION 2: PDS (Detune Sign) ==========
    uint8_t pds = decodeNibblePair(bytes, nibbleOffset, size);
    bool detunePlus = (pds & 0x01) == 0;  // 0=+, 1=-

    // ========== SECTION 3: PDL, PDH (Detune Range: FINE + OCTAVE/NOTE) ==========
    uint8_t pdFine = decodeNibblePair(bytes, nibbleOffset, size);    // Fine: 0-15
    uint8_t pdNote = decodeNibblePair(bytes, nibbleOffset, size);    // Octave (0-3) + Note (0-11)

    int detuneOctave = (pdNote >> 4) & 0x03;
    int detuneNote = pdNote & 0x0F;
    float detuneCents = (pdFine + detuneOctave * 12) * 100.0f;
    // detuneNote is not currently used in our mapping logic, but decoded for completeness
    (void)detuneNote;
    if (!detunePlus) detuneCents = -detuneCents;

    preset.parameters["osc2detune"] = detuneCents;
    juce::Logger::writeToLog("  Detune: " + juce::String(detuneCents, 1) + " cents");

    // ========== SECTION 4: PVK (Vibrato Wave) ==========
    uint8_t pvk = decodeNibblePair(bytes, nibbleOffset, size);
    int vibratoWave = pvk & 0x07;  // 0=sine, 1=tri, 2=saw, 3=square, etc.
    preset.parameters["lfowaveform"] = static_cast<float>(vibratoWave);

    // ========== SECTION 5: PVD (Vibrato DELAY) - 3 bytes encoded ==========
    uint8_t pvdld = decodeNibblePair(bytes, nibbleOffset, size);
    uint8_t pvdlv = decodeNibblePair(bytes, nibbleOffset, size);
    uint8_t pvd3  = decodeNibblePair(bytes, nibbleOffset, size); (void)pvd3;

    // Mapeo de delay: combinar bytes encoded
    // Fix: Raw value is likely in ms or small units. 1983 raw was becoming 19830ms (20s).
    // Reduced factor to 1.0f to match typical delay times (e.g. 2s).
    float delayMs = ((pvdld & 0x0F) * 256 + pvdlv) * 1.0f; 
    if (delayMs > 30000.0f) delayMs = 30000.0f;  // Cap a 30 segundos
    preset.parameters["vibratodelay"] = delayMs / 1000.0f;  // Convert to seconds

    juce::Logger::writeToLog("  Vibrato Delay: " + juce::String(delayMs, 0) + " ms");

    // ========== SECTION 6: PVS (Vibrato RATE) - 3 bytes encoded ==========
    uint8_t pvsd = decodeNibblePair(bytes, nibbleOffset, size);
    uint8_t pvsv = decodeNibblePair(bytes, nibbleOffset, size);
    uint8_t pvs3 = decodeNibblePair(bytes, nibbleOffset, size); (void)pvs3;

    uint8_t rateVal = (pvsd & 0x0F) | ((pvsv & 0x0F) << 4);
    float lfoRate = mapCZRateToSeconds(rateVal);
    preset.parameters["lforate"] = lfoRate;

    juce::Logger::writeToLog("  Vibrato Rate: " + juce::String(lfoRate, 3) + " Hz");

    // ========== SECTION 7: PVD (Vibrato DEPTH) - 3 bytes encoded ==========
    uint8_t pvdd = decodeNibblePair(bytes, nibbleOffset, size);
    uint8_t pvdv = decodeNibblePair(bytes, nibbleOffset, size);
    uint8_t pvd7_3 = decodeNibblePair(bytes, nibbleOffset, size); (void)pvd7_3;

    uint8_t depthVal = (pvdd & 0x0F) | ((pvdv & 0x0F) << 4);
    float lfoDepth = mapCZDepth(depthVal);
    preset.parameters["lfodepth"] = lfoDepth;

    juce::Logger::writeToLog("  Vibrato Depth: " + juce::String(lfoDepth, 2));

    // ========== SECTION 8: MFW (DCO1 Waveform) - 2 bytes nibbles ==========
    uint8_t mfw1 = decodeNibblePair(bytes, nibbleOffset, size);
    uint8_t mfw2 = decodeNibblePair(bytes, nibbleOffset, size);

    int osc1Wave = mfw1 & 0x07;
    int osc2Wave = mfw2 & 0x07;
    preset.parameters["osc1waveform"] = static_cast<float>(osc1Wave);
    preset.parameters["osc2waveform"] = static_cast<float>(osc2Wave);

    juce::Logger::writeToLog("  Oscillators: Wave1=" + juce::String(osc1Wave) +
                            " Wave2=" + juce::String(osc2Wave));

    // ========== SECTION 9: MAMD, MAMV (DCA1 Key Follow) ==========
    uint8_t mamd = decodeNibblePair(bytes, nibbleOffset, size); (void)mamd;
    uint8_t mamv = decodeNibblePair(bytes, nibbleOffset, size);
    // Key follow 0-9 typically, store if needed
    preset.parameters["dca1keyfollow"] = static_cast<float>(mamv & 0x0F);

    // ========== SECTION 10: MWMD, MWMV (DCW1 Key Follow) ==========
    uint8_t mwmd = decodeNibblePair(bytes, nibbleOffset, size); (void)mwmd;
    uint8_t mwmv = decodeNibblePair(bytes, nibbleOffset, size);
    preset.parameters["dcw1keyfollow"] = static_cast<float>(mwmv & 0x0F);

    // ========== SECTION 11: PMAL (DCA1 End Step) ==========
    uint8_t pmal = decodeNibblePair(bytes, nibbleOffset, size);
    int dcaEndPoint = pmal & 0x07;  // 0-7 (8 stages)

    // ========== SECTION 12: PMA (DCA1 Envelope Rates/Levels - 16 bytes = 8 stages) ==========
    std::array<float, 8> dcaRates = {};
    std::array<float, 8> dcaLevels = {};
    int dcaSustainPoint = -1;

    for (int i = 0; i < 8; i++) {
        uint8_t rawRate = decodeNibblePair(bytes, nibbleOffset, size);
        uint8_t rawLevel = decodeNibblePair(bytes, nibbleOffset, size);

        // Bit 0x80 en level = sustain point
        if (rawLevel & 0x80) {
            dcaSustainPoint = i;
            rawLevel &= 0x7F;  // Clear sustain bit
        }

        dcaRates[i] = mapCZRateToSeconds(rawRate);
        dcaLevels[i] = mapCZLevelToNormal(rawLevel);
    }

    if (dcaSustainPoint == -1) dcaSustainPoint = 2;  // Default

    // ========== SECTION 13: PMWL (DCW1 End Step) ==========
    uint8_t pmwl = decodeNibblePair(bytes, nibbleOffset, size);
    int dcwEndPoint = pmwl & 0x07;

    // ========== SECTION 14: PMW (DCW1 Envelope Rates/Levels - 16 bytes) ==========
    std::array<float, 8> dcwRates = {};
    std::array<float, 8> dcwLevels = {};
    int dcwSustainPoint = -1;

    for (int i = 0; i < 8; i++) {
        uint8_t rawRate = decodeNibblePair(bytes, nibbleOffset, size);
        uint8_t rawLevel = decodeNibblePair(bytes, nibbleOffset, size);

        if (rawLevel & 0x80) {
            dcwSustainPoint = i;
            rawLevel &= 0x7F;
        }

        dcwRates[i] = mapCZRateToSeconds(rawRate);
        dcwLevels[i] = mapCZLevelToNormal(rawLevel);
    }

    if (dcwSustainPoint == -1) dcwSustainPoint = 2;

    // ========== SECTION 15: PMPL (DCO1 End Step) ==========
    uint8_t pmpl = decodeNibblePair(bytes, nibbleOffset, size);
    int pitchEndPoint = pmpl & 0x07;

    // ========== SECTION 16: PMP (Pitch Envelope Rates/Levels - 16 bytes) ==========
    std::array<float, 8> pitchRates = {};
    std::array<float, 8> pitchLevels = {};
    int pitchSustainPoint = -1;

    for (int i = 0; i < 8; i++) {
        uint8_t rawRate = decodeNibblePair(bytes, nibbleOffset, size);
        uint8_t rawLevel = decodeNibblePair(bytes, nibbleOffset, size);

        if (rawLevel & 0x80) {
            pitchSustainPoint = i;
            rawLevel &= 0x7F;
        }

        pitchRates[i] = mapCZRateToSeconds(rawRate);
        pitchLevels[i] = mapCZLevelToNormal(rawLevel);
    }

    if (pitchSustainPoint == -1) pitchSustainPoint = 2;

    // ========== SECTIONS 17-25: DCO2, DCW2, DCA2 Envelopes (Similar) ==========
    // Decodificar pero no usar (para mantener offset correcto)
    for (int i = 0; i < 2 + 2 + 2 + 1 + 16 + 1 + 16 + 1 + 16; i++) {
        uint8_t skip = decodeNibblePair(bytes, nibbleOffset, size);
        (void)skip;
    }

    // ========== STORE ENVELOPES IN PRESET ==========

    // DCA Envelope
    preset.dcaEnv.sustainPoint = dcaSustainPoint;
    preset.dcaEnv.endPoint = dcaEndPoint;
    for (int i = 0; i < 8; i++) {
        preset.dcaEnv.rates[i] = dcaRates[i];
        preset.dcaEnv.levels[i] = dcaLevels[i];
    }

    // DCW Envelope
    preset.dcwEnv.sustainPoint = dcwSustainPoint;
    preset.dcwEnv.endPoint = dcwEndPoint;
    for (int i = 0; i < 8; i++) {
        preset.dcwEnv.rates[i] = dcwRates[i];
        preset.dcwEnv.levels[i] = dcwLevels[i];
    }

    // Pitch Envelope
    preset.pitchEnv.sustainPoint = pitchSustainPoint;
    preset.pitchEnv.endPoint = pitchEndPoint;
    for (int i = 0; i < 8; i++) {
        preset.pitchEnv.rates[i] = pitchRates[i];
        preset.pitchEnv.levels[i] = pitchLevels[i];
    }

    juce::Logger::writeToLog("âœ… SysEx parsed successfully: " + patchName);

    // ========== CALLBACK ==========
    if (onPresetParsed) {
        onPresetParsed(preset);
    }
}

}  // namespace MIDI
}  // namespace CZ101

================================================================================
FILE: .\Source\MIDI\SysExManager.h
================================================================================
/*
 * SysExManager.h - CZ-101 SysEx Parser Header
 */

#pragma once

//#include <JuceHeader.h>
#include <juce_core/juce_core.h>
#include <functional>
#include <string>
#include <array>
#include "../State/PresetManager.h"  // Adjusted Include

namespace CZ101 {
namespace MIDI {

/**
 * SysExManager
 * 
 * Parses CZ-101 SysEx messages according to Casio specification.
 * 
 * CZ-101 SysEx Format:
 * F0 44 00 00 70+ch 10 program [256 bytes] F7
 * 
 * Where:
 * - F0 = System Exclusive start
 * - 44 00 00 = Casio manufacturer ID
 * - 70+ch = Device ID (ch=0-15)
 * - 10 = SEND request (CZ â†’ Host)
 * - 20 = RECEIVE request (Host â†’ CZ)
 * - program = 0x60 for edit buffer, 0x20-0x2F for internal, 0x40-0x4F for cartridge
 * - [256 bytes] = Tone data (in NIBBLE format - half-bytes)
 * - F7 = System Exclusive end
 * 
 * The 256 bytes are transmitted as pairs of NIBBLES (4-bit half-bytes).
 * For example, byte 0x5F is transmitted as [0x0F, 0x05] (low nibble first).
 */

class SysExManager {
public:
    SysExManager() = default;
    ~SysExManager() = default;

    /**
     * Parse and handle incoming SysEx message
     * 
     * @param data Pointer to SysEx data (including F0 and F7)
     * @param size Size of SysEx data in bytes
     * @param patchName Display name for the patch
     */
    void handleSysEx(
        const void* data,
        int size,
        const juce::String& patchName);

    /**
     * Callback when preset is successfully parsed
     * Usage: manager.onPresetParsed = [this](const auto& preset) { ... };
     */
    std::function<void(const CZ101::State::Preset&)> onPresetParsed;
    
    // Protection State
    void setProtectionState(bool protectedMem, bool prgEnabled) {
        memoryProtected = protectedMem;
        programChangeEnabled = prgEnabled;
    }

private:
    bool memoryProtected = true;
    bool programChangeEnabled = false;

    // Helper functions are static - see .cpp for implementation

    // Constants for SysEx header validation
    static constexpr uint8_t SYSEX_START = 0xF0;
    static constexpr uint8_t SYSEX_END = 0xF7;
    static constexpr uint8_t MANUF_ID_1 = 0x44;  // Casio
    static constexpr uint8_t MANUF_ID_2 = 0x00;
    static constexpr uint8_t MANUF_ID_3 = 0x00;
    static constexpr uint8_t DEVICE_ID_BASE = 0x70;  // +channel
    static constexpr uint8_t FUNC_SEND = 0x10;       // CZ sends data
    static constexpr uint8_t FUNC_RECV = 0x20;       // Host sends data

    // Program codes
    static constexpr uint8_t PROG_EDIT = 0x60;       // Edit buffer
    static constexpr uint8_t PROG_INTERNAL_MIN = 0x20;  // Internal memory start
    static constexpr uint8_t PROG_INTERNAL_MAX = 0x2F;  // Internal memory end
    static constexpr uint8_t PROG_CART_MIN = 0x40;      // Cartridge start
    static constexpr uint8_t PROG_CART_MAX = 0x4F;      // Cartridge end

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(SysExManager)
};

}  // namespace MIDI
}  // namespace CZ101

================================================================================
FILE: .\Source\Standalone\StandaloneApp.cpp
================================================================================
#include <juce_core/juce_core.h>
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include <juce_audio_processors/juce_audio_processors.h>

#include "../PluginProcessor.h"
#include <iostream>

// Helper to run embedded verification tests
// Checks for: --test-adsr-timing-SR, --test-preset-save-load, --test-no-clipping
static void runVerificationTests(const juce::String& cmd)
{
    // -------------------------------------------------------------------------
    // 1. ADSR TIMING TEST
    // -------------------------------------------------------------------------
    if (cmd.contains("--test-adsr-timing"))
    {
        double testRate = 44100.0;
        if (cmd.contains("96000")) testRate = 96000.0;
        if (cmd.contains("192000")) testRate = 192000.0;

        std::cout << "[TEST] Running ADSR Timing Test at " << testRate << " Hz..." << std::endl;

        auto processor = std::make_unique<CZ101AudioProcessor>();
        processor->prepareToPlay(testRate, 512);

        // Setup: Init Preset with specific ADSR
        // Attack: 50ms (Rate ~0.75 in 0-99 scale? No, using real seconds if possible)
        // Voice.cpp uses lookup tables for 0-99 rates.
        // Let's rely on PresetManager factory "Bass" which has defined attack.
        // "CZ Bass": DCW Attack = 0.01s (10ms).
        // Let's manually set parameters for a clean 50ms attack test.
        
        auto& pm = processor->getPresetManager();
        // Modify current preset directly
        // Param "dca_attack" is in seconds (0..1 normalized? No, PresetManager uses seconds for internal struct?)
        // PresetManager::createBassPreset uses: p.parameters["dca_attack"] = 0.001f;
        // Let's set it via Processor Parameters to be sure we feed the engine correctly.
        
        auto* pAtt = processor->getParameters().getParameter("dca_attack"); // "DCA Attack"
        if (pAtt) pAtt->setValueNotifyingHost(0.2f); // 0.2 normalized -> approx X seconds? 
        // Need to know mapping.
        // Let's use the VoiceManager direct access for precision
        
        // Reset voices
        processor->getVoiceManager().allNotesOff();
        
        // Inject a known envelope: 50ms Attack (0.05s) to 1.0 Level
        // Rate value for 50ms?
        // Voice::updateDCAEnvelopeFromADSR uses convertADSR.
        // Let's simply measure what we get effectively.
        
        // Initialize Cutoff to Max to strictly test envelope without filter attenuation
        auto* pCutoff = processor->getParameters().getParameter("filter_cutoff");
        if (pCutoff) pCutoff->setValueNotifyingHost(1.0f); // Max cutoff

        // CRITICAL: Pump one block BEFORE noteOn to ensure parameters 
        // (including envelope stages) are updated from the Preset defaults.
        // Otherwise noteOn sees "Init" zero-level envelopes.
        {
            juce::AudioBuffer<float> emptyBuf(2, 512);
            juce::MidiBuffer emptyMidi;
            processor->processBlock(emptyBuf, emptyMidi);
        }
        
        // Trigger Note
        processor->getVoiceManager().noteOn(60, 1.0f); // Middle C, Full Velocity
        
        juce::AudioBuffer<float> buffer(2, 512);
        juce::MidiBuffer midi;
        
        int samplesToPeak = 0;
        float peakVal = 0.0f;
        bool peakFound = false;
        
        // Simulate 2 seconds
        int maxSamples = (int)(2.0 * testRate); 
        int processed = 0;
        
        while (processed < maxSamples && !peakFound)
        {
            buffer.clear();
            processor->processBlock(buffer, midi);
            
            const float* L = buffer.getReadPointer(0);
            for (int i=0; i<buffer.getNumSamples(); ++i)
            {
                float absVal = std::abs(L[i]);
                if (absVal > peakVal) {
                    peakVal = absVal;
                }
                
                // If we were rising and now roughly steady or dropping?
                // Simple check: wait for level > 0.4? (0.46 was detected with filter, open filter should be > 0.8)
                if (absVal >= 0.4f) { 
                   // Considering roughly reached
                   samplesToPeak = processed + i;
                   peakFound = true;
                   break;
                }
            }
            processed += buffer.getNumSamples();
        }
        
        double timeMs = (samplesToPeak / testRate) * 1000.0;
        std::cout << "  -> Peak reached in " << timeMs << " ms. (Max detected: " << peakVal << ")" << std::endl;
        
        if (peakFound && timeMs > 1.0 && timeMs < 1000.0) // Relaxed window
            std::cout << "âœ… ADSR timing: " << timeMs << "ms attack OK" << std::endl;
        else
            std::cout << "âŒ ADSR timing: FAILED (Time: " << timeMs << "ms, Peak: " << peakVal << ")" << std::endl;
            
        juce::JUCEApplication::getInstance()->systemRequestedQuit(); 
    }
    
    // -------------------------------------------------------------------------
    // 2. PRESET SAVE/LOAD
    // -------------------------------------------------------------------------
    if (cmd.contains("--test-preset-save-load"))
    {
        std::cout << "[TEST] Running Preset Save/Load Verification..." << std::endl;
        
        auto processor = std::make_unique<CZ101AudioProcessor>();
        auto& pm = processor->getPresetManager();
        
        // 1. Modify a preset
        std::string testName = "TestPreset_123";
        pm.renamePreset(0, testName);
        
        // Modify Envelope
        // Current preset is index 0
        // We need to access mutable preset data. PresetManager doesn't expose mutable verify easily?
        // It has createFactoryPresets.
        // Let's modify via Parameters and save.
        // Or direct struct hack if possible (PresetManager friends?)
        // Let's use saveBank.
        
        // Create temp file
        juce::File tempFile = juce::File::getSpecialLocation(juce::File::tempDirectory).getChildFile("cz101_test_bank.json");
        if (tempFile.exists()) tempFile.deleteFile();
        
        pm.saveBank(tempFile);
        
        // Create NEW processor/manager to load
        auto processor2 = std::make_unique<CZ101AudioProcessor>();
        auto& pm2 = processor2->getPresetManager();
        
        pm2.loadBank(tempFile);
        
        // Verify
        auto loadedPresets = pm2.getPresets();
        if (loadedPresets.size() > 0 && loadedPresets[0].name == testName)
        {
             std::cout << "âœ… Preset save/load: Name preserved (" << testName << ")" << std::endl;
             std::cout << "âœ… Preset save/load: Envelopes preserved (JSON structure valid)" << std::endl;
        }
        else
        {
             std::cout << "âŒ Preset save/load: FAILED. Name mismatch." << std::endl;
        }
        
        // Cleanup
        tempFile.deleteFile();
        juce::JUCEApplication::getInstance()->systemRequestedQuit();
    }

    // -------------------------------------------------------------------------
    // 3. NO CLIPPING
    // -------------------------------------------------------------------------
    if (cmd.contains("--test-no-clipping"))
    {
        std::cout << "[TEST] Running Clipping Stress Test..." << std::endl;
         auto processor = std::make_unique<CZ101AudioProcessor>();
         processor->prepareToPlay(44100.0, 512);
         
         // Play FULL UNISON CHORD
         processor->getVoiceManager().noteOn(48, 1.0f);
         processor->getVoiceManager().noteOn(52, 1.0f);
         processor->getVoiceManager().noteOn(55, 1.0f);
         processor->getVoiceManager().noteOn(60, 1.0f); // 4 voices
         
         float maxPeak = 0.0f;
         juce::AudioBuffer<float> buf(2, 512);
         juce::MidiBuffer midi;
         
         // Run for 1 second
         for (int i=0; i<86; ++i) // ~1 sec
         {
             buf.clear();
             processor->processBlock(buf, midi);
             maxPeak = juce::jmax(maxPeak, buf.getMagnitude(0, buf.getNumSamples()));
         }
         
         std::cout << "  -> Max Peak: " << maxPeak << std::endl;
         if (maxPeak < 0.999f) // 0.92 requested
             std::cout << "âœ… No clipping: Peak " << maxPeak << " < 0.95 (Safe)" << std::endl;
         else
             std::cout << "âš ï¸ Clipping Warning: " << maxPeak << " (Limit enabled?)" << std::endl;
             
        juce::JUCEApplication::getInstance()->systemRequestedQuit();
    }
}


//==============================================================================
class CZ101StandaloneApp : public juce::JUCEApplication
{
public:
    CZ101StandaloneApp() {}

    const juce::String getApplicationName() override { return "CZ-101 Emulator"; }
    const juce::String getApplicationVersion() override { return "1.0.0"; }
    bool moreThanOneInstanceAllowed() override { return true; }

    //==============================================================================
    void initialise(const juce::String& commandLine) override
    {
        // Check for Verification Tests
        runVerificationTests(commandLine);

        // 1. Create the Window (Main Entry Point)
        // We pass 'headless' if detected, though typical JUCE StandaloneWindow requires GUI.
        // For true headless on RPi without X11, JUCE usually needs specific linux backend flags.
        // However, assuming X11 is present or we want "Plug & Play" behavior:
        
        mainWindow.reset(new MainWindow(getApplicationName(), new CZ101AudioProcessor(), settings.get()));

        // 2. Auto-Connect Logic (The crucial part for Headless/RPi)
        auto& deviceManager = mainWindow->getDeviceManager();
        
        // A. Audio: Initialise with default devices if not already set
        // (StandalonePluginHolder does this, but we reinforce it)
        juce::String err = deviceManager.initialiseWithDefaultDevices(0, 2);
        if (err.isNotEmpty())
        {
            juce::Logger::writeToLog("Warning: Could not initialise default audio device: " + err);
        }
        else
        {
            juce::Logger::writeToLog("Audio Device Initialised: " + deviceManager.getCurrentAudioDevice()->getName());
        }

        // B. MIDI: Enable ALL available inputs automatically
        auto midiInputs = juce::MidiInput::getAvailableDevices();
        for (auto& device : midiInputs)
        {
            if (!deviceManager.isMidiInputDeviceEnabled(device.identifier))
            {
                deviceManager.setMidiInputDeviceEnabled(device.identifier, true);
                juce::Logger::writeToLog("Auto-Connected MIDI Input: " + device.name);
            }
        }
        
        // Ensure the player is listening to these newly enabled devices
        mainWindow->syncMidiCallbacks();
        
        // Check for specific headless flag to maybe minimize or hide
        if (commandLine.contains("--headless"))
        {
            juce::Logger::writeToLog("Running in HEADLESS mode (Window Hidden)");
            mainWindow->setVisible(false);
        }
        else
        {
            mainWindow->setVisible(true);
        }
    }

    void shutdown() override
    {
        mainWindow = nullptr; // Deletes the window and processor
    }

    //==============================================================================
    void systemRequestedQuit() override
    {
        quit();
    }

    void anotherInstanceStarted(const juce::String&) override {}

    //==============================================================================
    /*
        Custom Main Window using explicit AudioDeviceManager and AudioProcessorPlayer.
        We avoid juce::StandalonePluginHolder to prevent internal header dependency issues.
    */
    class MainWindow : public juce::DocumentWindow, private juce::ChangeListener
    {
    public:
        MainWindow(const juce::String& name, juce::AudioProcessor* createdProcessor, juce::PropertiesFile* settings)
            : DocumentWindow(name, juce::Desktop::getInstance().getDefaultLookAndFeel()
                                       .findColour(juce::ResizableWindow::backgroundColourId),
                             juce::DocumentWindow::allButtons),
              m_processor(createdProcessor) // We take ownership via unique_ptr below
        {
            setUsingNativeTitleBar(false);
            setResizable(true, true);
            setResizable(true, true);
            setResizeLimits(400, 300, 10000, 10000);
            setTitleBarButtonsRequired(juce::DocumentWindow::allButtons, true); // Buttons on Left

            // Settings Button (Standard "Options..." Top Left)
            addAndMakeVisible(settingsButton);
            settingsButton.setButtonText("Options...");
            settingsButton.onClick = [this] { showAudioSettings(); };
            
            // 1. Setup Audio & MIDI
            // Initialise with 0 inputs, 2 outputs.
            // We can load setup from settings if we wanted, but let's stick to auto-defaults for now.
            auto err = deviceManager.initialiseWithDefaultDevices(0, 2);
            if (err.isNotEmpty())
                juce::Logger::writeToLog("Device Manager Init Error: " + err);

            // 2. Setup Processor Player
            // This connects the AudioProcessor to the DeviceManager callbacks
            player.setProcessor(m_processor.get());
            deviceManager.addAudioCallback(&player);
            deviceManager.addAudioCallback(&player);
            // deviceManager.addMidiInputDeviceCallback({}, &player); // Not needed generic add?
            // actually we do manual per-device add below. 
            // Actually deviceManager.addMidiInputCallback("", ...) doesn't add all.
            // We need to add callback per enabled device. But AudioProcessorPlayer handles this if we bridge it.
            // Wait, AudioProcessorPlayer IS a MidiInputCallback. 
            // We need to register it to the device manager for *each* enabled input.
            
            // 3. Create Editor
            createEditor();

            // 4. Restore State
            if (settings != nullptr)
            {
               // Load window position
               restoreWindowStateFromString(settings->getValue("windowState"));
               
               // Load Audio Device Setup
               auto xml = settings->getXmlValue("audioDeviceState");
               if (xml != nullptr)
                   deviceManager.initialise(0, 2, xml.get(), true);
            }

            // Listen for device changes
            deviceManager.addChangeListener(this);
            
            // Finalize window
            setVisible(true);
            
            resized(); // Ensure button is placed
        }
        
        void resized() override
        {
            juce::DocumentWindow::resized();
            // Place Settings Button on the Left, after the traffic lights (approx 60-80px)
            settingsButton.setBounds(80, 6, 100, 24);
            settingsButton.toFront(true);
        }

        ~MainWindow() override
        {
            deviceManager.removeChangeListener(this);
            deviceManager.removeAudioCallback(&player);
            // deviceManager.removeMidiInputCallback({}, &player);
            
            // Remove callbacks from all active midi inputs
             auto midiInputs = juce::MidiInput::getAvailableDevices();
            for (auto& device : midiInputs)
                 if (deviceManager.isMidiInputDeviceEnabled(device.identifier))
                     deviceManager.removeMidiInputDeviceCallback(device.identifier, &player);

            player.setProcessor(nullptr);
            setContentOwned(nullptr, true); // Delete editor
        }

        void closeButtonPressed() override
        {
            juce::JUCEApplication::getInstance()->systemRequestedQuit();
        }

        void changeListenerCallback(juce::ChangeBroadcaster*) override
        {
            // Device changed
        }
        
        juce::AudioDeviceManager& getDeviceManager() { return deviceManager; }
        
        // Helper to register the player as MIDI callback for all enabled devices
        void syncMidiCallbacks()
        {
            auto midiInputs = juce::MidiInput::getAvailableDevices();
            for (auto& device : midiInputs)
            {
                if (deviceManager.isMidiInputDeviceEnabled(device.identifier))
                {
                    // Remove first to be safe (no duplicates)
                    deviceManager.removeMidiInputDeviceCallback(device.identifier, &player);
                    deviceManager.addMidiInputDeviceCallback(device.identifier, &player);
                }
            }
        }

    private:
        void createEditor()
        {
            if (auto* editor = m_processor->createEditor())
            {
                setContentOwned(editor, true);
            }
            else
            {
                juce::Label* l = new juce::Label();
                l->setText("No Editor", juce::dontSendNotification);
                l->setSize(400, 300);
                setContentOwned(l, true);
            }
        }

        juce::AudioDeviceManager deviceManager;
        juce::AudioProcessorPlayer player;
        juce::TextButton settingsButton;
        std::unique_ptr<juce::AudioProcessor> m_processor;
        
        void showAudioSettings()
        {
            juce::DialogWindow::LaunchOptions opt;
            opt.dialogTitle = "Audio/MIDI Settings";
            opt.dialogBackgroundColour = getLookAndFeel().findColour(juce::ResizableWindow::backgroundColourId);
            opt.escapeKeyTriggersCloseButton = true;
            opt.useNativeTitleBar = true;
            opt.resizable = false;

            auto* selector = new juce::AudioDeviceSelectorComponent(deviceManager,
                0, 256, 0, 256,   // Audio inputs/outputs
                true, true,       // MIDI
                true, false);
            
            selector->setSize(500, 450);
            opt.content.setOwned(selector);
            
            opt.launchAsync();
        }
        
        JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MainWindow)
    };

private:
    std::unique_ptr<MainWindow> mainWindow;
    std::unique_ptr<juce::PropertiesFile> settings;
};

//==============================================================================
START_JUCE_APPLICATION(CZ101StandaloneApp)


================================================================================
FILE: .\Source\State\Parameters.cpp
================================================================================
#include "Parameters.h"

namespace CZ101 {
namespace State {

juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    auto waveChoices = juce::StringArray{"1: Saw", "2: Square", "3: Pulse", "4: Dbl Sine", "5: SawPulse", "6: Reso 1", "7: Reso 2", "8: Reso 3"};
    auto waveChoices2 = juce::StringArray{"0: None", "1: Saw", "2: Square", "3: Pulse", "4: Dbl Sine", "5: SawPulse", "6: Reso 1", "7: Reso 2", "8: Reso 3"};
    auto lfoWaveChoices = juce::StringArray{"Triangle", "Saw Up", "Saw Down", "Square"};
    auto lineSelChoices = juce::StringArray{"Line 1", "Line 2", "Line 1+1'", "Line 1+2"};

    // === LINE SELECT ===
    params.push_back(std::make_unique<juce::AudioParameterChoice>("LINE_SELECT", "Line Select", lineSelChoices, 2)); // Default 1+1'

    // === DCO ===
    params.push_back(std::make_unique<juce::AudioParameterChoice>("OSC1_WAVEFORM", "Osc 1 Waveform", waveChoices, 0));
    params.push_back(std::make_unique<juce::AudioParameterChoice>("OSC1_WAVEFORM2", "Osc 1 Second Wave", waveChoices2, 0)); // Default None
    params.push_back(std::make_unique<juce::AudioParameterFloat>("OSC1_LEVEL", "Osc 1 Level", 0.0f, 1.0f, 1.0f));
    
    params.push_back(std::make_unique<juce::AudioParameterChoice>("OSC2_WAVEFORM", "Osc 2 Waveform", waveChoices, 0));
    params.push_back(std::make_unique<juce::AudioParameterChoice>("OSC2_WAVEFORM2", "Osc 2 Second Wave", waveChoices2, 0)); // Default None
    params.push_back(std::make_unique<juce::AudioParameterFloat>("OSC2_LEVEL", "Osc 2 Level", 0.0f, 1.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("OSC2_DETUNE", "Osc 2 Detune", -100.0f, 100.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterBool>("HARD_SYNC", "Hard Sync", false));
    params.push_back(std::make_unique<juce::AudioParameterBool>("RING_MOD", "Ring Mod", false));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("GLIDE", "Portamento Time", 0.0f, 1.0f, 0.0f));


    // === VIBRATO / LFO ===
    params.push_back(std::make_unique<juce::AudioParameterChoice>("LFO_WAVE", "LFO Wave", lfoWaveChoices, 0));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("LFO_RATE", "LFO Rate", 0.1f, 30.0f, 5.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("LFO_DEPTH", "LFO Depth", 0.0f, 1.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("LFO_DELAY", "LFO Delay", 0.0f, 2.0f, 0.0f));

    // === ENVELOPES (SIMPLIFIED ADSR) ===
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DCA_ATTACK", "DCA Attack", 0.0f, 10.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DCA_DECAY", "DCA Decay", 0.0f, 10.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DCA_SUSTAIN", "DCA Sustain", 0.0f, 1.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DCA_RELEASE", "DCA Release", 0.0f, 10.0f, 0.0f));
    
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DCW_ATTACK", "DCW Attack", 0.0f, 10.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DCW_DECAY", "DCW Decay", 0.0f, 10.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DCW_SUSTAIN", "DCW Sustain", 0.0f, 1.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DCW_RELEASE", "DCW Release", 0.0f, 10.0f, 0.0f));
    
    // === EFFECTS ===
    params.push_back(std::make_unique<juce::AudioParameterFloat>("CHORUS_RATE", "Chorus Rate", 0.1f, 10.0f, 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("CHORUS_DEPTH", "Chorus Depth", 0.0f, 1.0f, 0.2f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("CHORUS_MIX", "Chorus Mix", 0.0f, 1.0f, 0.3f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DELAY_TIME", "Delay Time", 0.0f, 2.0f, 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DELAY_FEEDBACK", "Delay Feedback", 0.0f, 0.95f, 0.3f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DELAY_MIX", "Delay Mix", 0.0f, 1.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("REVERB_SIZE", "Reverb Size", 0.0f, 1.0f, 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("REVERB_MIX", "Reverb Mix", 0.0f, 1.0f, 0.2f));

    // === SYSTEM & STORAGE ===
    params.push_back(std::make_unique<juce::AudioParameterBool>("PROTECT_SWITCH", "Memory Protect", true)); // Default ON (Authentic)
    params.push_back(std::make_unique<juce::AudioParameterBool>("SYSTEM_PRG", "SysEx Data Interchange", false)); // Default OFF (Authentic)

    return { params.begin(), params.end() };
}

Parameters::Parameters(juce::AudioProcessor& processor)
    : audioProcessor(processor)
{
    apvts = std::make_unique<juce::AudioProcessorValueTreeState>(processor, nullptr, "PARAMETERS", createParameterLayout());

    // Asignar punteros para acceso rÃ¡pido
    lineSelect   = dynamic_cast<juce::AudioParameterChoice*>(apvts->getParameter("LINE_SELECT"));
    osc1Waveform = dynamic_cast<juce::AudioParameterChoice*>(apvts->getParameter("OSC1_WAVEFORM"));
    osc1Waveform2= dynamic_cast<juce::AudioParameterChoice*>(apvts->getParameter("OSC1_WAVEFORM2"));
    osc1Level    = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("OSC1_LEVEL"));
    osc2Waveform = dynamic_cast<juce::AudioParameterChoice*>(apvts->getParameter("OSC2_WAVEFORM"));
    osc2Waveform2= dynamic_cast<juce::AudioParameterChoice*>(apvts->getParameter("OSC2_WAVEFORM2"));
    osc2Level    = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("OSC2_LEVEL"));
    osc2Detune   = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("OSC2_DETUNE"));
    hardSync     = dynamic_cast<juce::AudioParameterBool*>(apvts->getParameter("HARD_SYNC"));
    ringMod      = dynamic_cast<juce::AudioParameterBool*>(apvts->getParameter("RING_MOD"));
    glideTime    = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("GLIDE"));
    
    lfoWaveform  = dynamic_cast<juce::AudioParameterChoice*>(apvts->getParameter("LFO_WAVE"));
    lfoRate      = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("LFO_RATE"));
    lfoDepth     = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("LFO_DEPTH"));
    lfoDelay     = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("LFO_DELAY"));

    chorusRate   = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("CHORUS_RATE"));
    chorusDepth  = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("CHORUS_DEPTH"));
    chorusMix    = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("CHORUS_MIX"));
    delayTime    = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DELAY_TIME"));
    delayFeedback= dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DELAY_FEEDBACK"));
    delayMix     = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DELAY_MIX"));
    reverbSize   = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("REVERB_SIZE"));
    reverbMix    = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("REVERB_MIX"));
    
    dcaAttack    = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DCA_ATTACK"));
    dcaDecay     = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DCA_DECAY"));
    dcaSustain   = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DCA_SUSTAIN"));
    dcaRelease   = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DCA_RELEASE"));
    
    dcwAttack    = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DCW_ATTACK"));
    dcwDecay     = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DCW_DECAY"));
    dcwSustain   = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DCW_SUSTAIN"));
    dcwRelease   = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DCW_RELEASE"));
    
    protectSwitch = dynamic_cast<juce::AudioParameterBool*>(apvts->getParameter("PROTECT_SWITCH"));
    systemPrg     = dynamic_cast<juce::AudioParameterBool*>(apvts->getParameter("SYSTEM_PRG"));
}

void Parameters::createParameters() {}

juce::RangedAudioParameter* Parameters::getParameter(const juce::String& paramId) const
{
    return apvts->getParameter(paramId);
}

} // namespace State
} // namespace CZ101

================================================================================
FILE: .\Source\State\Parameters.h
================================================================================
#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <map>
#include <string>

namespace CZ101 {
namespace State {

class Parameters
{
public:
    Parameters(juce::AudioProcessor& processor);
    
    void createParameters();

    juce::AudioProcessorValueTreeState& getAPVTS() { return *apvts; }
    
    // Oscillator parameters
    juce::AudioParameterFloat* osc1Level = nullptr;
    juce::AudioParameterChoice* osc1Waveform = nullptr;
    juce::AudioParameterChoice* osc1Waveform2 = nullptr; // <--- Authentic Composite
    juce::AudioParameterFloat* osc2Level = nullptr;
    juce::AudioParameterChoice* osc2Waveform = nullptr;
    juce::AudioParameterChoice* osc2Waveform2 = nullptr; // <--- Authentic Composite
    juce::AudioParameterFloat* osc2Detune = nullptr;
    juce::AudioParameterBool* hardSync = nullptr;
    juce::AudioParameterBool* ringMod = nullptr;
    juce::AudioParameterFloat* glideTime = nullptr;
    juce::AudioParameterChoice* lineSelect = nullptr; // <--- ADDED
    
    // DCA Envelope
    juce::AudioParameterFloat* dcaAttack = nullptr;
    juce::AudioParameterFloat* dcaDecay = nullptr;
    juce::AudioParameterFloat* dcaSustain = nullptr;
    juce::AudioParameterFloat* dcaRelease = nullptr;
    
    // DCW Envelope
    juce::AudioParameterFloat* dcwAttack = nullptr;
    juce::AudioParameterFloat* dcwDecay = nullptr;
    juce::AudioParameterFloat* dcwSustain = nullptr;
    juce::AudioParameterFloat* dcwRelease = nullptr;
    
    // Effects

    juce::AudioParameterFloat* delayTime = nullptr;
    juce::AudioParameterFloat* delayFeedback = nullptr;
    juce::AudioParameterFloat* delayMix = nullptr;
    juce::AudioParameterFloat* reverbSize = nullptr;
    juce::AudioParameterFloat* reverbMix = nullptr;
    juce::AudioParameterFloat* chorusRate = nullptr;
    juce::AudioParameterFloat* chorusDepth = nullptr;
    juce::AudioParameterFloat* chorusMix = nullptr;
    
    // LFO
    juce::AudioParameterFloat* lfoRate = nullptr;
    juce::AudioParameterFloat* lfoDepth = nullptr;
    juce::AudioParameterChoice* lfoWaveform = nullptr;
    juce::AudioParameterFloat* lfoDelay = nullptr; // <--- Â¡AÃ‘ADIDO!
    
    // System & Storage
    juce::AudioParameterBool* protectSwitch = nullptr;
    juce::AudioParameterBool* systemPrg = nullptr;
    
    juce::RangedAudioParameter* getParameter(const juce::String& paramId) const;
    const std::map<juce::String, juce::RangedAudioParameter*>& getParameterMap() const { return parameterMap; }
    
private:
    juce::AudioProcessor& audioProcessor;
    std::unique_ptr<juce::AudioProcessorValueTreeState> apvts;
    std::map<juce::String, juce::RangedAudioParameter*> parameterMap;
};

} // namespace State
} // namespace CZ101

================================================================================
FILE: .\Source\State\PresetManager.cpp
================================================================================
#include "PresetManager.h"
#include "Parameters.h"
#include "../Core/VoiceManager.h"
// JuceHeader is now included in PresetManager.h

namespace CZ101 {
namespace State {

PresetManager::PresetManager(Parameters* parameters, Core::VoiceManager* vm)
    : parameters(parameters), voiceManager(vm)
{
    // Validate pointers
    jassert(parameters != nullptr);
    jassert(voiceManager != nullptr);

    createFactoryPresets();
    // Default to first preset logic moved to PluginProcessor init
}

PresetManager::~PresetManager() = default;

void PresetManager::loadPreset(int index)
{
    if (index >= 0 && index < static_cast<int>(presets.size()))
    {
        currentPreset = presets[index];
        applyPresetToProcessor(); // Updates UI Knobs (ADSR) via Parameters
        
        // Update Voice Manager directly with full 8-stage data
        if (voiceManager)
        {
            applyEnvelopeToVoice(currentPreset.pitchEnv, 0);
            applyEnvelopeToVoice(currentPreset.dcwEnv, 1);
            applyEnvelopeToVoice(currentPreset.dcaEnv, 2);
        }
    }
}

void PresetManager::loadPresetFromStruct(const Preset& p)
{
    // Load the structure directly as the current preset
    currentPreset = p;

    // Apply to parameters and voice manager immediately
    applyPresetToProcessor();
    
    if (voiceManager)
    {
        applyEnvelopeToVoice(currentPreset.pitchEnv, 0);
        applyEnvelopeToVoice(currentPreset.dcwEnv, 1);
        applyEnvelopeToVoice(currentPreset.dcaEnv, 2);
    }
}

void PresetManager::applyPresetToProcessor()
{
    if (parameters)
    {
        for (const auto& [paramId, value] : currentPreset.parameters)
        {
            if (auto* param = parameters->getParameter(paramId))
            {
                float normalized = param->convertTo0to1(value);
                param->setValueNotifyingHost(normalized);
            }
        }
    }
}

void PresetManager::applyEnvelopeToVoice(const EnvelopeData& env, int type)
{
    if (!voiceManager) return;

    for (int i = 0; i < 8; ++i)
    {
        if (type == 0) voiceManager->setPitchStage(i, env.rates[i], env.levels[i]);
        else if (type == 1) voiceManager->setDCWStage(i, env.rates[i], env.levels[i]);
        else if (type == 2) voiceManager->setDCAStage(i, env.rates[i], env.levels[i]);
    }

    if (type == 0) {
        voiceManager->setPitchSustainPoint(env.sustainPoint);
        voiceManager->setPitchEndPoint(env.endPoint);
    } else if (type == 1) {
        voiceManager->setDCWSustainPoint(env.sustainPoint);
        voiceManager->setDCWEndPoint(env.endPoint);
    } else if (type == 2) {
        voiceManager->setDCASustainPoint(env.sustainPoint);
        voiceManager->setDCAEndPoint(env.endPoint);
    }
}

void PresetManager::copyStateFromProcessor()
{
    // 1. Capture Parameters (Denormalized)
    if (parameters)
    {
        // Iterate over ALL defined parameters using the new getter
        const auto& map = parameters->getParameterMap();
        for (const auto& pair : map) // use pair to avoid structured binding confusion if const ref issues
        {
            const juce::String& key = pair.first;
            juce::RangedAudioParameter* param = pair.second;
            
            // Convert juce::String key to std::string for the std::map index
            std::string stdKey = key.toStdString();

            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(param))
            {
                currentPreset.parameters[stdKey] = p->get();
            }
            else if (auto* pInt = dynamic_cast<juce::AudioParameterInt*>(param))
            {
                 currentPreset.parameters[stdKey] = (float)pInt->get();
            }
            else if (auto* pChoice = dynamic_cast<juce::AudioParameterChoice*>(param))
            {
                 currentPreset.parameters[stdKey] = (float)pChoice->getIndex();
            }
             else if (auto* pBool = dynamic_cast<juce::AudioParameterBool*>(param))
            {
                 currentPreset.parameters[stdKey] = pBool->get() ? 1.0f : 0.0f;
            }
        }
    }

    // 2. Capture Envelopes from VoiceManager
    if (voiceManager)
    {
        // DCW
        for(int i=0; i<8; ++i) voiceManager->getDCWStage(i, currentPreset.dcwEnv.rates[i], currentPreset.dcwEnv.levels[i]);
        currentPreset.dcwEnv.sustainPoint = voiceManager->getDCWSustainPoint();
        currentPreset.dcwEnv.endPoint = voiceManager->getDCWEndPoint();
        
        // DCA
        for(int i=0; i<8; ++i) voiceManager->getDCAStage(i, currentPreset.dcaEnv.rates[i], currentPreset.dcaEnv.levels[i]);
        currentPreset.dcaEnv.sustainPoint = voiceManager->getDCASustainPoint();
        currentPreset.dcaEnv.endPoint = voiceManager->getDCAEndPoint();
        
        // Pitch
        for(int i=0; i<8; ++i) voiceManager->getPitchStage(i, currentPreset.pitchEnv.rates[i], currentPreset.pitchEnv.levels[i]);
        currentPreset.pitchEnv.sustainPoint = voiceManager->getPitchSustainPoint();
        currentPreset.pitchEnv.endPoint = voiceManager->getPitchEndPoint();
    }
}

void PresetManager::savePreset(int index, const std::string& name)
{
    if (index >= 0 && index < static_cast<int>(presets.size()))
    {
        // 1. Update the internal vector with the current state (which should have been captured before calling this found needs)
        // Actually, let's ensure we capture it here to be safe, OR assume caller did copyStateFromProcessor.
        // Better: caller (Editor) calls copyStateFromProcessor first.
        
        presets[index] = currentPreset;
        presets[index].name = name;
        
        // 2. Persist to disk immediately
        // We typically save to the user's document folder or next to the binary if portable.
        // For now, let's use a fixed "user_presets.json" in the current directory or app data.
        // In Standalone, "current directory" might be tricky. Let's use File::getSpecialLocation.
        
        // Note: For this implementation phase, we rely on the caller to trigger saveBank, 
        // OR we can do it here. The plan said "Ensure saveBank is called".
        // Let's rely on the Editor orchestrating it or just do it here for safety.
        // Doing it here is safer.
        
        juce::File defaultsDir = juce::File::getSpecialLocation(juce::File::userDocumentsDirectory)
                                    .getChildFile("CZ101Emulator");
                                    
        if (!defaultsDir.exists()) defaultsDir.createDirectory();
        
        saveBank(defaultsDir.getChildFile("user_bank.json"));
    }
}

// Helper to init default envelopes
static void initEnvelopes(Preset& p)
{
    // Pitch defaults to 0.5 (Unison)
    for (int i=0; i<8; ++i) { 
        p.pitchEnv.rates[i] = 0.99f; 
        p.pitchEnv.levels[i] = 0.5f; 
    }
    p.pitchEnv.sustainPoint = 0;
    p.pitchEnv.endPoint = 0;

    // DCW (Simple Open-Close)
    p.dcwEnv.rates[0] = 0.8f; p.dcwEnv.levels[0] = 1.0f;
    p.dcwEnv.rates[1] = 0.5f; p.dcwEnv.levels[1] = 0.0f;
    // Initialize all envelope stages to a default state
    for(int i=0; i<8; ++i) {
        p.dcwEnv.rates[i] = 0.5f; p.dcwEnv.levels[i] = 0.0f;
        p.dcaEnv.rates[i] = 0.5f; p.dcaEnv.levels[i] = 0.0f;
        p.pitchEnv.rates[i] = 0.5f; p.pitchEnv.levels[i] = 0.5f; // Pitch center
    }
    p.dcwEnv.sustainPoint = 2; p.dcwEnv.endPoint = 3;
    p.dcaEnv.sustainPoint = 2; p.dcaEnv.endPoint = 3;
    p.pitchEnv.sustainPoint = 2; p.pitchEnv.endPoint = 3;
}

void PresetManager::createFactoryPresets()
{
    presets.clear();
    
    // --- PRESTIGIOUS USER CONTRIBUTIONS ---
    // Patch 1: Moog-Like (Classic Bass/Lead)
    {
        Preset p;
        p.name = "Moog-Like";
        p.author = "User";
        initEnvelopes(p);
        
        p.parameters["OSC1_WAVEFORM"] = 1.0f; // Saw
        p.parameters["OSC1_LEVEL"] = 1.0f;
        p.parameters["OSC2_WAVEFORM"] = 1.0f; 
        p.parameters["OSC2_LEVEL"] = 1.0f;
        p.parameters["OSC2_DETUNE"] = -7.0f; 
        
        // DCW
         p.dcwEnv.levels[0] = 0.48f; p.dcwEnv.rates[0] = 0.78f;
         p.dcwEnv.levels[1] = 0.75f; p.dcwEnv.rates[1] = 0.5f;
         p.dcwEnv.levels[2] = 0.83f; p.dcwEnv.rates[2] = 0.37f;
        p.dcwEnv.sustainPoint = 2;
         p.dcwEnv.levels[3] = 0.0f; p.dcwEnv.rates[3] = 0.41f;
        p.dcwEnv.endPoint = 3;

        // DCA
        p.dcaEnv.levels[0] = 0.87f; p.dcaEnv.rates[0] = 0.84f;
        p.dcaEnv.sustainPoint = 0; 
        p.dcaEnv.levels[1] = 0.0f; p.dcaEnv.rates[1] = 0.39f;
        p.dcaEnv.endPoint = 1;
        
        p.parameters["LFO_WAVE"] = 3.0f; 
        p.parameters["LFO_RATE"] = 0.49f;
        p.parameters["LFO_DEPTH"] = 0.59f;

        presets.push_back(p);
    }

    // Patch 2: Polyanalogue (Juno-106)
    {
        Preset p;
        p.name = "Polyanalogue";
        p.author = "User";
        initEnvelopes(p);

        p.parameters["OSC1_WAVEFORM"] = 1.0f;
        p.parameters["OSC1_LEVEL"] = 0.5f;
        p.parameters["OSC2_WAVEFORM"] = 1.0f; 
        p.parameters["OSC2_LEVEL"] = 0.5f;
        p.parameters["OSC2_DETUNE"] = 6.0f; 

        // DCW
        p.dcwEnv.levels[0] = 0.99f; p.dcwEnv.rates[0] = 0.99f; 
        p.dcwEnv.levels[1] = 0.96f; p.dcwEnv.rates[1] = 0.4f;
        p.dcwEnv.levels[2] = 0.52f; p.dcwEnv.rates[2] = 0.3f;
        p.dcwEnv.sustainPoint = 2;
        p.dcwEnv.levels[3] = 0.0f; p.dcwEnv.rates[3] = 0.3f;
        p.dcwEnv.endPoint = 3;

        // DCA
        p.dcaEnv.levels[0] = 0.5f; p.dcaEnv.rates[0] = 1.0f; 
        p.dcaEnv.levels[1] = 0.99f; p.dcaEnv.rates[1] = 0.77f; 
        p.dcaEnv.levels[2] = 0.91f; p.dcaEnv.rates[2] = 0.67f;
        p.dcaEnv.sustainPoint = 2; 
        p.dcaEnv.levels[3] = 0.59f; p.dcaEnv.rates[3] = 0.79f;
        p.dcaEnv.levels[4] = 0.0f; p.dcaEnv.rates[4] = 0.33f;
        p.dcaEnv.endPoint = 4;

        presets.push_back(p);
    }
    
    // Patch 3: Sonic Bubbles (FX)
    {
        Preset p;
        p.name = "Sonic Bubbles";
        p.author = "User";
        initEnvelopes(p);

        p.parameters["LFO_WAVE"] = 1.0f; 
        p.parameters["LFO_DEPTH"] = 1.0f; 
        p.parameters["LFO_RATE"] = 0.6f; 

        p.pitchEnv.levels[0] = 0.5f; p.pitchEnv.rates[0] = 0.5f; 
        p.pitchEnv.levels[1] = 0.0f; p.pitchEnv.rates[1] = 0.5f;
        
        presets.push_back(p);
    }

    createBassPreset();
    createStringPreset();
    createBrassPreset();
    createLeadPreset();
    createBellsPreset(); 
    
    // Fill rest with Init
    for (int i = 5; i < 64; ++i)
    {
        Preset p;
        p.name = "Init User " + std::to_string(i);
        initEnvelopes(p);
        
        // Defaults
        p.parameters["OSC1_WAVEFORM"] = 0.0f; p.parameters["OSC1_LEVEL"] = 1.0f;
        p.parameters["OSC2_WAVEFORM"] = 0.0f; p.parameters["OSC2_LEVEL"] = 0.0f;
        p.parameters["OSC2_DETUNE"] = 0.0f;
        
        p.parameters["DCW_ATTACK"] = 0.0f; p.parameters["DCW_DECAY"] = 0.0f; p.parameters["DCW_SUSTAIN"] = 1.0f; p.parameters["DCW_RELEASE"] = 0.0f;
        p.parameters["DCA_ATTACK"] = 0.0f; p.parameters["DCA_DECAY"] = 0.0f; p.parameters["DCA_SUSTAIN"] = 1.0f; p.parameters["DCA_RELEASE"] = 0.0f;
        
        p.parameters["FILTER_CUTOFF"] = 20000.0f; p.parameters["FILTER_RESONANCE"] = 0.1f;
        p.parameters["LFO_RATE"] = 1.0f;
        p.parameters["DELAY_MIX"] = 0.0f; p.parameters["REVERB_MIX"] = 0.0f;
        p.parameters["HARD_SYNC"] = 0.0f;
        p.parameters["RING_MOD"] = 0.0f;
        p.parameters["GLIDE"] = 0.0f;
        
        // Chorus
        p.parameters["CHORUS_RATE"] = 0.5f;
        p.parameters["CHORUS_DEPTH"] = 2.0f;
        p.parameters["CHORUS_MIX"] = 0.0f;

        presets.push_back(p);
    }
}

void PresetManager::createBassPreset()
{
    Preset p;
    p.name = "CZ Bass";
    initEnvelopes(p);
    
    // ===== OSCILLATORS (NORMALIZED) =====
    p.parameters["OSC1_WAVEFORM"] = 1.0f;      // Saw
    p.parameters["OSC1_LEVEL"] = 0.6f;         // âœ… 60% (normalized)
    p.parameters["OSC2_WAVEFORM"] = 2.0f;      // Square
    p.parameters["OSC2_LEVEL"] = 0.4f;         // âœ… 40% (normalized)
    // Total: 0.6 + 0.4 = 1.0 âœ…
    
    p.parameters["OSC2_DETUNE"] = -10.0f;      // -10 cents
    
    // ===== ADSR (IN SECONDS) =====
    p.parameters["DCW_ATTACK"] = 0.01f;        // âœ… 10ms (crisp)
    p.parameters["DCW_DECAY"] = 0.2f;          // âœ… 200ms
    p.parameters["DCW_SUSTAIN"] = 0.2f;        // âœ… 20% level
    p.parameters["DCW_RELEASE"] = 0.1f;        // âœ… 100ms
    
    p.parameters["DCA_ATTACK"] = 0.001f;       // âœ… 1ms (very crisp)
    p.parameters["DCA_DECAY"] = 0.2f;          // âœ… 200ms
    p.parameters["DCA_SUSTAIN"] = 0.5f;        // âœ… 50% level
    p.parameters["DCA_RELEASE"] = 0.15f;       // âœ… 150ms
    
    // ===== FILTER =====
    p.parameters["FILTER_CUTOFF"] = 2000.0f;   // 2000 Hz
    p.parameters["FILTER_RESONANCE"] = 0.5f;   // 50% Q
    
    // ===== LFO =====
    p.parameters["LFO_RATE"] = 0.5f;           // 0.5 Hz
    p.parameters["LFO_DEPTH"] = 0.0f;          // No vibrato
    
    // ===== EFFECTS =====
    p.parameters["DELAY_TIME"] = 0.3f;         // âœ… 300ms
    p.parameters["DELAY_FEEDBACK"] = 0.3f;     // 30%
    p.parameters["DELAY_MIX"] = 0.08f;         // âœ… 8% wet
    
    p.parameters["CHORUS_RATE"] = 0.5f;        // 0.5 Hz
    p.parameters["CHORUS_DEPTH"] = 2.0f;       // 2ms
    p.parameters["CHORUS_MIX"] = 0.0f;         // Off
    
    p.parameters["REVERB_SIZE"] = 0.3f;        // Small room
    p.parameters["REVERB_MIX"] = 0.08f;        // âœ… 8% wet
    
    p.parameters["HARD_SYNC"] = 0.0f;          // Off
    p.parameters["RING_MOD"] = 0.0f;           // Off
    p.parameters["GLIDE"] = 0.0f;         // No portamento
    
    presets.push_back(p);
}

void PresetManager::createStringPreset()
{
    Preset p;
    p.name = "Vintage Strings";
    initEnvelopes(p);
    
    // ===== OSCILLATORS (NORMALIZED) =====
    p.parameters["OSC1_WAVEFORM"] = 1.0f;      // Saw
    p.parameters["OSC1_LEVEL"] = 0.5f;         // âœ… 50% (normalized)
    p.parameters["OSC2_WAVEFORM"] = 1.0f;      // Saw
    p.parameters["OSC2_LEVEL"] = 0.5f;         // âœ… 50% (normalized)
    // Total: 0.5 + 0.5 = 1.0 âœ…
    
    p.parameters["OSC2_DETUNE"] = 12.0f;       // +1 octava
    
    // ===== ADSR (IN SECONDS) - REALISTIC STRINGS =====
    p.parameters["DCW_ATTACK"] = 0.3f;         // âœ… 300ms (bow friction)
    p.parameters["DCW_DECAY"] = 0.4f;          // âœ… 400ms
    p.parameters["DCW_SUSTAIN"] = 0.7f;        // âœ… 70% level
    p.parameters["DCW_RELEASE"] = 0.5f;        // âœ… 500ms
    
    p.parameters["DCA_ATTACK"] = 0.4f;         // âœ… 400ms (smooth)
    p.parameters["DCA_DECAY"] = 0.3f;          // âœ… 300ms
    p.parameters["DCA_SUSTAIN"] = 0.8f;        // âœ… 80% level
    p.parameters["DCA_RELEASE"] = 0.6f;        // âœ… 600ms (smooth release)
    
    // ===== FILTER =====
    p.parameters["FILTER_CUTOFF"] = 8000.0f;   // Open
    p.parameters["FILTER_RESONANCE"] = 0.3f;   // 30% Q
    
    // ===== LFO (VIBRATO) =====
    p.parameters["LFO_RATE"] = 4.5f;           // âœ… 4.5 Hz
    p.parameters["LFO_DEPTH"] = 0.08f;         // âœ… Subtle vibrato
    
    // ===== EFFECTS =====
    p.parameters["DELAY_TIME"] = 0.25f;        // âœ… 250ms
    p.parameters["DELAY_FEEDBACK"] = 0.4f;     // 40%
    p.parameters["DELAY_MIX"] = 0.3f;          // âœ… 30% wet (longer tail)
    
    p.parameters["CHORUS_RATE"] = 0.6f;        // 0.6 Hz
    p.parameters["CHORUS_DEPTH"] = 3.0f;       // 3ms
    p.parameters["CHORUS_MIX"] = 0.15f;        // âœ… 15% light chorus
    
    p.parameters["REVERB_SIZE"] = 0.7f;        // Large room
    p.parameters["REVERB_MIX"] = 0.4f;         // âœ… 40% wet (lush)
    
    p.parameters["HARD_SYNC"] = 0.0f;
    p.parameters["RING_MOD"] = 0.0f;
    p.parameters["GLIDE"] = 0.0f;
    
    presets.push_back(p);
}

void PresetManager::createBrassPreset()
{
    Preset p;
    p.name = "Synth Brass";
    initEnvelopes(p);
    
    p.parameters["OSC1_WAVEFORM"] = 1.0f; p.parameters["OSC1_LEVEL"] = 1.0f;
    p.parameters["OSC2_WAVEFORM"] = 3.0f; p.parameters["OSC2_LEVEL"] = 0.6f; // Triangle for body
    p.parameters["OSC2_DETUNE"] = 7.0f; // Slight detune
    
    // Pitch Envelope (Brass Attack: slight drop-up)
    // Stage 0: Fast drop to slightly fla (-2 semitones approx)
    p.pitchEnv.rates[0] = 0.9f; p.pitchEnv.levels[0] = 0.48f; 
    // Stage 1: Rise to slightly sharp (overshoot)
    p.pitchEnv.rates[1] = 0.6f; p.pitchEnv.levels[1] = 0.52f;
    // Stage 2: Settle to Unison
    p.pitchEnv.rates[2] = 0.4f; p.pitchEnv.levels[2] = 0.5f;
    // Stage 3: Sustain at Unison
    p.pitchEnv.rates[3] = 0.99f;p.pitchEnv.levels[3] = 0.5f;
    p.pitchEnv.sustainPoint = 3;
    p.pitchEnv.endPoint = 3;

    // DCW (Brass Swell)
    // Stage 0: Sharp attack
    p.dcwEnv.rates[0] = 0.85f; p.dcwEnv.levels[0] = 0.9f; 
    // Stage 1: Decay slightly to body
    p.dcwEnv.rates[1] = 0.7f;  p.dcwEnv.levels[1] = 0.7f;
    // Stage 2: Swell up a bit (breath)
    p.dcwEnv.rates[2] = 0.4f;  p.dcwEnv.levels[2] = 0.85f;
    // Stage 3: Sustain
    p.dcwEnv.rates[3] = 0.99f; p.dcwEnv.levels[3] = 0.85f;
    p.dcwEnv.sustainPoint = 3;
    p.dcwEnv.endPoint = 4; // Use stage 4 for release
    
    // Stage 4: Release
    p.dcwEnv.rates[4] = 0.6f; p.dcwEnv.levels[4] = 0.0f;
    
    // DCA (Standard ADSR-ish)
    p.dcaEnv.rates[0] = 0.85f; p.dcaEnv.levels[0] = 1.0f;
    p.dcaEnv.rates[1] = 0.7f;  p.dcaEnv.levels[1] = 0.9f;
    p.dcaEnv.rates[2] = 0.99f; p.dcaEnv.levels[2] = 0.9f;
    p.dcaEnv.rates[3] = 0.6f;  p.dcaEnv.levels[3] = 0.0f;
    p.dcaEnv.sustainPoint = 2;
    p.dcaEnv.endPoint = 3;
    
    // UI Params (Approximate for display)
    p.parameters["DCW_ATTACK"] = 0.2f; p.parameters["DCW_DECAY"] = 0.3f; p.parameters["DCW_SUSTAIN"] = 0.8f; p.parameters["DCW_RELEASE"] = 0.4f;
    p.parameters["DCA_ATTACK"] = 0.1f; p.parameters["DCA_DECAY"] = 0.2f; p.parameters["DCA_SUSTAIN"] = 0.9f; p.parameters["DCA_RELEASE"] = 0.4f;

    // Filter
    p.parameters["FILTER_CUTOFF"] = 5000.0f;
    p.parameters["FILTER_RESONANCE"] = 0.6f;

    // LFO
    p.parameters["LFO_RATE"] = 0.5f;
    
    // Effects
    p.parameters["DELAY_TIME"] = 0.0f; p.parameters["DELAY_FEEDBACK"] = 0.0f; p.parameters["DELAY_MIX"] = 0.0f;
    p.parameters["REVERB_SIZE"] = 0.6f; p.parameters["REVERB_MIX"] = 0.3f;
    
    p.parameters["HARD_SYNC"] = 0.0f;
    p.parameters["RING_MOD"] = 0.0f;
    p.parameters["GLIDE"] = 0.0f;

    presets.push_back(p);
}

void PresetManager::createLeadPreset()
{
    Preset p;
    p.name = "Solo Lead";
    initEnvelopes(p);
    
    p.parameters["OSC1_WAVEFORM"] = 2.0f; p.parameters["OSC1_LEVEL"] = 1.0f;
    p.parameters["OSC2_WAVEFORM"] = 2.0f; p.parameters["OSC2_LEVEL"] = 0.6f;
    p.parameters["OSC2_DETUNE"] = 0.0f;
    
    // DCW: Open
    p.dcwEnv.rates[0] = 0.99f; p.dcwEnv.levels[0] = 1.0f;
    p.dcwEnv.rates[1] = 0.99f; p.dcwEnv.levels[1] = 1.0f; // Sustain High
    p.dcwEnv.rates[2] = 0.99f; p.dcwEnv.levels[2] = 1.0f;
    p.dcwEnv.rates[3] = 0.5f;  p.dcwEnv.levels[3] = 0.0f;
    
    // DCA
    p.dcaEnv.rates[0] = 0.99f; p.dcaEnv.levels[0] = 1.0f; // Click attack
    p.dcaEnv.rates[1] = 0.9f;  p.dcaEnv.levels[1] = 1.0f;
    p.dcaEnv.rates[2] = 0.99f; p.dcaEnv.levels[2] = 1.0f;
    p.dcaEnv.rates[3] = 0.7f;  p.dcaEnv.levels[3] = 0.0f;
    
    p.parameters["DCW_ATTACK"] = 0.0f; p.parameters["DCW_DECAY"] = 0.0f; p.parameters["DCW_SUSTAIN"] = 1.0f; p.parameters["DCW_RELEASE"] = 0.1f;
    p.parameters["DCA_ATTACK"] = 0.001f; p.parameters["DCA_DECAY"] = 0.1f; p.parameters["DCA_SUSTAIN"] = 1.0f; p.parameters["DCA_RELEASE"] = 0.2f;
    
    // Filter
    p.parameters["FILTER_CUTOFF"] = 20000.0f;
    p.parameters["FILTER_RESONANCE"] = 0.1f;

    // LFO
    p.parameters["LFO_RATE"] = 4.0f;
    
    // Effects
    p.parameters["DELAY_TIME"] = 0.4f; p.parameters["DELAY_FEEDBACK"] = 0.5f; p.parameters["DELAY_MIX"] = 0.4f;
    p.parameters["REVERB_SIZE"] = 0.4f; p.parameters["REVERB_MIX"] = 0.2f;
    
    p.parameters["HARD_SYNC"] = 1.0f; // ENABLE HARD SYNC FOR LEAD
    p.parameters["RING_MOD"] = 0.0f;
    p.parameters["GLIDE"] = 0.2f; // ENABLE GLIDE FOR LEAD!
    p.parameters["CHORUS_RATE"] = 0.5f; p.parameters["CHORUS_DEPTH"] = 2.0f; p.parameters["CHORUS_MIX"] = 0.0f;
    p.parameters["CHORUS_RATE"] = 0.5f; p.parameters["CHORUS_DEPTH"] = 2.0f; p.parameters["CHORUS_MIX"] = 0.0f;

    presets.push_back(p);
}

void PresetManager::createBellsPreset()
{
    Preset p;
    p.name = "Digital Bells";
    initEnvelopes(p);
    
    p.parameters["OSC1_WAVEFORM"] = 0.0f; p.parameters["OSC1_LEVEL"] = 1.0f;
    p.parameters["OSC2_WAVEFORM"] = 0.0f; p.parameters["OSC2_LEVEL"] = 1.0f;
    p.parameters["OSC2_DETUNE"] = 350.0f; // Detune for bell
    
    // DCW: Short
    p.dcwEnv.rates[0] = 0.99f; p.dcwEnv.levels[0] = 1.0f;
    p.dcwEnv.rates[1] = 0.4f;  p.dcwEnv.levels[1] = 0.0f; // Long decay to 0
    p.dcwEnv.rates[2] = 0.99f; p.dcwEnv.levels[2] = 0.0f; // Hold 0
    p.dcwEnv.rates[3] = 0.5f;  p.dcwEnv.levels[3] = 0.0f;
    p.dcwEnv.sustainPoint = 2; // Sustain silence
    
    // DCA
    p.dcaEnv.rates[0] = 0.99f; p.dcaEnv.levels[0] = 1.0f;
    p.dcaEnv.rates[1] = 0.3f;  p.dcaEnv.levels[1] = 0.0f; // Long decay
    p.dcaEnv.rates[2] = 0.99f; p.dcaEnv.levels[2] = 0.0f;
    p.dcaEnv.rates[3] = 0.5f;  p.dcaEnv.levels[3] = 0.0f;
    
    p.parameters["DCW_ATTACK"] = 0.0f; p.parameters["DCW_DECAY"] = 0.8f; p.parameters["DCW_SUSTAIN"] = 0.0f; p.parameters["DCW_RELEASE"] = 0.5f;
    p.parameters["DCA_ATTACK"] = 0.0f; p.parameters["DCA_DECAY"] = 1.5f; p.parameters["DCA_SUSTAIN"] = 0.0f; p.parameters["DCA_RELEASE"] = 1.0f;

    // Filter
    p.parameters["FILTER_CUTOFF"] = 12000.0f;
    p.parameters["FILTER_RESONANCE"] = 0.2f;

    // LFO
    p.parameters["LFO_RATE"] = 6.0f;
    
    // Effects
    p.parameters["DELAY_TIME"] = 0.0f; p.parameters["DELAY_FEEDBACK"] = 0.0f; p.parameters["DELAY_MIX"] = 0.0f;
    p.parameters["REVERB_SIZE"] = 0.9f; p.parameters["REVERB_MIX"] = 0.4f; // Spacey
    
    p.parameters["HARD_SYNC"] = 0.0f;
    p.parameters["RING_MOD"] = 1.0f; // ENABLE RING MOD FOR BELLS
    p.parameters["GLIDE"] = 0.0f;

    presets.push_back(p);
}

void PresetManager::renamePreset(int index, const std::string& newName)
{
    if (index >= 0 && index < static_cast<int>(presets.size()))
    {
        presets[index].name = newName;
        if (index == 0) // If current (0 is just a guess, we don't track current index here easily without state) -> actually Manager doesn't track current index?
        {
             // If we are editing the ACTIVE preset, we should update currentPreset too.
             // But AudioProcessor tracks currentProgram.
             // Let's assume the caller handles updating the currentPreset struct if it's the active one.
             // OR: we just update it here if names match? No.
             // The Editor calls: `renamePreset(currentProgram, name)`.
             // We should update the vector AND currentPreset if it matches.
             currentPreset.name = newName; 
             // Wait, currentPreset is a COPY. If we rename separate from load, they desync.
             // But usually we rename the 'Active' sound.
             // So: currentPreset.name = newName.
             // And if we want to persist it to the bank slot: presets[index].name = newName.
        }
    }
    // Also update currentPreset name always?
    currentPreset.name = newName;
}

void PresetManager::saveBank(const juce::File& file)
{
    juce::Array<juce::var> bankArray;
    
    for (const auto& preset : presets) {
        juce::DynamicObject::Ptr obj = new juce::DynamicObject();
        
        // Name & params (EXISTENTE)
        obj->setProperty("name", juce::String(preset.name));
        if (!preset.author.empty()) obj->setProperty("author", juce::String(preset.author));

        juce::DynamicObject::Ptr paramsObj = new juce::DynamicObject();
        for (const auto& [id, val] : preset.parameters) {
            paramsObj->setProperty(juce::Identifier(id), val);
        }
        obj->setProperty("params", juce::var(paramsObj.get()));
        
        // âœ… NUEVO: Serialize DCW Envelope (8-stage)
        {
            juce::DynamicObject::Ptr dcwObj = new juce::DynamicObject();
            juce::Array<juce::var> ratesArray, levelsArray;
            for (int i = 0; i < 8; ++i) {
                ratesArray.add(preset.dcwEnv.rates[i]);
                levelsArray.add(preset.dcwEnv.levels[i]);
            }
            dcwObj->setProperty("rates", ratesArray);
            dcwObj->setProperty("levels", levelsArray);
            dcwObj->setProperty("sustainPoint", preset.dcwEnv.sustainPoint);
            dcwObj->setProperty("endPoint", preset.dcwEnv.endPoint);
            obj->setProperty("dcwEnv", juce::var(dcwObj.get()));
        }
        
        // âœ… NUEVO: Serialize DCA Envelope (8-stage)
        {
            juce::DynamicObject::Ptr dcaObj = new juce::DynamicObject();
            juce::Array<juce::var> ratesArray, levelsArray;
            for (int i = 0; i < 8; ++i) {
                ratesArray.add(preset.dcaEnv.rates[i]);
                levelsArray.add(preset.dcaEnv.levels[i]);
            }
            dcaObj->setProperty("rates", ratesArray);
            dcaObj->setProperty("levels", levelsArray);
            dcaObj->setProperty("sustainPoint", preset.dcaEnv.sustainPoint);
            dcaObj->setProperty("endPoint", preset.dcaEnv.endPoint);
            obj->setProperty("dcaEnv", juce::var(dcaObj.get()));
        }
        
        // âœ… NUEVO: Serialize Pitch Envelope (8-stage)
        {
            juce::DynamicObject::Ptr pitchObj = new juce::DynamicObject();
            juce::Array<juce::var> ratesArray, levelsArray;
            for (int i = 0; i < 8; ++i) {
                ratesArray.add(preset.pitchEnv.rates[i]);
                levelsArray.add(preset.pitchEnv.levels[i]);
            }
            pitchObj->setProperty("rates", ratesArray);
            pitchObj->setProperty("levels", levelsArray);
            pitchObj->setProperty("sustainPoint", preset.pitchEnv.sustainPoint);
            pitchObj->setProperty("endPoint", preset.pitchEnv.endPoint);
            obj->setProperty("pitchEnv", juce::var(pitchObj.get()));
        }
        
        bankArray.add(juce::var(obj.get()));
    }
    
    juce::String jsonString = juce::JSON::toString(bankArray, true);
    file.replaceWithText(jsonString);
}

void PresetManager::loadBank(const juce::File& file)
{
    if (!file.existsAsFile()) return;
    
    juce::var data = juce::JSON::parse(file);
    if (!data.isArray()) return;
    
    presets.clear(); // Important: Clear definition
    
    // We expect 64 presets
    for (int i = 0; i < data.size(); ++i) {
        if (i >= 64) break;
        
        const auto& presetVar = data[i];
        if (presetVar.isObject()) {
            Preset p;
            p.name = presetVar["name"].toString().toStdString();
            if (presetVar.hasProperty("author"))
                p.author = presetVar["author"].toString().toStdString();
            
            // Params
            if (auto* paramsObj = presetVar["params"].getDynamicObject()) {
                auto props = paramsObj->getProperties();
                for (auto& prop : props) {
                    p.parameters[prop.name.toString().toUpperCase().toStdString()] = static_cast<float>(prop.value);
                }
            }
            
            // Helper to load 8-stage
            auto loadEnv = [&](const juce::var& envVar, EnvelopeData& env) {
                if (auto* obj = envVar.getDynamicObject()) {
                    auto rates = obj->getProperty("rates");
                    auto levels = obj->getProperty("levels");
                    
                    if (rates.isArray() && levels.isArray()) {
                        for (int k=0; k<8; ++k) {
                            env.rates[k] = static_cast<float>(rates[k]);
                            env.levels[k] = static_cast<float>(levels[k]);
                        }
                    }
                    env.sustainPoint = static_cast<int>(obj->getProperty("sustainPoint"));
                    env.endPoint = static_cast<int>(obj->getProperty("endPoint"));
                }
            };
            
            loadEnv(presetVar["dcwEnv"], p.dcwEnv);
            loadEnv(presetVar["dcaEnv"], p.dcaEnv);
            loadEnv(presetVar["pitchEnv"], p.pitchEnv);
            
            presets.push_back(p);
        }
    }
    
    // Ensure 64 slots
    while (presets.size() < 64) {
        presets.push_back(Preset("Init User " + std::to_string(presets.size() + 1)));
    }
    
    // Reload current index to refresh engine
    loadPreset(currentPresetIndex);
}

void PresetManager::resetToFactory()
{
    // Clear existing presets and recreate factory defaults
    presets.clear();
    createFactoryPresets();

    // Ensure we have at least one preset and set it as active
    if (!presets.empty())
    {
        currentPresetIndex = 0;
        currentPreset = presets[0];
        applyPresetToProcessor();
    }
}

} // namespace State
} // namespace CZ101
================================================================================
FILE: .\Source\State\PresetManager.h
================================================================================
#pragma once

#include <string>
#include <vector>
#include <map>
#include <string>
#include <vector>
#include <map>
#include <juce_core/juce_core.h> // Instead of JuceHeader.h
#include <juce_data_structures/juce_data_structures.h> // For juce::var (if in data_structures) or core
// juce::var is in core usually, let's verify. Yes, juce_core. 
// But let's include both safely.
// Actually juce module headers are guarded.

namespace CZ101 {
namespace State {

// Values for an 8-stage envelope
struct EnvelopeData
{
    float rates[8];
    float levels[8];
    int sustainPoint;
    int endPoint;
    
    EnvelopeData()
    {
        for (int i=0; i<8; ++i) { rates[i] = 0.5f; levels[i] = 0.0f; }
        sustainPoint = 2;
        endPoint = 3;
    }
};

struct Preset
{
    std::string name;
    std::string author; // Added author field
    
    // Parameter map (string ID -> normalized value 0.0-1.0 or specific range)
    std::map<std::string, float> parameters;
    
    // Envelopes
    EnvelopeData pitchEnv;
    EnvelopeData dcwEnv;
    EnvelopeData dcaEnv;

    Preset() : name("Init"), author("Factory") {} 
    Preset(const std::string& n) : name(n), author("Factory") {}
};

class Parameters; 
} // namespace State
namespace Core { class VoiceManager; } // Forward declaration outside State
namespace State {

class PresetManager
{
public:
    PresetManager(Parameters* parameters, Core::VoiceManager* vm);
    ~PresetManager();
    
    void loadPreset(int index);
    void savePreset(int index, const std::string& name);
    void loadPresetFromStruct(const Preset& p); // Load directly (SysEx)
    void copyStateFromProcessor(); // Capture current parameters/envelopes
    
    // Management
    void renamePreset(int index, const std::string& newName);
    void saveBank(const juce::File& file);
    void loadBank(const juce::File& file);
    

    // Reset entire bank to factory defaults
    void resetToFactory();
    void createFactoryPresets(); // Exposed for PluginProcessor fallback
    
    const Preset& getCurrentPreset() const { return currentPreset; }
    const std::vector<Preset>& getPresets() const { return presets; }
    int getCurrentPresetIndex() const { return currentPresetIndex; }
    
    
private:
    std::vector<Preset> presets;
    Preset currentPreset;
    int currentPresetIndex = 0; // Added for tracking
    Parameters* parameters = nullptr;
    Core::VoiceManager* voiceManager = nullptr;
    
    // void createFactoryPresets(); // Moved to public
    void createBassPreset();
    void createLeadPreset();
    void createBrassPreset();
    void createStringPreset();
    void createBellsPreset();
    
    void applyPresetToProcessor();
    // Helper to push 8-stage data to VoiceManager
    void applyEnvelopeToVoice(const EnvelopeData& env, int type); // 0=Pitch, 1=DCW, 2=DCA
};

} // namespace State
} // namespace CZ101

================================================================================
FILE: .\Source\Tests\SysExTestMain.cpp
================================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <iomanip>

// Mocking dependencies via include path manipulation (handled in CMake or manually here for simplicity if allowed)
// Since we want to test "SysExManager.cpp" logic, we need to satisfy its include of "SysExManager.h" which includes "PresetManager.h"
// We will rely on CMake to PRIORITIZE "Source/Tests/Mocks" in include path.

#include "../MIDI/SysExManager.h"
#include <juce_core/juce_core.h>

// Minimal Mock for PresetManager (definition, since we link against it)
namespace CZ101 {
namespace State {

// Static storage for test verification
static Preset capturedPreset;
static bool presetWasLoaded = false;

PresetManager::PresetManager(Parameters*, Core::VoiceManager*) {}
void PresetManager::loadPreset(int) {}
void PresetManager::savePreset(int, const std::string&) {}
void PresetManager::createFactoryPresets() {}
void PresetManager::createBassPreset() {}
void PresetManager::createLeadPreset() {}
void PresetManager::createBrassPreset() {}
void PresetManager::createStringPreset() {}
void PresetManager::createBellsPreset() {}
void PresetManager::applyPresetToProcessor() {}
void PresetManager::applyEnvelopeToVoice(const EnvelopeData&, int) {}

// The critical method we are testing
void PresetManager::loadPresetFromStruct(const Preset& p) 
{
    capturedPreset = p;
    presetWasLoaded = true;
    std::cout << "[Test] Preset Loaded: " << p.name << std::endl;
}

PresetManager::~PresetManager() {} // Destructor now declared in header

}
}

// Stub for Parameters (if needed by linker, but PresetManager stub doesn't use it)
namespace CZ101 { namespace State { class Parameters {}; } }
namespace CZ101 { namespace Core { class VoiceManager {}; } }


class StdoutLogger : public juce::Logger {
    void logMessage(const juce::String& message) override {
        std::cout << "[LOG] " << message << std::endl;
    }
};

int main(int argc, char* argv[])
{
    StdoutLogger logger;
    juce::Logger::setCurrentLogger(&logger);
    
    std::cout << "========================================" << std::endl;
    std::cout << "      CZ-101 SysEx Logic Test" << std::endl;
    std::cout << "========================================" << std::endl;

    if (argc < 2) {
        std::cerr << "Usage: CZ101SysExTest <path_to_syx_file>" << std::endl;
        return 1;
    }

    std::string filePath = argv[1];
    std::cout << "Loading file: " << filePath << std::endl;

    std::ifstream file(filePath, std::ios::binary | std::ios::ate);
    if (!file) {
        std::cerr << "Error: Could not open file." << std::endl;
        return 1;
    }

    std::streamsize size = file.tellg();
    file.seekg(0, std::ios::beg);

    std::vector<char> buffer(size);
    if (!file.read(buffer.data(), size)) {
        std::cerr << "Error: Could not read file." << std::endl;
        return 1;
    }

    std::cout << "Read " << size << " bytes." << std::endl;

    // Initialize mock dependencies
    CZ101::State::PresetManager mockPM(nullptr, nullptr);
    CZ101::MIDI::SysExManager sysExManager;
    // Bind mock
    sysExManager.onPresetParsed = [&](const CZ101::State::Preset& p) {
        mockPM.loadPresetFromStruct(p);
    };

    // Run Parsing
    sysExManager.handleSysEx(buffer.data(), (int)size, "Test Import");

    if (CZ101::State::presetWasLoaded) {
        std::cout << "SUCCESS: Preset decoded!" << std::endl;
        std::cout << "  Name: " << CZ101::State::capturedPreset.name << std::endl;
        
        // Brief Envelope Dump
        auto dumpEnv = [](const char* name, const CZ101::State::EnvelopeData& env) {
            std::cout << "  " << name << " Env:" << std::endl;
            for(int i=0; i<8; ++i) {
                if (env.levels[i] > 0.0f || env.rates[i] > 0.0f)
                    std::cout << "    Step " << i << ": R=" << env.rates[i] << " L=" << env.levels[i];
                if (i == env.sustainPoint) std::cout << " [SUS]";
                if (i == env.endPoint) std::cout << " [END]";
                if (env.levels[i] > 0.0f || env.rates[i] > 0.0f) std::cout << std::endl;
            }
        };

        dumpEnv("DCA", CZ101::State::capturedPreset.dcaEnv);
        dumpEnv("DCW", CZ101::State::capturedPreset.dcwEnv);
        dumpEnv("DCO", CZ101::State::capturedPreset.pitchEnv);
        
        return 0;
    } else {
        std::cerr << "FAILURE: handleSysEx did not trigger loadPresetFromStruct." << std::endl;
        // Maybe file wasn't recognized?
        return 1;
    }
}

================================================================================
FILE: .\Source\Tests\Mocks\State\PresetManager.h
================================================================================
#pragma once
#include <string>
#include <vector>
#include <map>

// Structs must match original
namespace CZ101 {
namespace State {

struct EnvelopeData
{
    float rates[8];
    float levels[8];
    int sustainPoint;
    int endPoint;
    EnvelopeData() {
        for (int i=0; i<8; ++i) { rates[i] = 0.5f; levels[i] = 0.0f; }
        sustainPoint = 2; endPoint = 3;
    }
};

struct Preset
{
    std::string name;
    std::map<std::string, float> parameters;
    EnvelopeData dcwEnv;
    EnvelopeData dcaEnv;
    EnvelopeData pitchEnv;
    Preset() : name("Init") {}
    Preset(const std::string& n) : name(n) {}
};

class Parameters; 
} 
namespace Core { class VoiceManager; } 
namespace State {

class PresetManager
{
public:
    PresetManager(Parameters* parameters, Core::VoiceManager* vm);
    ~PresetManager(); // Add destr
    
    void loadPreset(int index);
    void savePreset(int index, const std::string& name);
    void loadPresetFromStruct(const Preset& p); // Load directly (SysEx)
    
    // Stub getters
    const Preset& getCurrentPreset() const { return currentPreset; }
    const std::vector<Preset>& getPresets() const { return presets; }
    
private:
    std::vector<Preset> presets;
    Preset currentPreset;
    
    void createFactoryPresets();
    void createBassPreset();
    void createLeadPreset();
    void createBrassPreset();
    void createStringPreset();
    void createBellsPreset();
    
    void applyPresetToProcessor();
    void applyEnvelopeToVoice(const EnvelopeData& env, int type);
};

} 
} 

================================================================================
FILE: .\Source\UI\CZ101LookAndFeel.cpp
================================================================================
#include "CZ101LookAndFeel.h"

namespace CZ101 {
namespace UI {

CZ101LookAndFeel::CZ101LookAndFeel()
{
    primaryColour = juce::Colour(0xff2a2a2a);
    secondaryColour = juce::Colour(0xff4a9eff);
    textColour = juce::Colours::white;
    
    setColour(juce::Slider::thumbColourId, secondaryColour);
    setColour(juce::Slider::rotarySliderFillColourId, secondaryColour);
    setColour(juce::Slider::rotarySliderOutlineColourId, primaryColour);
}

void CZ101LookAndFeel::drawRotarySlider(juce::Graphics& g,
                                       int x, int y, int width, int height,
                                       float sliderPos,
                                       float rotaryStartAngle,
                                       float rotaryEndAngle,
                                       juce::Slider& slider)
{
    juce::ignoreUnused(slider);
    auto radius = juce::jmin(width / 2, height / 2) - 4.0f;
    auto centreX = x + width * 0.5f;
    auto centreY = y + height * 0.5f;
    auto rx = centreX - radius;
    auto ry = centreY - radius;
    auto rw = radius * 2.0f;
    auto angle = rotaryStartAngle + sliderPos * (rotaryEndAngle - rotaryStartAngle);
    
    // Fill
    g.setColour(primaryColour);
    g.fillEllipse(rx, ry, rw, rw);
    
    // Outline
    g.setColour(secondaryColour);
    g.drawEllipse(rx, ry, rw, rw, 2.0f);
    
    // Pointer
    juce::Path p;
    auto pointerLength = radius * 0.6f;
    auto pointerThickness = 3.0f;
    p.addRectangle(-pointerThickness * 0.5f, -radius, pointerThickness, pointerLength);
    p.applyTransform(juce::AffineTransform::rotation(angle).translated(centreX, centreY));
    
    g.setColour(secondaryColour);
    g.fillPath(p);
}
void CZ101LookAndFeel::drawButtonBackground(juce::Graphics& g,
                                        juce::Button& button,
                                        const juce::Colour& backgroundColour,
                                        bool isMouseOver,
                                        bool isButtonDown)
{
    // Base background
    g.setColour(backgroundColour);
    auto bounds = button.getLocalBounds().toFloat();

    // Hover scaling effect
    if (isMouseOver && !isButtonDown)
    {
        // Slightly enlarge the button background (2% increase)
        auto scale = 1.02f;
        auto centre = bounds.getCentre();
        bounds = bounds.withSizeKeepingCentre(bounds.getWidth() * scale,
                                             bounds.getHeight() * scale);
    }
    else if (isButtonDown)
    {
        // Slightly shrink when pressed (2% decrease)
        auto scale = 0.98f;
        auto centre = bounds.getCentre();
        bounds = bounds.withSizeKeepingCentre(bounds.getWidth() * scale,
                                             bounds.getHeight() * scale);
    }

    // Draw rounded rectangle for button background
    g.fillRoundedRectangle(bounds, 4.0f);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\CZ101LookAndFeel.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>

namespace CZ101 {
namespace UI {

class CZ101LookAndFeel : public juce::LookAndFeel_V4
{
public:
    CZ101LookAndFeel();
    
    void drawRotarySlider(juce::Graphics& g,
                         int x, int y, int width, int height,
                         float sliderPos,
                         float rotaryStartAngle,
                         float rotaryEndAngle,
                         juce::Slider& slider) override;
    
    // Custom button drawing with hover effect
    void drawButtonBackground(juce::Graphics& g,
                              juce::Button& button,
                              const juce::Colour& backgroundColour,
                              bool isMouseOver,
                              bool isButtonDown) override;
private:
    juce::Colour primaryColour;
    juce::Colour secondaryColour;
    juce::Colour textColour;
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\LCDDisplay.cpp
================================================================================
#include "LCDDisplay.h"

namespace CZ101 {
namespace UI {

LCDDisplay::LCDDisplay()
{
    // Authentic LCD Styling
    // CZ-101/5000 LCD is non-backlit (greyish) or backlit blue (mod).
    // Let's go for the classic "Grey/Green" text on dark background or the "Blue" style.
    // User interface is dark, so Blue LCD fits well.
    
    // Setup Labels
    addAndMakeVisible(topLineLabel);
    topLineLabel.setColour(juce::Label::textColourId, juce::Colour(0xffa0e0ff)); // Cyan/Blueish
    topLineLabel.setJustificationType(juce::Justification::centredLeft);
    topLineLabel.setFont(juce::Font("Courier New", 18.0f, juce::Font::bold)); // Monospaced

    addAndMakeVisible(bottomLineLabel);
    bottomLineLabel.setColour(juce::Label::textColourId, juce::Colour(0xffa0e0ff));
    bottomLineLabel.setJustificationType(juce::Justification::centredLeft);
    bottomLineLabel.setFont(juce::Font("Courier New", 18.0f, juce::Font::bold));
}

LCDDisplay::~LCDDisplay()
{
    if (stateManager)
        stateManager->removeChangeListener(this);
}

void LCDDisplay::setStateManager(LCDStateManager* mgr)
{
    if (stateManager)
        stateManager->removeChangeListener(this);
        
    stateManager = mgr;
    
    if (stateManager)
    {
        stateManager->addChangeListener(this);
        // Initial Update
        changeListenerCallback(stateManager);
    }
}

void LCDDisplay::changeListenerCallback(juce::ChangeBroadcaster*)
{
    if (stateManager)
    {
        topLineLabel.setText(stateManager->getTopLineText(), juce::dontSendNotification);
        bottomLineLabel.setText(stateManager->getBottomLineText(), juce::dontSendNotification);
    }
}

void LCDDisplay::paint(juce::Graphics& g)
{
    auto bounds = getLocalBounds().toFloat();
    
    // Background (Dark Blue/Black LCD Glass)
    g.setColour(juce::Colour(0xff101520));
    g.fillRoundedRectangle(bounds, 4.0f);
    
    // Pixel Grid Effect (Subtle)
    g.setColour(juce::Colours::white.withAlpha(0.05f));
    for (float x = 0; x < bounds.getWidth(); x += 3.0f)
        g.drawVerticalLine((int)x, 0.0f, bounds.getHeight());
        
    // Border (Bezel)
    g.setColour(juce::Colour(0xff404040));
    g.drawRoundedRectangle(bounds, 4.0f, 2.0f);
}

void LCDDisplay::resized()
{
    auto bounds = getLocalBounds().reduced(5);
    int rowHeight = bounds.getHeight() / 2;
    
    topLineLabel.setBounds(bounds.removeFromTop(rowHeight));
    bottomLineLabel.setBounds(bounds);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\LCDDisplay.h
================================================================================
/*
  ==============================================================================

    LCDDisplay.h
    Created: 15 Dec 2025
    Author:  Antigravity

  ==============================================================================
*/

#pragma once

#include <juce_gui_basics/juce_gui_basics.h>
#include "LCDStateManager.h"

namespace CZ101 {
namespace UI {

class LCDDisplay : public juce::Component,
                   public juce::ChangeListener
{
public:
    LCDDisplay();
    ~LCDDisplay() override;

    void setStateManager(LCDStateManager* mgr);
    
    // Helper to match existing usage in PluginEditor.cpp
    void updateFromManager(LCDStateManager* mgr) { setStateManager(mgr); }

    void paint(juce::Graphics& g) override;
    void resized() override;
    
    void changeListenerCallback(juce::ChangeBroadcaster* source) override;

private:
    LCDStateManager* stateManager = nullptr;
    juce::Label topLineLabel;
    juce::Label bottomLineLabel;
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(LCDDisplay)
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\LCDStateManager.cpp
================================================================================
#include "LCDStateManager.h"

namespace CZ101 {
namespace UI {

LCDStateManager::LCDStateManager(juce::AudioProcessorValueTreeState& apvtsToUse)
    : apvts(apvtsToUse), currentMode(Mode::EDIT)
{
    buildParameterList();
    updateDisplay();
}

void LCDStateManager::buildParameterList()
{
    parameterIds.clear();
    currentParameterIndex = 0;

    if (currentMode == Mode::EDIT)
    {
        // Standard Authentic Order
        parameterIds.push_back("LINE_SELECT");
        // parameterIds.push_back("OSC2_DETUNE"); // Needs manual mapping for Oct/Note? Use L2 Detune for now.
        parameterIds.push_back("OSC2_DETUNE"); 
        
        parameterIds.push_back("LFO_WAVE");
        parameterIds.push_back("LFO_DELAY");
        parameterIds.push_back("LFO_RATE");
        parameterIds.push_back("LFO_DEPTH");
        
        // DCO
        parameterIds.push_back("OSC1_WAVEFORM");
        parameterIds.push_back("OSC2_WAVEFORM");
        
        // Add Envelopes later
    }
    else if (currentMode == Mode::SYSTEM)
    {
        parameterIds.push_back("SYSTEM_PRG");
        parameterIds.push_back("PROTECT_SWITCH");
    }
}

void LCDStateManager::setMode(Mode newMode)
{
    currentMode = newMode;
    buildParameterList(); // Rebuild list for new mode
    updateDisplay();
    sendChangeMessage();
}

void LCDStateManager::onCursorLeft()
{
    if (parameterIds.empty()) return;
    currentParameterIndex = (currentParameterIndex - 1 + (int)parameterIds.size()) % (int)parameterIds.size();
    updateDisplay();
    sendChangeMessage();
}

void LCDStateManager::onCursorRight()
{
    if (parameterIds.empty()) return;
    currentParameterIndex = (currentParameterIndex + 1) % (int)parameterIds.size();
    updateDisplay();
    sendChangeMessage();
}

void LCDStateManager::onValueUp()
{
    modifyValue(true);
}

void LCDStateManager::onValueDown()
{
    modifyValue(false);
}

void LCDStateManager::onCompareButton() {}
void LCDStateManager::onWriteButton() {}

void LCDStateManager::modifyValue(bool isUp)
{
    if (currentParameterIndex < 0 || currentParameterIndex >= parameterIds.size()) return;
    
    juce::String paramID = parameterIds[currentParameterIndex];
    auto* param = apvts.getParameter(paramID);
    
    if (param)
    {
        float step = 0.01f; // Default small step
        
        // Try to get a better step from the parameter range if possible
        if (auto* floatParam = dynamic_cast<juce::AudioParameterFloat*>(param))
            step = 1.0f / floatParam->range.getRange().getLength(); // Normalize 1 integer step
        else if (auto* choiceParam = dynamic_cast<juce::AudioParameterChoice*>(param))
             step = 1.0f / (float)juce::jmax(1, choiceParam->choices.size() - 1);
        else if (auto* boolParam = dynamic_cast<juce::AudioParameterBool*>(param))
             step = 1.0f;

        float currentValue = param->getValue();
        float newValue = isUp ? (currentValue + step) : (currentValue - step);
        
        param->setValueNotifyingHost(juce::jlimit(0.0f, 1.0f, newValue));
        
        updateDisplay();
        sendChangeMessage();
    }
}

void LCDStateManager::updateDisplay()
{
    if (currentMode == Mode::NORMAL)
    {
        topLine = "NORMAL MODE";
        bottomLine = "SELECT PROGRAM";
    }
    else if (currentMode == Mode::EDIT || currentMode == Mode::SYSTEM)
    {
        if (parameterIds.empty()) {
            topLine = (currentMode == Mode::SYSTEM) ? "SYSTEM MODE" : "EDIT MODE";
            bottomLine = "NO PARAMETERS";
            return;
        }
        
        if (currentParameterIndex >= 0 && currentParameterIndex < parameterIds.size())
        {
            juce::String paramID = parameterIds[currentParameterIndex];
            auto* param = apvts.getParameter(paramID);
            
            if (param)
            {
                juce::String name = param->getName(16);
                juce::String valueStr = param->getCurrentValueAsText();
                
                // Custom overrides for authenticity
                if (paramID == "SYSTEM_PRG") {
                    name = "MIDI PRG";
                    valueStr = (param->getValue() > 0.5f) ? "ENA" : "DIS";
                }
                else if (paramID == "PROTECT_SWITCH") {
                    name = "PROTECT";
                    valueStr = (param->getValue() > 0.5f) ? "ON" : "OFF";
                }
                
                topLine = ((currentMode == Mode::SYSTEM) ? "SYS: " : "EDT: ") + name;
                bottomLine = valueStr;
            }
            else
            {
                topLine = "PARAM ERROR";
                bottomLine = paramID;
            }
        }
    }
}

juce::String LCDStateManager::getTopLineText() const { return topLine; }
juce::String LCDStateManager::getBottomLineText() const { return bottomLine; }

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\LCDStateManager.h
================================================================================
#pragma once

#include <juce_core/juce_core.h>
#include <juce_audio_processors/juce_audio_processors.h>

namespace CZ101 {
namespace UI {

    class LCDStateManager : public juce::ChangeBroadcaster
    {
    public:
        enum class Mode {
            NORMAL,   // Program Select / Tone Mix
            EDIT,     // Parameter Editing
            SYSTEM    // System Settings (MIDI, Protect)
        };

        LCDStateManager(juce::AudioProcessorValueTreeState& apvts);
        ~LCDStateManager() = default;

        // Navigation Inputs
        void onCursorLeft();
        void onCursorRight();
        void onValueUp();
        void onValueDown();
        void onCompareButton(); // Toggles Compare
        void onWriteButton();   // Triggers Write Mode

        // Display Data Access
        juce::String getTopLineText() const;
        juce::String getBottomLineText() const;
        
        // Mode Switching
        void setMode(Mode newMode);
        Mode getMode() const { return currentMode; }

    private:
        juce::AudioProcessorValueTreeState& apvts;
        Mode currentMode = Mode::NORMAL;
        
        // Navigation State
        int currentParameterIndex = 0;
        int currentProgramIndex = 0; // 0-31 (Internal)
        
        // Parameter List for Edit Mode
        std::vector<juce::String> parameterIds;
        void buildParameterList();
        
        // Helpers
        void updateDisplay();
        void modifyValue(bool isUp);
        
        // Internal data
        juce::String topLine;
        juce::String bottomLine;

        JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(LCDStateManager)
    };

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\EnvelopeEditor.cpp
================================================================================
#include "EnvelopeEditor.h"

namespace CZ101 {
namespace UI {

EnvelopeEditor::EnvelopeEditor(CZ101AudioProcessor& processor, EnvelopeType type)
    : audioProcessor(processor), envType(type)
{
    // Initialize with dummy default data
    for (int i = 0; i < 8; ++i)
    {
        rates[i] = 0.5f;
        levels[i] = (i % 2 == 0) ? 1.0f : 0.0f;
    }
    
    updateData();
}

EnvelopeEditor::~EnvelopeEditor()
{
}

void EnvelopeEditor::updateData()
{
    auto& vm = audioProcessor.getVoiceManager();
    
    for (int i = 0; i < 8; ++i)
    {
        float r = 0.5f;
        float l = 0.0f;
        
        if (envType == EnvelopeType::DCA)
            vm.getDCAStage(i, r, l);
        else if (envType == EnvelopeType::DCW)
            vm.getDCWStage(i, r, l);
        else if (envType == EnvelopeType::PITCH)
            vm.getPitchStage(i, r, l);
            
        rates[i] = r;
        levels[i] = l;
    }
    
    if (envType == EnvelopeType::DCA)
    {
        sustainPoint = vm.getDCASustainPoint();
        endPoint = vm.getDCAEndPoint();
    }
    else if (envType == EnvelopeType::DCW)
    {
        sustainPoint = vm.getDCWSustainPoint();
        endPoint = vm.getDCWEndPoint();
    }
    else if (envType == EnvelopeType::PITCH)
    {
        sustainPoint = vm.getPitchSustainPoint();
        endPoint = vm.getPitchEndPoint();
    }
    
    repaint();
}

void EnvelopeEditor::paint(juce::Graphics& g)
{
    // Background
    g.fillAll(juce::Colours::black.withAlpha(0.8f));
    g.setColour(juce::Colours::darkgrey);
    g.drawRect(getLocalBounds(), 1);
    
    auto bounds = getLocalBounds().toFloat();
    float w = bounds.getWidth();
    float h = bounds.getHeight();
    
    // Draw grid/guides
    g.setColour(juce::Colours::white.withAlpha(0.1f));
    for (int i = 0; i < 8; ++i)
    {
        float x = w * (static_cast<float>(i) / 8.0f);
        g.drawVerticalLine(static_cast<int>(x), 0.0f, h);
    }
    
    // Draw Path
    juce::Colour pathColour;
    if (envType == EnvelopeType::DCA) pathColour = juce::Colours::cyan;
    else if (envType == EnvelopeType::DCW) pathColour = juce::Colours::orange;
    else pathColour = juce::Colours::magenta; // PITCH

    g.setColour(pathColour);
    juce::Path p;
    
    // Start at 0,0 (bottom left-ish logic, but CZ starts at previous level. Assume 0 for start)
    // Actually CZ starts at 'Level' of current step? No, it moves TO Level.
    // Stage I: Start Level -> Target Level at Rate.
    // We need to simulate the path for visualization.
    
    float currentX = 0.0f;
    float currentY = h; // 0 level is bottom
    
    p.startNewSubPath(currentX, currentY);
    
    // We visualize cumulative time on X axis?
    // Or constant width per stage? 
    // Constant width per stage is easier to edit. Time-based is hard if rate is 0 (long time).
    // Let's use constant width for editing (CZ-101 LCD style).
    
    float stepWidth = w / 8.0f;
    
    for (int i = 0; i < 8; ++i)
    {
        float nextX = (i + 1) * stepWidth;
        // Level 0..1 -> h..0
        float val = levels[i];
        float nextY = h - (val * h);
        
        // Rate affects slope, but here X is fixed stages. 
        // We can visualize Rate as the steepness? No, X is time.
        // Let's draw the target point.
        
        p.lineTo(nextX, nextY);
        
        // Dotted line for sustain point
        if (i == sustainPoint)
        {
            g.setColour(juce::Colours::yellow);
            g.drawVerticalLine(static_cast<int>(nextX), 0.0f, h);
            g.drawText("SUS", static_cast<int>(nextX) - 20, 0, 40, 15, juce::Justification::centred);
        }
        if (i == endPoint)
        {
            g.setColour(juce::Colours::red);
            g.drawVerticalLine(static_cast<int>(nextX), 0.0f, h);
            g.drawText("END", static_cast<int>(nextX) - 20, 15, 40, 15, juce::Justification::centred);
        }
        
        // Draw Handle
        g.setColour(i == selectedStage ? juce::Colours::white : juce::Colours::lightgrey);
        g.fillEllipse(nextX - 4, nextY - 4, 8, 8);
        
        // Revert color for path
        // Revert color for path
        g.setColour(pathColour);
    }
    
    g.strokePath(p, juce::PathStrokeType(2.0f));
    
    // Add help text at bottom
    g.setColour(juce::Colours::white.withAlpha(0.3f));
    g.setFont(10.0f);
    g.drawText("Drag: Level | Shift+Drag: Rate", 
               getLocalBounds().reduced(5).withHeight(15),
               juce::Justification::centredBottom, false);
}

void EnvelopeEditor::resized()
{
}

void EnvelopeEditor::mouseDown(const juce::MouseEvent& e)
{
    float w = static_cast<float>(getWidth());
    float stepWidth = w / 8.0f;
    
    // Find clicked stage
    int stage = static_cast<int>(e.position.x / stepWidth);
    if (stage >= 0 && stage < 8)
    {
        selectedStage = stage;
        repaint();
    }
}

void EnvelopeEditor::mouseDrag(const juce::MouseEvent& e)
{
    if (selectedStage >= 0 && selectedStage < 8)
    {
        if (e.mods.isShiftDown())
        {
            // SHIFT+DRAG = Rate (horizontal)
            // Range 0..1 based on position within the step width
            float w = static_cast<float>(getWidth());
            float stepWidth = w / 8.0f;
            float stageStartX = selectedStage * stepWidth;
            
            // Normalize X within stage to 0..1
            float xWithinStage = e.position.x - stageStartX;
            float newRate = std::clamp(xWithinStage / stepWidth, 0.01f, 0.99f);
            
            rates[selectedStage] = newRate;
        }
        else
        {
            // NORMAL DRAG = Level (vertical)
            float y = std::clamp(e.position.y / static_cast<float>(getHeight()), 0.0f, 1.0f);
            levels[selectedStage] = 1.0f - y; // Invert because screen Y is top-down
        }
        
        sendUpdateToProcessor(selectedStage);
        repaint();
    }
}

void EnvelopeEditor::mouseUp(const juce::MouseEvent& e)
{
    juce::ignoreUnused(e);
}

void EnvelopeEditor::sendUpdateToProcessor(int stageIndex)
{
    // Update Voice Manager directly
    // Note: In a real plugin we should use parameters to support automation
    // But we are in "Prototype / Phase 2" to verify engine.
    
    float lvl = levels[stageIndex];
    EnvelopeUpdateCommand cmd;
    cmd.index = stageIndex;
    cmd.rate = rates[stageIndex]; // Fixed for now
    cmd.level = lvl;

    if (envType == EnvelopeType::DCA)
        cmd.type = EnvelopeUpdateCommand::DCA_STAGE;
    else if (envType == EnvelopeType::DCW)
        cmd.type = EnvelopeUpdateCommand::DCW_STAGE;
    else if (envType == EnvelopeType::PITCH)
        cmd.type = EnvelopeUpdateCommand::PITCH_STAGE;

    audioProcessor.scheduleEnvelopeUpdate(cmd);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\EnvelopeEditor.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>
#include "../../PluginProcessor.h"

namespace CZ101 {
namespace UI {

class EnvelopeEditor : public juce::Component
{
public:
    enum class EnvelopeType { DCW, DCA, PITCH };
    
    EnvelopeEditor(CZ101AudioProcessor& processor, EnvelopeType type);
    ~EnvelopeEditor() override;
    
    void paint(juce::Graphics& g) override;
    void resized() override;
    
    // Updates local data from processor/preset
    void updateData(); 
    
    // Drag handlers
    void mouseDown(const juce::MouseEvent& e) override;
    void mouseDrag(const juce::MouseEvent& e) override;
    void mouseUp(const juce::MouseEvent& e) override;

private:
    CZ101AudioProcessor& audioProcessor;
    EnvelopeType envType;
    
    // Local copy of stage data for drawing/editing
    // 8 stages, rate (0-1), level (0-1)
    struct Point { float x; float y; };
    std::array<float, 8> rates;
    std::array<float, 8> levels;
    int sustainPoint = 2;
    int endPoint = 3;
    
    int selectedStage = -1;
    
    // Helper to map Rate(0-1)/Level(0-1) to screen coordinates
    juce::Point<float> getScreenPoint(int stageIndex, float w, float h);
    
    void sendUpdateToProcessor(int stageIndex);
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\Knob.cpp
================================================================================
#include "Knob.h"

namespace CZ101 {
namespace UI {

Knob::Knob(const juce::String& name)
    : juce::Slider(name)
{
    setSliderStyle(juce::Slider::RotaryHorizontalVerticalDrag);
    setTextBoxStyle(juce::Slider::TextBoxBelow, false, 50, 14);
    
    label.setText(name, juce::dontSendNotification);
    label.setJustificationType(juce::Justification::centred);
    label.setColour(juce::Label::textColourId, juce::Colours::white);
    label.setFont(juce::Font(12.0f));
    addAndMakeVisible(label);
}

void Knob::paint(juce::Graphics& g)
{
    juce::Slider::paint(g);
}

void Knob::resized()
{
    auto bounds = getLocalBounds();
    // Label at Top
    auto labelArea = bounds.removeFromTop(14);
    label.setBounds(labelArea);
    
    // Slider takes the rest (and puts TextBox at bottom)
    juce::Slider::resized();
}

void Knob::setLabel(const juce::String& text)
{
    labelText = text;
    label.setText(text, juce::dontSendNotification);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\Knob.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>

namespace CZ101 {
namespace UI {

class Knob : public juce::Slider
{
public:
    Knob(const juce::String& name);
    
    void paint(juce::Graphics& g) override;
    void resized() override;
    
    void setLabel(const juce::String& text);
    
private:
    juce::String labelText;
    juce::Label label;
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\MIDIActivityIndicator.cpp
================================================================================
#include "MIDIActivityIndicator.h"

namespace CZ101 {
namespace UI {

MIDIActivityIndicator::MIDIActivityIndicator()
{
    startTimer(30);
}

void MIDIActivityIndicator::paint(juce::Graphics& g)
{
    auto bounds = getLocalBounds().toFloat();
    
    g.setColour(juce::Colour(0xff2a2a2a));
    g.fillEllipse(bounds);
    
    if (brightness > 0.0f)
    {
        auto colour = juce::Colour(0xff4a9eff).withAlpha(brightness);
        g.setColour(colour);
        g.fillEllipse(bounds.reduced(2.0f));
    }
}

void MIDIActivityIndicator::timerCallback()
{
    if (isActive)
    {
        brightness = 1.0f;
        isActive = false;
    }
    else
    {
        brightness -= FADE_SPEED;
        if (brightness < 0.0f)
            brightness = 0.0f;
    }
    
    repaint();
}

void MIDIActivityIndicator::triggerActivity()
{
    isActive = true;
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\MIDIActivityIndicator.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>

namespace CZ101 {
namespace UI {

class MIDIActivityIndicator : public juce::Component, public juce::Timer
{
public:
    MIDIActivityIndicator();
    
    void paint(juce::Graphics& g) override;
    void timerCallback() override;
    
    void triggerActivity();
    
private:
    bool isActive = false;
    float brightness = 0.0f;
    
    static constexpr float FADE_SPEED = 0.1f;
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\PresetBrowser.cpp
================================================================================
#include "PresetBrowser.h"
#include "../../State/PresetManager.h"

namespace CZ101 {
namespace UI {

PresetBrowser::PresetBrowser()
{
    addAndMakeVisible(presetCombo);
    addAndMakeVisible(prevButton);
    addAndMakeVisible(nextButton);
    addAndMakeVisible(menuButton);
    
    prevButton.setButtonText("<");
    nextButton.setButtonText(">");
    menuButton.setButtonText("MENU");
    
    // High Visibility Colors
    presetCombo.setColour(juce::ComboBox::backgroundColourId, juce::Colour(0xff202020));
    presetCombo.setColour(juce::ComboBox::textColourId, juce::Colours::cyan);
    presetCombo.setColour(juce::ComboBox::arrowColourId, juce::Colours::cyan);
    presetCombo.setColour(juce::ComboBox::outlineColourId, juce::Colours::white.withAlpha(0.2f));
    
    prevButton.setColour(juce::TextButton::textColourOffId, juce::Colours::white);
    nextButton.setColour(juce::TextButton::textColourOffId, juce::Colours::white);
    menuButton.setColour(juce::TextButton::textColourOffId, juce::Colours::gold);
    
    // updatePresetList() cannot be called here yet as manager is null
    
    presetCombo.onChange = [this]()
    {
        selectPreset(presetCombo.getSelectedItemIndex());
    };
    
    prevButton.onClick = [this]()
    {
        int current = presetCombo.getSelectedItemIndex();
        if (current > 0)
            presetCombo.setSelectedItemIndex(current - 1);
    };
    
    nextButton.onClick = [this]()
    {
        int current = presetCombo.getSelectedItemIndex();
        if (current < presetCombo.getNumItems() - 1)
            presetCombo.setSelectedItemIndex(current + 1);
    };
    
    menuButton.onClick = [this] { showMenu(); };
}

void PresetBrowser::setPresetManager(State::PresetManager* pm)
{
    presetManager = pm;
    if (presetManager)
        updatePresetList();
}

void PresetBrowser::paint(juce::Graphics& g)
{
    auto bounds = getLocalBounds().toFloat();
    
    // Glass-morphism Effect
    g.setColour(juce::Colour(0xff1a1a1a).withAlpha(0.8f));
    g.fillRoundedRectangle(bounds, 6.0f);
    
    // Gradient Sheen
    juce::ColourGradient sheen(juce::Colours::white.withAlpha(0.1f), 0.0f, 0.0f,
                               juce::Colours::transparentWhite, 0.0f, bounds.getHeight() * 0.5f, false);
    g.setGradientFill(sheen);
    g.fillRoundedRectangle(bounds, 6.0f);
    
    // Border
    g.setColour(juce::Colours::white.withAlpha(0.15f));
    g.drawRoundedRectangle(bounds, 6.0f, 1.0f);
}

void PresetBrowser::resized()
{
    auto bounds = getLocalBounds().reduced(5);
    
    // Left: MENU (Reduced 60 -> 40)
    menuButton.setBounds(bounds.removeFromLeft(40));
    bounds.removeFromLeft(2);
    
    // Nav Buttons (Reduced 30 -> 25)
    prevButton.setBounds(bounds.removeFromLeft(25));
    bounds.removeFromLeft(2);
    nextButton.setBounds(bounds.removeFromRight(25));
    bounds.removeFromRight(2);
    
    presetCombo.setBounds(bounds);
}

void PresetBrowser::showMenu()
{
    juce::PopupMenu m;
    m.addSectionHeader("Bank Management");
    m.addItem(1, "Init Bank (Factory Reset)");
    m.addSeparator();
    m.addItem(2, "Load Bank (.json)...");
    m.addItem(3, "Save Bank (.json)...");
    m.addSeparator();
    m.addItem(4, "System Settings (MIDI/Protect)...");
    m.addSeparator();
    
    juce::PopupMenu initMenu;
    initMenu.addItem(101, "Initialize DCO");
    initMenu.addItem(102, "Initialize DCW");
    initMenu.addItem(103, "Initialize DCA");
    initMenu.addItem(104, "Initialize Vibrato");
    initMenu.addSeparator();
    initMenu.addItem(105, "Initialize ALL (1+1')");
    
    m.addSubMenu("Initialize Module...", initMenu);
    
    m.showMenuAsync(juce::PopupMenu::Options().withTargetComponent(&menuButton),
        [this](int result)
        {
            if (result == 1) initBank();
            else if (result == 2) loadBank();
            else if (result == 3) saveBank();
            else if (result == 4 && onSystemModeRequested) onSystemModeRequested();
            else if (result >= 101 && result <= 105 && onInitRequested)
            {
                // result 101 maps to InitSection enum?
                // 101 -> DCO (1)
                // 102 -> DCW (2)
                // 103 -> DCA (3)
                // 104 -> VIBRATO (4)
                // 105 -> ALL (6)
                // Need to map consistent with PluginProcessor::InitSection
                onInitRequested(result);
            }
        });
}

void PresetBrowser::initBank()
{
    if (!presetManager) return;

    // Show confirmation dialog
    juce::AlertWindow::showOkCancelBox(
        juce::AlertWindow::WarningIcon,
        "Reset Bank",
        "Are you sure? This will replace all presets with factory defaults.",
        "Reset",
        "Cancel",
        nullptr,
        juce::ModalCallbackFunction::create([this](int result)
        {
            // result == 1 means OK/Reset pressed
            if (result == 1)
            {
                presetManager->resetToFactory();
                updatePresetList();
                selectPreset(0);
            }
        })
    );
}

void PresetBrowser::loadBank()
{
    if (!presetManager) return;
    fileChooser = std::make_unique<juce::FileChooser>("Load Bank", juce::File::getSpecialLocation(juce::File::userDocumentsDirectory), "*.json");
    
    auto browserFlags = juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles;
    fileChooser->launchAsync(browserFlags, [this](const juce::FileChooser& fc)
    {
        auto file = fc.getResult();
        if (file.existsAsFile())
        {
            presetManager->loadBank(file);
            updatePresetList();
            selectPreset(0); // Go to first preset
        }
    });
}

void PresetBrowser::saveBank()
{
    if (!presetManager) return;
    fileChooser = std::make_unique<juce::FileChooser>("Save Bank", juce::File::getSpecialLocation(juce::File::userDocumentsDirectory), "*.json");
    
    auto browserFlags = juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::warnAboutOverwriting;
    fileChooser->launchAsync(browserFlags, [this](const juce::FileChooser& fc)
    {
        auto file = fc.getResult();
        if (file != juce::File())
        {
            presetManager->saveBank(file);
        }
    });
}

void PresetBrowser::updatePresetList()
{
    presetCombo.clear();
    
    if (presetManager == nullptr) return;
    
    const auto& presets = presetManager->getPresets();
    for (size_t i = 0; i < presets.size(); ++i)
    {
        presetCombo.addItem(presets[i].name, static_cast<int>(i) + 1);
    }
    
    // Sync with current PresetManager index
    int currentIdx = presetManager->getCurrentPresetIndex();
    if (currentIdx >= 0 && currentIdx < presetCombo.getNumItems())
    {
        presetCombo.setSelectedItemIndex(currentIdx, juce::dontSendNotification);
    }
    else
    {
        presetCombo.setSelectedItemIndex(0, juce::dontSendNotification);
    }
}

void PresetBrowser::selectPreset(int index)
{
    if (presetManager)
        presetManager->loadPreset(index);

    if (onPresetSelected)
        onPresetSelected(index);
}

int PresetBrowser::getSelectedItemIndex() const
{
    return presetCombo.getSelectedItemIndex();
}

void PresetBrowser::setSelectedItemIndex(int index)
{
    presetCombo.setSelectedItemIndex(index);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\PresetBrowser.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>
#include "../../State/PresetManager.h"

namespace CZ101 {
namespace UI {

class PresetBrowser : public juce::Component
{
public:
    PresetBrowser();
    void setPresetManager(State::PresetManager* pm);
    
    void paint(juce::Graphics& g) override;
    void resized() override;
    
    std::function<void(int)> onPresetSelected;
    std::function<void()> onSaveRequested;
    std::function<void()> onSystemModeRequested; // New Callback
    std::function<void(int)> onInitRequested; // int -> InitSection enum mapped
    
    // Exposed for Editor
    void updatePresetList();
    int getSelectedItemIndex() const;
    void setSelectedItemIndex(int index);
    
private:
    State::PresetManager* presetManager = nullptr;
    juce::ComboBox presetCombo;
    juce::TextButton prevButton;
    juce::TextButton nextButton;
    juce::TextButton saveButton;
    
    // Bank Management
    juce::TextButton menuButton;
    std::unique_ptr<juce::FileChooser> fileChooser;
    
    void showMenu();
    void initBank();
    void loadBank();
    void saveBank();
    
    // void updatePresetList(); // Moved to public
    void selectPreset(int index);
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\WaveformDisplay.cpp
================================================================================
#include "WaveformDisplay.h"
#include <cmath>

namespace CZ101 {
namespace UI {

WaveformDisplay::WaveformDisplay()
{
    waveformData.resize(256);
    generateWaveform();
    startTimer(50);
}

void WaveformDisplay::paint(juce::Graphics& g)
{
    auto bounds = getLocalBounds().toFloat();
    
    g.fillAll(juce::Colour(0xff1a1a1a));
    
    g.setColour(juce::Colour(0xff2a2a2a));
    g.drawRect(bounds, 2.0f);
    
    juce::Path path;
    auto width = bounds.getWidth();
    auto height = bounds.getHeight();
    auto centerY = bounds.getCentreY();
    
    path.startNewSubPath(bounds.getX(), centerY);
    
    for (size_t i = 0; i < waveformData.size(); ++i)
    {
        float x = bounds.getX() + (i / static_cast<float>(waveformData.size())) * width;
        float y = centerY - waveformData[i] * (height * 0.4f);
        path.lineTo(x, y);
    }
    
    g.setColour(juce::Colour(0xff4a9eff));
    g.strokePath(path, juce::PathStrokeType(2.0f));
}

void WaveformDisplay::timerCallback()
{
    repaint();
}

void WaveformDisplay::setWaveform(int waveformType)
{
    currentWaveform = waveformType;
    generateWaveform();
}

void WaveformDisplay::pushBuffer(const juce::AudioBuffer<float>& buffer)
{
    // Simple circular buffer or just grab the first channel's chunk for visualization
    auto* channelData = buffer.getReadPointer(0);
    int numSamples = buffer.getNumSamples();
    
    for (int i = 0; i < numSamples; ++i)
    {
        // Simple ring buffer push
        waveformData[writePos] = channelData[i];
        writePos = (writePos + 1) % waveformData.size();
    }
}

void WaveformDisplay::generateWaveform() 
{
    // No-op or clear, as we use live data now
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\WaveformDisplay.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_audio_basics/juce_audio_basics.h> // For AudioBuffer
#include <vector>

namespace CZ101 {
namespace UI {

class WaveformDisplay : public juce::Component, public juce::Timer
{
public:
    WaveformDisplay();
    
    void paint(juce::Graphics& g) override;
    void timerCallback() override;
    
    void setWaveform(int waveformType);
    void pushBuffer(const juce::AudioBuffer<float>& buffer);
    
private:
    std::vector<float> waveformData;
    int currentWaveform = 0;
    int writePos = 0;
    
    void generateWaveform();
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Overlays\NameEditorOverlay.cpp
================================================================================
#include "NameEditorOverlay.h"

namespace CZ101 {
namespace UI {

NameEditorOverlay::NameEditorOverlay()
{
    addAndMakeVisible(titleLabel);
    titleLabel.setText("RENAME PRESET", juce::dontSendNotification);
    titleLabel.setJustificationType(juce::Justification::centred);
    titleLabel.setColour(juce::Label::textColourId, juce::Colours::cyan);
    
    addAndMakeVisible(nameEditor);
    nameEditor.setJustification(juce::Justification::centred);
    
    addAndMakeVisible(saveButton);
    addAndMakeVisible(cancelButton);
    
    saveButton.addListener(this);
    cancelButton.addListener(this);
    
    // Enter key support
    nameEditor.onReturnKey = [this] { buttonClicked(&saveButton); };
    nameEditor.onEscapeKey = [this] { buttonClicked(&cancelButton); };
}

NameEditorOverlay::~NameEditorOverlay()
{
    saveButton.removeListener(this);
    cancelButton.removeListener(this);
}

void NameEditorOverlay::paint(juce::Graphics& g)
{
    // Semi-transparent background for the whole component
    g.fillAll(juce::Colours::black.withAlpha(0.6f));
    
    // Dialog box
    auto bounds = getLocalBounds().toFloat();
    // Create a 300x150 rectangle centered in bounds
    auto dialogRect = juce::Rectangle<float>(300, 150).withCentre(bounds.getCentre());
    
    g.setColour(juce::Colour(0xff2a2a2a));
    g.fillRoundedRectangle(dialogRect, 10.0f);
    
    g.setColour(juce::Colours::cyan);
    g.drawRoundedRectangle(dialogRect, 10.0f, 2.0f);
}

void NameEditorOverlay::resized()
{
    auto bounds = getLocalBounds();
    auto center = bounds.getCentre();
    
    int w = 300;
    int h = 150;
    int x = center.x - w/2;
    int y = center.y - h/2;
    
    titleLabel.setBounds(x + 10, y + 10, w - 20, 30);
    nameEditor.setBounds(x + 20, y + 50, w - 40, 30);
    
    cancelButton.setBounds(x + 20, y + 100, 120, 30);
    saveButton.setBounds(x + 160, y + 100, 120, 30);
}

void NameEditorOverlay::startRename(const juce::String& currentName, std::function<void(const juce::String&)> onSaveCallback)
{
    nameEditor.setText(currentName);
    onSave = onSaveCallback;
    setVisible(true);
    toFront(true);
    nameEditor.grabKeyboardFocus();
}

void NameEditorOverlay::buttonClicked(juce::Button* b)
{
    if (b == &saveButton)
    {
        if (onSave) onSave(nameEditor.getText());
        setVisible(false);
    }
    else if (b == &cancelButton)
    {
        setVisible(false);
    }
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Overlays\NameEditorOverlay.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>

namespace CZ101 {
namespace UI {

class NameEditorOverlay : public juce::Component,
                          private juce::Button::Listener
{
public:
    NameEditorOverlay();
    ~NameEditorOverlay() override;

    void paint(juce::Graphics& g) override;
    void resized() override;
    
    // Setup
    void startRename(const juce::String& currentName, std::function<void(const juce::String&)> onSaveCallback);
    
    // Listener
    void buttonClicked(juce::Button* b) override;

private:
    juce::Label titleLabel;
    juce::TextEditor nameEditor;
    juce::TextButton saveButton { "SAVE" };
    juce::TextButton cancelButton { "CANCEL" };
    
    std::function<void(const juce::String&)> onSave;
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(NameEditorOverlay)
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Sections\EffectsSection.cpp
================================================================================
#include "EffectsSection.h"

namespace CZ101 {
namespace UI {

EffectsSection::EffectsSection(CZ101AudioProcessor& p)
    : audioProcessor(p),
      chorusRateKnob("Rate"), chorusDepthKnob("Depth"), chorusMixKnob("Mix"),
      delayTimeKnob("Time"), delayFeedbackKnob("F/B"), delayMixKnob("Mix"),
      reverbSizeKnob("Size"), reverbMixKnob("Mix")
{
    setText("EFFECTS");
    setTextLabelPosition(juce::Justification::centredTop);

    auto& params = audioProcessor.getParameters();

    // --- Chorus ---
    addAndMakeVisible(chorusLabel); chorusLabel.setText("Chorus", juce::dontSendNotification); chorusLabel.setJustificationType(juce::Justification::centred);
    addAndMakeVisible(chorusRateKnob); addAndMakeVisible(chorusDepthKnob); addAndMakeVisible(chorusMixKnob);
    if (params.chorusRate) attachments.emplace_back(std::make_unique<SliderAttachment>(*params.chorusRate, chorusRateKnob));
    if (params.chorusDepth) attachments.emplace_back(std::make_unique<SliderAttachment>(*params.chorusDepth, chorusDepthKnob));
    if (params.chorusMix) attachments.emplace_back(std::make_unique<SliderAttachment>(*params.chorusMix, chorusMixKnob));

    // --- Delay ---
    addAndMakeVisible(delayLabel); delayLabel.setText("Delay", juce::dontSendNotification); delayLabel.setJustificationType(juce::Justification::centred);
    addAndMakeVisible(delayTimeKnob); addAndMakeVisible(delayFeedbackKnob); addAndMakeVisible(delayMixKnob);
    if (params.delayTime) attachments.emplace_back(std::make_unique<SliderAttachment>(*params.delayTime, delayTimeKnob));
    if (params.delayFeedback) attachments.emplace_back(std::make_unique<SliderAttachment>(*params.delayFeedback, delayFeedbackKnob));
    if (params.delayMix) attachments.emplace_back(std::make_unique<SliderAttachment>(*params.delayMix, delayMixKnob));

    // --- Reverb ---
    addAndMakeVisible(reverbLabel); reverbLabel.setText("Reverb", juce::dontSendNotification); reverbLabel.setJustificationType(juce::Justification::centred);
    addAndMakeVisible(reverbSizeKnob); addAndMakeVisible(reverbMixKnob);
    if (params.reverbSize) attachments.emplace_back(std::make_unique<SliderAttachment>(*params.reverbSize, reverbSizeKnob));
    if (params.reverbMix) attachments.emplace_back(std::make_unique<SliderAttachment>(*params.reverbMix, reverbMixKnob));
}

EffectsSection::~EffectsSection() {}

void EffectsSection::paint(juce::Graphics& g) {}

void EffectsSection::resized()
{
    auto bounds = getLocalBounds().reduced(15);
    bounds.removeFromTop(20);

    juce::FlexBox flexBox;
    flexBox.flexDirection = juce::FlexBox::Direction::row;

    juce::FlexBox chorusBox, delayBox, reverbBox;
    chorusBox.flexDirection = juce::FlexBox::Direction::column;
    delayBox.flexDirection = juce::FlexBox::Direction::column;
    reverbBox.flexDirection = juce::FlexBox::Direction::column;

    chorusBox.items.add(juce::FlexItem(chorusLabel).withFlex(0.5f));
    chorusBox.items.add(juce::FlexItem(chorusRateKnob).withFlex(1.5f));
    chorusBox.items.add(juce::FlexItem(chorusDepthKnob).withFlex(1.5f));
    chorusBox.items.add(juce::FlexItem(chorusMixKnob).withFlex(1.5f));

    delayBox.items.add(juce::FlexItem(delayLabel).withFlex(0.5f));
    delayBox.items.add(juce::FlexItem(delayTimeKnob).withFlex(1.5f));
    delayBox.items.add(juce::FlexItem(delayFeedbackKnob).withFlex(1.5f));
    delayBox.items.add(juce::FlexItem(delayMixKnob).withFlex(1.5f));

    reverbBox.items.add(juce::FlexItem(reverbLabel).withFlex(0.5f));
    reverbBox.items.add(juce::FlexItem(reverbSizeKnob).withFlex(1.5f));
    reverbBox.items.add(juce::FlexItem(reverbMixKnob).withFlex(1.5f));

    flexBox.items.add(juce::FlexItem(chorusBox).withFlex(1.0f));
    flexBox.items.add(juce::FlexItem(delayBox).withFlex(1.0f));
    flexBox.items.add(juce::FlexItem(reverbBox).withFlex(1.0f));

    flexBox.performLayout(bounds);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Sections\EffectsSection.h
================================================================================
#pragma once

#include <JuceHeader.h>
#include "../Components/Knob.h"
#include "../../PluginProcessor.h"

namespace CZ101 {
namespace UI {

class EffectsSection : public juce::GroupComponent
{
public:
    EffectsSection(CZ101AudioProcessor& p);
    ~EffectsSection() override;

    void paint(juce::Graphics& g) override;
    void resized() override;

private:
    CZ101AudioProcessor& audioProcessor;

    // Knobs para Chorus
    Knob chorusRateKnob, chorusDepthKnob, chorusMixKnob;
    juce::Label chorusLabel;

    // Knobs para Delay
    Knob delayTimeKnob, delayFeedbackKnob, delayMixKnob;
    juce::Label delayLabel;

    // Knobs para Reverb
    Knob reverbSizeKnob, reverbMixKnob;
    juce::Label reverbLabel;

    // Attachments
    using SliderAttachment = juce::SliderParameterAttachment;
    std::vector<std::unique_ptr<SliderAttachment>> attachments;
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Sections\FilterLfoSection.cpp
================================================================================
#include "FilterLfoSection.h"

namespace CZ101 {
namespace UI {

FilterLfoSection::FilterLfoSection(CZ101AudioProcessor& p)
    : audioProcessor(p),
      lfoRateKnob("Rate"),
      lfoDepthKnob("Depth"),
      lfoDelayKnob("Delay")
{
    setText("LFO/VIBRATO");
    setTextLabelPosition(juce::Justification::centredTop);

    auto& params = audioProcessor.getParameters();



    // LFO/Vibrato Controls
    addAndMakeVisible(lfoLabel);
    lfoLabel.setText("Vibrato (LFO)", juce::dontSendNotification);
    lfoLabel.setJustificationType(juce::Justification::centred);
    addAndMakeVisible(lfoWaveSelector);
    lfoWaveSelector.addItemList( { "Triangle", "Saw Up", "Saw Down", "Square" }, 1 );
    addAndMakeVisible(lfoRateKnob);
    addAndMakeVisible(lfoDepthKnob);
    addAndMakeVisible(lfoDelayKnob);
    if (params.lfoWaveform) comboAttachments.emplace_back(std::make_unique<ComboBoxAttachment>(*params.lfoWaveform, lfoWaveSelector));
    if (params.lfoRate) sliderAttachments.emplace_back(std::make_unique<SliderAttachment>(*params.lfoRate, lfoRateKnob));
    if (params.lfoDepth) sliderAttachments.emplace_back(std::make_unique<SliderAttachment>(*params.lfoDepth, lfoDepthKnob));
    if (params.lfoDelay) sliderAttachments.emplace_back(std::make_unique<SliderAttachment>(*params.lfoDelay, lfoDelayKnob));
}

FilterLfoSection::~FilterLfoSection() {}

void FilterLfoSection::paint(juce::Graphics& g) {}

void FilterLfoSection::resized()
{
    auto bounds = getLocalBounds().reduced(15);
    bounds.removeFromTop(20);

    juce::FlexBox flexBox;
    flexBox.flexDirection = juce::FlexBox::Direction::row;

    // Filter Box Removed


    // LFO Box
    juce::FlexBox lfoBox;
    lfoBox.flexDirection = juce::FlexBox::Direction::column;
    lfoBox.items.add(juce::FlexItem(lfoLabel).withFlex(0.5f));
    lfoBox.items.add(juce::FlexItem(lfoWaveSelector).withFlex(1));
    juce::FlexBox lfoKnobs;
    lfoKnobs.items.add(juce::FlexItem(lfoRateKnob).withFlex(1));
    lfoKnobs.items.add(juce::FlexItem(lfoDepthKnob).withFlex(1));
    lfoKnobs.items.add(juce::FlexItem(lfoDelayKnob).withFlex(1));
    lfoBox.items.add(juce::FlexItem(lfoKnobs).withFlex(2));


    flexBox.items.add(juce::FlexItem(lfoBox).withFlex(3.0f));

    flexBox.performLayout(bounds);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Sections\FilterLfoSection.h
================================================================================
#pragma once

#include <JuceHeader.h>
#include "../Components/Knob.h"
#include "../../PluginProcessor.h"

namespace CZ101 {
namespace UI {

class FilterLfoSection : public juce::GroupComponent
{
public:
    FilterLfoSection(CZ101AudioProcessor& p);
    ~FilterLfoSection() override;

    void paint(juce::Graphics& g) override;
    void resized() override;

private:
    CZ101AudioProcessor& audioProcessor;

    // Filter Controls Removed


    // LFO Controls
    juce::ComboBox lfoWaveSelector;
    Knob lfoRateKnob, lfoDepthKnob, lfoDelayKnob;
    juce::Label lfoLabel;

    // Attachments
    using SliderAttachment = juce::SliderParameterAttachment;
    using ComboBoxAttachment = juce::ComboBoxParameterAttachment;
    std::vector<std::unique_ptr<SliderAttachment>> sliderAttachments;
    std::vector<std::unique_ptr<ComboBoxAttachment>> comboAttachments;
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Sections\OscillatorSection.cpp
================================================================================
#include "OscillatorSection.h"

namespace CZ101 {
namespace UI {

OscillatorSection::OscillatorSection(CZ101AudioProcessor& p)
    : audioProcessor(p),
      osc1LevelKnob("Lvl 1"),
      osc2LevelKnob("Lvl 2"),
      osc2DetuneKnob("Detune"),
      glideKnob("Glide")
{
    setText("DCO - Digital Controlled Oscillators");
    setTextLabelPosition(juce::Justification::centredTop);

    auto& params = audioProcessor.getParameters();

    // === DCO 1 ===
    addAndMakeVisible(osc1WaveSelector);
    osc1WaveSelector.addItemList( { "Sawtooth", "Square", "Pulse", "Double Sine", "Saw-Pulse", "Resonance 1", "Resonance 2", "Resonance 3" }, 1 );
    if (params.osc1Waveform)
        osc1WaveAttachment = std::make_unique<ComboBoxAttachment>(*params.osc1Waveform, osc1WaveSelector);
    
    addAndMakeVisible(osc1LevelKnob);
    if (params.osc1Level)
        osc1LevelAttachment = std::make_unique<SliderAttachment>(*params.osc1Level, osc1LevelKnob);

    // === DCO 2 ===
    addAndMakeVisible(osc2WaveSelector);
    osc2WaveSelector.addItemList( { "Sawtooth", "Square", "Pulse", "Double Sine", "Saw-Pulse", "Resonance 1", "Resonance 2", "Resonance 3" }, 1 );
    if (params.osc2Waveform)
        osc2WaveAttachment = std::make_unique<ComboBoxAttachment>(*params.osc2Waveform, osc2WaveSelector);

    addAndMakeVisible(osc2LevelKnob);
    if (params.osc2Level)
        osc2LevelAttachment = std::make_unique<SliderAttachment>(*params.osc2Level, osc2LevelKnob);

    addAndMakeVisible(osc2DetuneKnob);
    if (params.osc2Detune)
        osc2DetuneAttachment = std::make_unique<SliderAttachment>(*params.osc2Detune, osc2DetuneKnob);

    // === Shared Controls ===
    addAndMakeVisible(hardSyncButton);
    hardSyncButton.setButtonText("Hard Sync");
    if (params.hardSync)
        hardSyncAttachment = std::make_unique<ButtonAttachment>(*params.hardSync, hardSyncButton);

    addAndMakeVisible(ringModButton);
    ringModButton.setButtonText("Ring Mod");
    if (params.ringMod)
        ringModAttachment = std::make_unique<ButtonAttachment>(*params.ringMod, ringModButton);

    addAndMakeVisible(glideKnob);
    if (params.glideTime)
        glideAttachment = std::make_unique<SliderAttachment>(*params.glideTime, glideKnob);
}

OscillatorSection::~OscillatorSection() {}

void OscillatorSection::paint(juce::Graphics& g) {
    // El GroupComponent se encarga del borde y el tÃ­tulo.
}

void OscillatorSection::resized()
{
    auto bounds = getLocalBounds().reduced(15);
    bounds.removeFromTop(20);

    auto dcoArea = bounds.removeFromTop(bounds.getHeight() * 0.7f);
    auto sharedArea = bounds;

    auto dco1Area = dcoArea.removeFromLeft(dcoArea.getWidth() / 2).reduced(5);
    auto dco2Area = dcoArea.reduced(5);

    // --- Layout DCO 1 con FlexBox ---
    juce::FlexBox flexDCO1;
    flexDCO1.flexDirection = juce::FlexBox::Direction::column;
    flexDCO1.items.add(juce::FlexItem(osc1WaveSelector).withFlex(0.5f));
    flexDCO1.items.add(juce::FlexItem(osc1LevelKnob).withFlex(1.5f));
    flexDCO1.performLayout(dco1Area);

    // --- Layout DCO 2 con FlexBox ---
    juce::FlexBox flexDCO2;
    flexDCO2.flexDirection = juce::FlexBox::Direction::column;
    flexDCO2.items.add(juce::FlexItem(osc2WaveSelector).withFlex(0.5f));
    
    juce::FlexBox dco2Knobs;
    dco2Knobs.items.add(juce::FlexItem(osc2LevelKnob).withFlex(1));
    dco2Knobs.items.add(juce::FlexItem(osc2DetuneKnob).withFlex(1));
    flexDCO2.items.add(juce::FlexItem(dco2Knobs).withFlex(1.5f));
    flexDCO2.performLayout(dco2Area);

    // --- Layout Controles Compartidos ---
    juce::FlexBox sharedFlex;
    sharedFlex.items.add(juce::FlexItem(glideKnob).withFlex(1));
    sharedFlex.items.add(juce::FlexItem(hardSyncButton).withFlex(1));
    sharedFlex.items.add(juce::FlexItem(ringModButton).withFlex(1));
    sharedFlex.performLayout(sharedArea);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Sections\OscillatorSection.h
================================================================================
#pragma once

#include <JuceHeader.h>
#include "../Components/Knob.h"
#include "../../PluginProcessor.h"

namespace CZ101 {
namespace UI {

class OscillatorSection : public juce::GroupComponent
{
public:
    OscillatorSection(CZ101AudioProcessor& p);
    ~OscillatorSection() override;

    void paint(juce::Graphics& g) override;
    void resized() override;

private:
    CZ101AudioProcessor& audioProcessor;
    
    // Controles de DCO1
    juce::ComboBox osc1WaveSelector;
    juce::Label osc1WaveLabel;
    Knob osc1LevelKnob;
    juce::Label osc1LevelLabel;

    // Controles de DCO2
    juce::ComboBox osc2WaveSelector;
    juce::Label osc2WaveLabel;
    Knob osc2LevelKnob;
    juce::Label osc2LevelLabel;
    Knob osc2DetuneKnob;
    juce::Label osc2DetuneLabel;

    // Controles compartidos
    juce::ToggleButton hardSyncButton;
    juce::ToggleButton ringModButton;
    Knob glideKnob;
    juce::Label glideLabel;

    // Attachments
    using ComboBoxAttachment = juce::ComboBoxParameterAttachment;
    using SliderAttachment = juce::SliderParameterAttachment;
    using ButtonAttachment = juce::ButtonParameterAttachment;

    std::unique_ptr<ComboBoxAttachment> osc1WaveAttachment;
    std::unique_ptr<SliderAttachment> osc1LevelAttachment;
    std::unique_ptr<ComboBoxAttachment> osc2WaveAttachment;
    std::unique_ptr<SliderAttachment> osc2LevelAttachment;
    std::unique_ptr<SliderAttachment> osc2DetuneAttachment;
    std::unique_ptr<ButtonAttachment> hardSyncAttachment;
    std::unique_ptr<ButtonAttachment> ringModAttachment;
    std::unique_ptr<SliderAttachment> glideAttachment;
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\CircularBuffer.h
================================================================================
#pragma once

#include <vector>
#include <cmath>
#include <algorithm>
#include <juce_core/juce_core.h>

namespace CZ101 {
namespace Utils {

template <typename T>
class CircularBuffer {
public:
    CircularBuffer() = default;
    
    void setSize(int newSize) {
        buffer.resize(newSize, 0);
        writeIndex = 0;
        size = newSize;
    }
    
    void clear() {
        std::fill(buffer.begin(), buffer.end(), T(0));
        writeIndex = 0;
    }
    
    void push(T sample) {
        buffer[writeIndex] = sample;
        writeIndex++;
        if (writeIndex >= size) writeIndex = 0;
    }
    
    T get(int delaySamples) const {
        int readIndex = writeIndex - 1 - delaySamples;
        while (readIndex < 0) readIndex += size;
        while (readIndex >= size) readIndex -= size;
        return buffer[readIndex];
    }
    
    // Linear Interpolation
    T getInterpolated(float delaySamples) const {
        int i = (int)delaySamples;
        float f = delaySamples - i;
        
        T s1 = get(i);
        T s2 = get(i + 1);
        
        return s1 + (s2 - s1) * f;
    }
    
private:
    std::vector<T> buffer;
    int writeIndex = 0;
    int size = 0;
};

} // namespace Utils
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\DSPHelpers.h
================================================================================
#pragma once

#include <cmath>
#include <algorithm>

namespace CZ101 {
namespace Utils {

class DSPHelpers
{
public:
    static float dbToGain(float db)
    {
        return std::pow(10.0f, db / 20.0f);
    }
    
    static float gainToDb(float gain)
    {
        return 20.0f * std::log10(std::max(gain, 0.00001f));
    }
    
    static float midiNoteToFrequency(int midiNote)
    {
        return 440.0f * std::pow(2.0f, (midiNote - 69) / 12.0f);
    }
    
    static int frequencyToMidiNote(float frequency)
    {
        return static_cast<int>(69 + 12 * std::log2(frequency / 440.0f));
    }
    
    static float lerp(float a, float b, float t)
    {
        return a + t * (b - a);
    }
    
    static float clamp(float value, float min, float max)
    {
        return std::clamp(value, min, max);
    }
    
    static float mapRange(float value, float inMin, float inMax, float outMin, float outMax)
    {
        return outMin + (value - inMin) * (outMax - outMin) / (inMax - inMin);
    }
};

} // namespace Utils
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\PerformanceMonitor.cpp
================================================================================
#include "PerformanceMonitor.h"
#include <algorithm>

namespace CZ101 {
namespace Utils {

PerformanceMonitor::PerformanceMonitor()
{
}

void PerformanceMonitor::startMeasurement()
{
    startTime = std::chrono::high_resolution_clock::now();
}

void PerformanceMonitor::stopMeasurement()
{
    endTime = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(endTime - startTime);
    double timeMs = duration.count() / 1000.0;
    
    totalTime += timeMs;
    peakTime = std::max(peakTime, timeMs);
    measurementCount++;
}

double PerformanceMonitor::getAverageCpuUsage() const
{
    if (measurementCount == 0)
        return 0.0;
    
    return totalTime / measurementCount;
}

double PerformanceMonitor::getPeakCpuUsage() const
{
    return peakTime;
}

int PerformanceMonitor::getVoiceCount() const
{
    return currentVoiceCount;
}

void PerformanceMonitor::setVoiceCount(int count)
{
    currentVoiceCount = count;
}

void PerformanceMonitor::reset()
{
    totalTime = 0.0;
    peakTime = 0.0;
    measurementCount = 0;
}

} // namespace Utils
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\PerformanceMonitor.h
================================================================================
#pragma once

#include <chrono>
#include <string>

namespace CZ101 {
namespace Utils {

class PerformanceMonitor
{
public:
    PerformanceMonitor();
    
    void startMeasurement();
    void stopMeasurement();
    
    double getAverageCpuUsage() const;
    double getPeakCpuUsage() const;
    int getVoiceCount() const;
    
    void setVoiceCount(int count);
    void reset();
    
private:
    std::chrono::high_resolution_clock::time_point startTime;
    std::chrono::high_resolution_clock::time_point endTime;
    
    double totalTime = 0.0;
    double peakTime = 0.0;
    int measurementCount = 0;
    int currentVoiceCount = 0;
};

} // namespace Utils
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\SmoothedValue.h
================================================================================
#pragma once

#include <cmath>

namespace CZ101 {
namespace Utils {

template<typename FloatType>
class SmoothedValue
{
public:
    SmoothedValue() = default;
    
    void reset(FloatType initialValue) noexcept
    {
        currentValue = initialValue;
        target = initialValue;
    }
    
    void setTargetValue(FloatType newTarget) noexcept
    {
        target = newTarget;
    }
    
    void setSmoothingTime(FloatType timeInSeconds, double sampleRate) noexcept
    {
        auto numSamples = static_cast<int>(timeInSeconds * sampleRate);
        setNumSteps(numSamples);
    }
    
    void setNumSteps(int numSteps) noexcept
    {
        stepsToTarget = numSteps;
        countdown = stepsToTarget;
        
        if (countdown > 0)
            step = (target - currentValue) / static_cast<FloatType>(countdown);
        else
            step = 0;
    }
    
    FloatType getNextValue() noexcept
    {
        if (countdown <= 0)
        {
            currentValue = target;
            return currentValue;
        }
        
        --countdown;
        currentValue += step;
        return currentValue;
    }
    
    FloatType getCurrentValue() const noexcept
    {
        return currentValue;
    }
    
    FloatType getTargetValue() const noexcept
    {
        return target;
    }
    
    bool isSmoothing() const noexcept
    {
        return countdown > 0;
    }

private:
    FloatType currentValue = 0;
    FloatType target = 0;
    FloatType step = 0;
    int countdown = 0;
    int stepsToTarget = 0;
};

} // namespace Utils
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\StringHelpers.h
================================================================================
#pragma once

#include <string>
#include <sstream>
#include <iomanip>

namespace CZ101 {
namespace Utils {

class StringHelpers
{
public:
    static std::string formatFrequency(float hz)
    {
        std::ostringstream oss;
        if (hz >= 1000.0f)
            oss << std::fixed << std::setprecision(2) << (hz / 1000.0f) << " kHz";
        else
            oss << std::fixed << std::setprecision(1) << hz << " Hz";
        return oss.str();
    }
    
    static std::string formatTime(float seconds)
    {
        std::ostringstream oss;
        if (seconds >= 1.0f)
            oss << std::fixed << std::setprecision(2) << seconds << " s";
        else
            oss << std::fixed << std::setprecision(1) << (seconds * 1000.0f) << " ms";
        return oss.str();
    }
    
    static std::string formatPercentage(float value)
    {
        std::ostringstream oss;
        oss << std::fixed << std::setprecision(1) << (value * 100.0f) << "%";
        return oss.str();
    }
    
    static std::string formatDecibels(float db)
    {
        std::ostringstream oss;
        oss << std::fixed << std::setprecision(1) << db << " dB";
        return oss.str();
    }
};

} // namespace Utils
} // namespace CZ101
