
================================================================================
FILE: .\Source\PluginEditor.cpp
================================================================================
#include "PluginEditor.h"
#include "UI/DesignTokens.h"
#include "MIDI/SysExManager.h" // Explicit include to prevent lookup issues

CZ101AudioProcessorEditor::CZ101AudioProcessorEditor(CZ101AudioProcessor& p)
    : AudioProcessorEditor(&p), audioProcessor(p),
      oscSection(p), effectsSection(p), filterLfoSection(p),
      // Initialize 6 Envelopes (Line 1 Types, then Line 2 Types) -- Note: EnvelopeEditor needs to know which line? 
      // Existing EnvelopeEditor took (processor, type). It relied on 'setLine'.
      // Now we need to set line on init or via setLine immediately.
      pitchEditorL1(p, CZ101::UI::EnvelopeEditor::EnvelopeType::PITCH),
      pitchEditorL2(p, CZ101::UI::EnvelopeEditor::EnvelopeType::PITCH),
      dcwEditorL1(p, CZ101::UI::EnvelopeEditor::EnvelopeType::DCW),
      dcwEditorL2(p, CZ101::UI::EnvelopeEditor::EnvelopeType::DCW),
      dcaEditorL1(p, CZ101::UI::EnvelopeEditor::EnvelopeType::DCA),
      dcaEditorL2(p, CZ101::UI::EnvelopeEditor::EnvelopeType::DCA),
      keyboardComponent(keyboardState, juce::MidiKeyboardComponent::horizontalKeyboard)
{
    juce::LookAndFeel::setDefaultLookAndFeel(&customLookAndFeel);
    openGLContext.attachTo(*this);

    // Set Lines
    pitchEditorL1.setLine(1); pitchEditorL2.setLine(2);
    dcwEditorL1.setLine(1);   dcwEditorL2.setLine(2);
    dcaEditorL1.setLine(1);   dcaEditorL2.setLine(2);

    addAndMakeVisible(oscSection);
    addAndMakeVisible(effectsSection);
    addAndMakeVisible(filterLfoSection);
    addAndMakeVisible(waveformDisplay);
    addAndMakeVisible(keyboardComponent);
    addAndMakeVisible(lcdDisplay);
    addAndMakeVisible(envelopeTabs);
    
    // Create Containers
    pitchContainer = std::make_unique<DualEnvelopeContainer>(pitchEditorL1, pitchEditorL2);
    dcwContainer   = std::make_unique<DualEnvelopeContainer>(dcwEditorL1, dcwEditorL2);
    dcaContainer   = std::make_unique<DualEnvelopeContainer>(dcaEditorL1, dcaEditorL2);

    // Header Components
    addAndMakeVisible(presetBrowser);
    presetBrowser.setPresetManager(&audioProcessor.getPresetManager());
    
    // Wire Mode Switching
    auto& lcdMgr = audioProcessor.getLCDStateManager();

    presetBrowser.onSystemModeRequested = [&lcdMgr]() { lcdMgr.setMode(CZ101::UI::LCDStateManager::Mode::SYSTEM); };
    
    presetBrowser.onInitRequested = [this](int id) {
        auto s = InitSection::ALL;
        if (id == 101) s = InitSection::DCO;
        else if (id == 102) s = InitSection::DCW;
        else if (id == 103) s = InitSection::DCA;
        else if (id == 104) s = InitSection::VIBRATO;
        else if (id == 105) s = InitSection::ALL;
        audioProcessor.initializeSection(s);
    };
    
    presetBrowser.onPresetSelected = [this](int index) {
        pitchEditorL1.updateData(); pitchEditorL2.updateData();
        dcwEditorL1.updateData();   dcwEditorL2.updateData();
        dcaEditorL1.updateData();   dcaEditorL2.updateData();
        
        bool prot = (bool)audioProcessor.getParameters().getAPVTS().getRawParameterValue("PROTECT_SWITCH")->load();
        protectButton.setToggleState(prot, juce::dontSendNotification);
    };
    
    // Removed MIDI LED per user request (or made small/hidden - User said "remove or small circular". I'll skip adding it to simplify)
    // addAndMakeVisible(midiIndicator); 
    
    addAndMakeVisible(loadSysExButton);
    addAndMakeVisible(saveSysExButton);
    addAndMakeVisible(protectButton);
    
    loadSysExButton.onClick = [this]() { loadSysExFile(); };
    saveSysExButton.onClick = [this]() { saveSysExFile(); };

    // LCD Buttons
    addAndMakeVisible(cursorLeft); addAndMakeVisible(cursorRight);
    addAndMakeVisible(cursorUp); addAndMakeVisible(cursorDown);

    // Protect Button Styling (TextButton as Toggle)
    protectButton.setButtonText("Protect");
    protectButton.setClickingTogglesState(true);
    protectButton.setColour(juce::TextButton::buttonOnColourId, juce::Colours::red);
    protectButton.setColour(juce::TextButton::buttonColourId, juce::Colours::darkgrey);
    // Remove old ToggleButton styling logic
    // protectButton.setColour(juce::ToggleButton::tickColourId...);
    
    protectAttachment = std::make_unique<juce::AudioProcessorValueTreeState::ButtonAttachment>(
        audioProcessor.getParameters().getAPVTS(), "PROTECT_SWITCH", protectButton);
    
    lcdDisplay.setStateManager(&lcdMgr);
    
    // INVERTED LOGIC: Up = Add (ValueUp), Down = Sub (ValueDown)
    cursorLeft.onClick   = [&lcdMgr]() { lcdMgr.onCursorLeft(); };
    cursorRight.onClick  = [&lcdMgr]() { lcdMgr.onCursorRight(); };
    cursorUp.onClick     = [&lcdMgr]() { lcdMgr.onValueUp(); };   // Up arrow -> Plus
    cursorDown.onClick   = [&lcdMgr]() { lcdMgr.onValueDown(); }; // Down arrow -> Minus
    
    keyboardState.addListener(this);

    // Add Tabs with Containers
    envelopeTabs.addTab("PITCH", juce::Colours::magenta, pitchContainer.get(), false);
    envelopeTabs.addTab("DCW", juce::Colours::orange, dcwContainer.get(), false);
    envelopeTabs.addTab("DCA", juce::Colours::cyan, dcaContainer.get(), false);

    setSize(1200, 768); // WIDER REV 4
    startTimerHz(60);
}

CZ101AudioProcessorEditor::~CZ101AudioProcessorEditor()
{
    stopTimer();
    keyboardState.removeListener(this);
    openGLContext.detach();
    juce::LookAndFeel::setDefaultLookAndFeel(nullptr);
}

void CZ101AudioProcessorEditor::paint(juce::Graphics& g) 
{ 
    g.fillAll(CZ101::UI::DesignTokens::Colors::background); 
    
    g.setColour(CZ101::UI::DesignTokens::Colors::border);
    g.drawHorizontalLine(60, 0, getWidth());
    g.drawHorizontalLine(getHeight() - 80, 0, getWidth());
}

// --- LAYOUT REV 5 (Left-LCD-Right-UpDown) ---
void CZ101AudioProcessorEditor::resized()
{
    using namespace CZ101::UI;
    auto area = getLocalBounds();
    
    // 1. Keyboard (Bottom 12%)
    keyboardComponent.setBounds(area.removeFromBottom(getHeight() * 0.12f));
    
    // 2. Header (Top 8%)
    auto headerArea = area.removeFromTop(getHeight() * 0.08f);
    
    // WIDER Preset Browser (left) (40% now)
    presetBrowser.setBounds(headerArea.removeFromLeft(getWidth() * 0.40f).reduced(10, 5));
    
    // Global Buttons (Right Edge)
    auto headerRight = headerArea.removeFromRight(getWidth() * 0.20f);
    auto btnW = headerRight.getWidth() / 3;
    loadSysExButton.setBounds(headerRight.removeFromLeft(btnW).reduced(5));
    saveSysExButton.setBounds(headerRight.removeFromLeft(btnW).reduced(5));
    protectButton.setBounds(headerRight.removeFromLeft(btnW).reduced(5)); // Red Button

    // CENTER: [Left] [LCD] [Right] [UpDownStack]
    // Calculate total width needed for this block to center it properly
    int lcdW = 280;
    int arrowW = 40;   // Width of main navigation arrows
    int upDownW = 28;  // Smaller width for the increment stack
    int sidePadding = 4;
    
    int totalCenterW = arrowW + sidePadding + lcdW + sidePadding + arrowW + sidePadding + upDownW; 
    
    auto centerArea = headerArea; 
    auto contentRect = centerArea.withSizeKeepingCentre(totalCenterW, centerArea.getHeight());
    
    // 1. Left Arrow
    cursorLeft.setBounds(contentRect.removeFromLeft(arrowW).reduced(5, 12));
    
    // 2. LCD
    contentRect.removeFromLeft(sidePadding);
    lcdDisplay.setBounds(contentRect.removeFromLeft(lcdW).reduced(0, 6));
    
    // 3. Right Arrow
    contentRect.removeFromLeft(sidePadding);
    cursorRight.setBounds(contentRect.removeFromLeft(arrowW).reduced(5, 12));
    
    // 4. Up/Down Stack (Small and Stacked)
    contentRect.removeFromLeft(sidePadding);
    auto upDownArea = contentRect.removeFromLeft(upDownW).reduced(0, 5);
    int halfH = upDownArea.getHeight() / 2;
    cursorUp.setBounds(upDownArea.removeFromTop(halfH).reduced(2));
    cursorDown.setBounds(upDownArea.reduced(2)); 
    
    // 3. Main Body
    auto bodyArea = area.reduced(10);
    // Wider Envelopes -> Reduce side columns
    int colWidth = bodyArea.getWidth() * 0.22f;
    
    auto leftSection = bodyArea.removeFromLeft(colWidth).reduced(5);
    oscSection.setBounds(leftSection.removeFromTop(leftSection.getHeight() * 0.65f));
    waveformDisplay.setBounds(leftSection.withTrimmedTop(10));
    
    auto rightSection = bodyArea.removeFromRight(colWidth).reduced(5);
    // User said: "shift right elements more to the right". (Implied by wider center).
    filterLfoSection.setBounds(rightSection.removeFromTop(rightSection.getHeight() * 0.55f));
    effectsSection.setBounds(rightSection.withTrimmedTop(10));
    
    // Center: Envelopes
    envelopeTabs.setBounds(bodyArea.reduced(5));
}

// --- MÃ‰TODOS CON LÃ“GICA RESTAURADA (versiÃ³n corta) ---
void CZ101AudioProcessorEditor::timerCallback()
{
    // Update MIDI Indicator
    if (audioProcessor.getMidiProcessor().hasRecentActivity())
    {
        // midiIndicator.triggerActivity(); // Removed midiIndicator
        audioProcessor.getMidiProcessor().clearActivityFlag();
    }
    
    // Update Waveform Display
    auto& buffer = audioProcessor.getVisBuffer();
    auto& fifo = audioProcessor.getVisFifo();
    // Variables already declared above
    if (fifo.getNumReady() > 0)
    {
        int start1, size1, start2, size2;
        fifo.prepareToRead(fifo.getNumReady(), start1, size1, start2, size2);
        
        if (size1 > 0)
        {
            // Create a temporary buffer for the slice
            juce::AudioBuffer<float> temp(1, size1);
            temp.copyFrom(0, 0, buffer, 0, start1, size1);
            waveformDisplay.pushBuffer(temp);
        }
        
        if (size2 > 0)
        {
             juce::AudioBuffer<float> temp(1, size2);
             temp.copyFrom(0, 0, buffer, 0, start2, size2);
             waveformDisplay.pushBuffer(temp);
        }
        
        fifo.finishedRead(size1 + size2);
    }
    
    waveformDisplay.repaint();
}

void CZ101AudioProcessorEditor::handleNoteOn(juce::MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity)
{
    auto m = juce::MidiMessage::noteOn(midiChannel, midiNoteNumber, velocity);
    audioProcessor.getMidiProcessor().processMessage(m);
}

void CZ101AudioProcessorEditor::handleNoteOff(juce::MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity)
{
    auto m = juce::MidiMessage::noteOff(midiChannel, midiNoteNumber, velocity);
    audioProcessor.getMidiProcessor().processMessage(m);
}

// void CZ101AudioProcessorEditor::refreshMidiOutputs() { ... } // Removed

void CZ101AudioProcessorEditor::loadSysExFile()
{
    fileChooser = std::make_unique<juce::FileChooser>("Select a CZ-101 SysEx file (.syx)..." ,
                                                       juce::File::getSpecialLocation(juce::File::userHomeDirectory),
                                                       "*.syx");
    
    fileChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
                              [this](const juce::FileChooser& fc)
    {
        auto file = fc.getResult();
        if (file.existsAsFile())
        {
            juce::MemoryBlock data;
            file.loadFileAsData(data);
            audioProcessor.getSysExManager().handleSysEx(data.getData(), (int)data.getSize(), file.getFileName());
        }
    });
}

void CZ101AudioProcessorEditor::saveSysExFile()
{
    fileChooser = std::make_unique<juce::FileChooser>("Save Current Patch as SysEx (.syx)..." ,
                                                       juce::File::getSpecialLocation(juce::File::userHomeDirectory),
                                                       "*.syx");
    
    fileChooser->launchAsync(juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles,
                              [this](const juce::FileChooser& fc)
    {
        auto file = fc.getResult();
        if (file != juce::File())
        {
            auto& preset = audioProcessor.getPresetManager().getCurrentPreset();
            auto data = audioProcessor.getSysExManager().createPatchDump(preset);
            if (data.getSize() > 0)
            {
                file.replaceWithData(data.getData(), data.getSize());
            }
        }
    }); // This closes launchAsync lambda and call
}

bool CZ101AudioProcessorEditor::isInterestedInFileDrag(const juce::StringArray& files)
{
    for (auto f : files) if (f.endsWithIgnoreCase(".syx")) return true;
    return false;
}

void CZ101AudioProcessorEditor::filesDropped(const juce::StringArray& files, int x, int y)
{
    for (auto f : files)
    {
        if (f.endsWithIgnoreCase(".syx"))
        {
            juce::File file(f);
            juce::MemoryBlock data;
            file.loadFileAsData(data);
            audioProcessor.getSysExManager().handleSysEx(data.getData(), (int)data.getSize(), file.getFileName());
            break; // Handle only one for now
        }
    }
}

================================================================================
FILE: .\Source\PluginEditor.h
================================================================================
#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include "PluginProcessor.h"
#include "UI/CZ101LookAndFeel.h"
#include "UI/DesignTokens.h"
#include "UI/Sections/OscillatorSection.h"
#include "UI/Sections/EffectsSection.h"
#include "UI/Sections/FilterLfoSection.h"
#include "UI/Components/EnvelopeEditor.h"
#include "UI/Components/WaveformDisplay.h"
#include "UI/LCDDisplay.h"
#include "UI/Components/PresetBrowser.h"
#include "UI/Components/MIDIActivityIndicator.h"
#include "UI/Overlays/NameEditorOverlay.h"

class CZ101AudioProcessorEditor : public juce::AudioProcessorEditor,
                                   private juce::MidiKeyboardState::Listener,
                                   private juce::Timer,
                                   public juce::FileDragAndDropTarget // <-- AÃ‘ADIDO
{
public:
    CZ101AudioProcessorEditor(CZ101AudioProcessor&);
    ~CZ101AudioProcessorEditor() override;

    void paint(juce::Graphics&) override;
    void resized() override;
    
private:
    // --- MÃ©todos de LÃ³gica y Eventos ---
    void timerCallback() override;
    void handleNoteOn(juce::MidiKeyboardState*, int, int, float) override;
    void handleNoteOff(juce::MidiKeyboardState*, int, int, float) override;
    void loadSysExFile();
    void saveSysExFile();
    bool isInterestedInFileDrag(const juce::StringArray& files) override;
    void filesDropped(const juce::StringArray& files, int x, int y) override;

    CZ101AudioProcessor& audioProcessor;
    CZ101::UI::CZ101LookAndFeel customLookAndFeel;
    juce::OpenGLContext openGLContext;
    
    // --- Componentes Principales y Secciones UI ---
    juce::MidiKeyboardState keyboardState;
    juce::MidiKeyboardComponent keyboardComponent;
    
    // Header
    CZ101::UI::LCDDisplay lcdDisplay;
    CZ101::UI::PresetBrowser presetBrowser;
    CZ101::UI::MIDIActivityIndicator midiIndicator;
    // juce::ComboBox midiOutputSelector; // Removed per user request
    juce::TextButton loadSysExButton { "LOAD SYX" };
    juce::TextButton saveSysExButton { "SAVE" };
    juce::TextButton protectButton { "PROTECT" }; // Authentic Memory Protect
    std::unique_ptr<juce::AudioProcessorValueTreeState::ButtonAttachment> protectAttachment;
    
    std::unique_ptr<juce::MidiOutput> activeMidiOutput;
    std::unique_ptr<juce::FileChooser> fileChooser;
    
    // Tooltip Implementation
    juce::TooltipWindow tooltipWindow { this, 700 }; // 700ms delay

    // Secciones del Cuerpo
    CZ101::UI::OscillatorSection oscSection;
    CZ101::UI::EffectsSection effectsSection;
    CZ101::UI::FilterLfoSection filterLfoSection;
    CZ101::UI::WaveformDisplay waveformDisplay;
    
    // Line Zoning (Visual only now)
    // juce::TextButton line1Button { "LINE 1" }; // Removed
    // juce::TextButton line2Button { "LINE 2" }; // Removed
    int currentLineView = 1;

    // LCD Navigation
    juce::ArrowButton cursorLeft  { "Left",  0.75f, CZ101::UI::DesignTokens::Colors::accentCyan }; // 0.75 = Left
    juce::ArrowButton cursorRight { "Right", 0.25f, CZ101::UI::DesignTokens::Colors::accentCyan }; // 0.25 = Right
    juce::ArrowButton cursorUp    { "Up",    0.00f, CZ101::UI::DesignTokens::Colors::accentCyan }; // 0.00 = Up
    juce::ArrowButton cursorDown  { "Down",  0.50f, CZ101::UI::DesignTokens::Colors::accentCyan }; // 0.50 = Down
    
    // Helper Class for Dual View
    struct DualEnvelopeContainer : public juce::Component {
        CZ101::UI::EnvelopeEditor& l1;
        CZ101::UI::EnvelopeEditor& l2;
        juce::Label label1 { {}, "LINE 1" };
        juce::Label label2 { {}, "LINE 2" };
        
        DualEnvelopeContainer(CZ101::UI::EnvelopeEditor& e1, CZ101::UI::EnvelopeEditor& e2) : l1(e1), l2(e2) {
            addAndMakeVisible(l1); addAndMakeVisible(l2);
            addAndMakeVisible(label1); addAndMakeVisible(label2);
            label1.setJustificationType(juce::Justification::centred);
            label2.setJustificationType(juce::Justification::centred);
            label1.setColour(juce::Label::textColourId, juce::Colours::cyan);
            // label2 is default
        }
        void resized() override {
            auto area = getLocalBounds();
            auto h = area.getHeight() / 2;
            auto area1 = area.removeFromTop(h);
            label1.setBounds(area1.removeFromTop(20));
            l1.setBounds(area1);
            
            label2.setBounds(area.removeFromTop(20));
            l2.setBounds(area);
        }
    };

    // Envolventes (Split View)
    juce::TabbedComponent envelopeTabs { juce::TabbedButtonBar::TabsAtTop };
    
    // Editor Instances
    CZ101::UI::EnvelopeEditor pitchEditorL1, pitchEditorL2;
    CZ101::UI::EnvelopeEditor dcwEditorL1, dcwEditorL2;
    CZ101::UI::EnvelopeEditor dcaEditorL1, dcaEditorL2;
    
    // Containers
    std::unique_ptr<DualEnvelopeContainer> pitchContainer;
    std::unique_ptr<DualEnvelopeContainer> dcwContainer;
    std::unique_ptr<DualEnvelopeContainer> dcaContainer;

    // Overlays
    CZ101::UI::NameEditorOverlay nameOverlay;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(CZ101AudioProcessorEditor)
};

================================================================================
FILE: .\Source\PluginProcessor.cpp
================================================================================
#include "PluginProcessor.h"
#include "PluginEditor.h"

// --- CONSTRUCTOR ---
CZ101AudioProcessor::CZ101AudioProcessor()
    : AudioProcessor(BusesProperties()
                     .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      voiceManager(),
      parameters(*this),
      presetManager(&parameters, &voiceManager),
      midiProcessor(voiceManager, presetManager),
      sysExManager()
{
    // Setup File Logger
    auto logFile = juce::File::getSpecialLocation(juce::File::userDocumentsDirectory)
                   .getChildFile("CZ101Emulator")
                   .getChildFile("cz101_debug.log");
                   
    fileLogger = std::make_unique<juce::FileLogger>(logFile, "CZ-101 Emulator Log");
    juce::Logger::setCurrentLogger(fileLogger.get());
    juce::Logger::writeToLog("Logger initialized at: " + logFile.getFullPathName());
    
    // Bind SysEx Callback
    sysExManager.onPresetParsed = [this](const CZ101::State::Preset& p) {
        // 1. Update Voice Engine immediately (Audio Thread safe-ish with lock)
        applyPresetToVoiceEngine(p);
        
        // 2. Defer Parameter/Host notification to Message Thread
        const juce::ScopedLock sl(presetLock);
        pendingSysExPreset = std::make_unique<CZ101::State::Preset>(p);
        hasPendingSysEx = true;
        triggerAsyncUpdate();
    };
    
    midiProcessor.setSysExManager(&sysExManager);
    
    // Initialize LCD State Manager here to ensure it persists and avoids dangling references
    lcdStateManager = std::make_unique<CZ101::UI::LCDStateManager>(parameters.getAPVTS());
}

CZ101AudioProcessor::~CZ101AudioProcessor() 
{ 
    juce::Logger::setCurrentLogger(nullptr); 
}

// --- APPLY PRESET TO VOICE ENGINE ---
void CZ101AudioProcessor::applyPresetToVoiceEngine(const CZ101::State::Preset& preset)
{
    // Audit Fix [D]: Lock preset to prevent race with Audio Thread
    const juce::ScopedLock sl(presetLock);

    // Envelopes: These update the VoiceManager directly as they are not mapped to APVTS parameters for performance reasons
    // Line 1
    for (int i = 0; i < 8; ++i) {
        voiceManager.setPitchStage(1, i, preset.pitchEnv.rates[i], preset.pitchEnv.levels[i]);
        voiceManager.setDCWStage(1, i, preset.dcwEnv.rates[i], preset.dcwEnv.levels[i]);
        voiceManager.setDCAStage(1, i, preset.dcaEnv.rates[i], preset.dcaEnv.levels[i]);
    }
    voiceManager.setPitchSustainPoint(1, preset.pitchEnv.sustainPoint);
    voiceManager.setPitchEndPoint(1, preset.pitchEnv.endPoint);
    voiceManager.setDCWSustainPoint(1, preset.dcwEnv.sustainPoint);
    voiceManager.setDCWEndPoint(1, preset.dcwEnv.endPoint);
    voiceManager.setDCASustainPoint(1, preset.dcaEnv.sustainPoint);
    voiceManager.setDCAEndPoint(1, preset.dcaEnv.endPoint);

    // Line 2
    for (int i = 0; i < 8; ++i) {
        voiceManager.setPitchStage(2, i, preset.pitchEnv2.rates[i], preset.pitchEnv2.levels[i]);
        voiceManager.setDCWStage(2, i, preset.dcwEnv2.rates[i], preset.dcwEnv2.levels[i]);
        voiceManager.setDCAStage(2, i, preset.dcaEnv2.rates[i], preset.dcaEnv2.levels[i]);
    }
    voiceManager.setPitchSustainPoint(2, preset.pitchEnv2.sustainPoint);
    voiceManager.setPitchEndPoint(2, preset.pitchEnv2.endPoint);
    voiceManager.setDCWSustainPoint(2, preset.dcwEnv2.sustainPoint);
    voiceManager.setDCWEndPoint(2, preset.dcwEnv2.endPoint);
    voiceManager.setDCASustainPoint(2, preset.dcaEnv2.sustainPoint);
    voiceManager.setDCAEndPoint(2, preset.dcaEnv2.endPoint);

    // APVTS parameters are updated by PresetManager::applyPresetToProcessor() called during load.
    // We only need to ensure the VoiceManager has the full Envelope data which might exceed APVTS simple ADSR.
    // Audit Fix 4: Removed redundant updateParameters() call as APVTS notification handles it.
}

// --- BASIC PLUGIN INFO ---
const juce::String CZ101AudioProcessor::getName() const { return JucePlugin_Name; }
bool CZ101AudioProcessor::acceptsMidi() const { return true; }
bool CZ101AudioProcessor::producesMidi() const { return false; }
bool CZ101AudioProcessor::isMidiEffect() const { return false; }
// Audit Fix 2.2: Return max reasonable tail (CZ-101 envelope max).
double CZ101AudioProcessor::getTailLengthSeconds() const { return 8.0; } 
int CZ101AudioProcessor::getNumPrograms() { return 1; }
int CZ101AudioProcessor::getCurrentProgram() { return 0; }
void CZ101AudioProcessor::setCurrentProgram(int index) { juce::ignoreUnused(index); }
const juce::String CZ101AudioProcessor::getProgramName(int index) { juce::ignoreUnused(index); return {}; }
void CZ101AudioProcessor::changeProgramName(int, const juce::String&) {}

// --- EDITOR ---
bool CZ101AudioProcessor::hasEditor() const { return true; }
juce::AudioProcessorEditor* CZ101AudioProcessor::createEditor() { return new CZ101AudioProcessorEditor(*this); }

// --- PREPARE TO PLAY ---
void CZ101AudioProcessor::prepareToPlay(double sr, int samplesPerBlock) 
{
    voiceManager.setSampleRate(sr);
    delayL.setSampleRate(sr);
    delayR.setSampleRate(sr);
    reverb.setSampleRate(sr);
    chorus.prepare(sr);
    
    juce::File presetsDir = juce::File::getSpecialLocation(juce::File::userDocumentsDirectory).getChildFile("CZ101Emulator");
    if (!presetsDir.exists()) presetsDir.createDirectory();
    juce::File bankFile = presetsDir.getChildFile("userbank.json");
    
    if (bankFile.existsAsFile()) {
        presetManager.loadBank(bankFile);
        if (presetManager.getPresets().empty()) presetManager.createFactoryPresets();
    } else {
        presetManager.createFactoryPresets();
        presetManager.saveBank(bankFile);
    }
    
    presetManager.loadPreset(0);
    
    // Audit Fix 1.2: Reset Effects RNG/Phase
    chorus.reset();
    delayL.reset();
    delayR.reset();
    reverb.reset(); // Added missing reverb reset
    
    // Audit Fix 3.1: Initialize Latency
    updateParameters();
}

void CZ101AudioProcessor::releaseResources() {}

bool CZ101AudioProcessor::isBusesLayoutSupported(const BusesLayout& layouts) const
{
    return layouts.getMainOutputChannelSet() == juce::AudioChannelSet::stereo();
}

// --- PROCESS BLOCK ---
void CZ101AudioProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    juce::ScopedNoDenormals noDenormals;
    performanceMonitor.startMeasurement();
    
    for (int i = getTotalNumInputChannels(); i < getTotalNumOutputChannels(); ++i) 
        buffer.clear(i, 0, buffer.getNumSamples());
    
    // Audit Fix [D]: Protect Audio Processing with Lock
    const juce::ScopedLock sl(presetLock);

    // Optimized Bypass Path
    if (parameters.bypass && parameters.bypass->get())
    {
        midiProcessor.processMidiBuffer(midiMessages);
        performanceMonitor.stopMeasurement();
        return;
    }

    processEnvelopeUpdates();
    updateParameters();
    
    midiProcessor.processMidiBuffer(midiMessages);
    
    auto* channelDataL = buffer.getWritePointer(0);
    auto* channelDataR = buffer.getWritePointer(1);
    
    voiceManager.renderNextBlock(channelDataL, channelDataR, buffer.getNumSamples());
    
    // Effects Path
    chorus.process(channelDataL, channelDataR, buffer.getNumSamples());
    
    for (int i=0; i<buffer.getNumSamples(); ++i) {
        channelDataL[i] = delayL.processSample(channelDataL[i]);
        if (channelDataR != channelDataL) channelDataR[i] = delayR.processSample(channelDataR[i]);
    }
    
    reverb.processStereo(channelDataL, channelDataR, buffer.getNumSamples());
    
    // Visualization logic
    if (visFifo.getFreeSpace() >= buffer.getNumSamples())
    {
        int start1, size1, start2, size2;
        visFifo.prepareToWrite(buffer.getNumSamples(), start1, size1, start2, size2);
        auto* l = buffer.getReadPointer(0);
        auto* r = (buffer.getNumChannels() > 1) ? buffer.getReadPointer(1) : l;
        
        if (size1 > 0) visBuffer.copyFrom(0, start1, buffer, 0, 0, size1);
        if (size2 > 0) visBuffer.copyFrom(0, start2, buffer, 0, size1, size2);
        visFifo.finishedWrite(size1 + size2);
    }
    
    performanceMonitor.stopMeasurement();
}

// --- UPDATE PARAMETERS (Centralized Logic) ---
void CZ101AudioProcessor::updateParameters()
{
    // Retrieve base values from APVTS
    int lineSel = parameters.lineSelect ? parameters.lineSelect->getIndex() : 2; 
    float l1 = parameters.osc1Level->get();
    float l2 = parameters.osc2Level->get();
    int w1_1 = parameters.osc1Waveform->getIndex();
    int w1_2 = parameters.osc1Waveform2 ? (parameters.osc1Waveform2->getIndex() == 0 ? 8 : parameters.osc1Waveform2->getIndex() - 1) : 8;
    int w2_1 = parameters.osc2Waveform->getIndex();
    int w2_2 = parameters.osc2Waveform2 ? (parameters.osc2Waveform2->getIndex() == 0 ? 8 : parameters.osc2Waveform2->getIndex() - 1) : 8;

    // 1. Line Select Muting Logic
    if (lineSel == 0) l2 = 0.0f; // Line 1 Only
    if (lineSel == 1) l1 = 0.0f; // Line 2 Only

    // 2. Line Select 1+1' Logic (Copy Line 1 to Line 2)
    // Audit Fix 2.1: Line 2 follows Line 1 but with detune
    // 2. Line Select 1+1' Logic (Copy Line 1 to Line 2)
    if (lineSel == 2) { 
        w2_1 = w1_1;
        w2_2 = w1_2;
        l2 = l1; // Audit Fix 2: Copy Line 1 Level to Line 2
        
        // Audit Fix [C]: Full Envelope Copy 1->2 (Parametric Mode)
        for (int i=0; i<8; ++i) {
             float r, lv;
             // Pitch
             voiceManager.getPitchStage(1, i, r, lv); voiceManager.setPitchStage(2, i, r, lv);
             // DCW
             voiceManager.getDCWStage(1, i, r, lv); voiceManager.setDCWStage(2, i, r, lv);
             // DCA
             voiceManager.getDCAStage(1, i, r, lv); voiceManager.setDCAStage(2, i, r, lv);
        }
        voiceManager.setPitchSustainPoint(2, voiceManager.getPitchSustainPoint(1));
        voiceManager.setPitchEndPoint(2, voiceManager.getPitchEndPoint(1));
        voiceManager.setDCWSustainPoint(2, voiceManager.getDCWSustainPoint(1));
        voiceManager.setDCWEndPoint(2, voiceManager.getDCWEndPoint(1));
        voiceManager.setDCASustainPoint(2, voiceManager.getDCASustainPoint(1));
        voiceManager.setDCAEndPoint(2, voiceManager.getDCAEndPoint(1));
    }

    // 3. Update VoiceManager engine
    voiceManager.setOsc1Level(l1);
    voiceManager.setOsc2Level(l2);
    voiceManager.setOsc1Waveforms(w1_1, w1_2);
    voiceManager.setOsc2Waveforms(w2_1, w2_2);
    
    voiceManager.setOsc2Detune(parameters.osc2Detune->get());
    if (parameters.hardSync) voiceManager.setHardSync(parameters.hardSync->get());
    if (parameters.ringMod) voiceManager.setRingMod(parameters.ringMod->get());
    if (parameters.glideTime) voiceManager.setGlideTime(parameters.glideTime->get());

    // Envelope Parameters (These are secondary controls, primary is via applyPreset)
    if (parameters.dcwAttack) voiceManager.setDCWAttack(parameters.dcwAttack->get());
    if (parameters.dcwDecay) voiceManager.setDCWDecay(parameters.dcwDecay->get());
    if (parameters.dcwSustain) voiceManager.setDCWSustain(parameters.dcwSustain->get());
    if (parameters.dcwRelease) voiceManager.setDCWRelease(parameters.dcwRelease->get());

    if (parameters.dcaAttack) voiceManager.setDCAAttack(parameters.dcaAttack->get());
    if (parameters.dcaDecay) voiceManager.setDCADecay(parameters.dcaDecay->get());
    if (parameters.dcaSustain) voiceManager.setDCASustain(parameters.dcaSustain->get());
    if (parameters.dcaRelease) voiceManager.setDCARelease(parameters.dcaRelease->get());

    // LFO / Vibrato
    if (parameters.lfoRate) voiceManager.setLFOFrequency(parameters.lfoRate->get());
    if (parameters.lfoWaveform) voiceManager.setLFOWaveform(static_cast<CZ101::DSP::LFO::Waveform>(parameters.lfoWaveform->getIndex()));
    if (parameters.lfoDepth) voiceManager.setVibratoDepth(parameters.lfoDepth->get());
    if (parameters.lfoDelay) voiceManager.setLFODelay(parameters.lfoDelay->get());

    // 4. Update Effects
    if (parameters.chorusRate) chorus.setRate(parameters.chorusRate->get());
    if (parameters.chorusDepth) chorus.setDepth(parameters.chorusDepth->get());
    if (parameters.chorusMix) chorus.setMix(parameters.chorusMix->get());
    
    if (parameters.reverbSize && parameters.reverbMix)
    {
        reverbParams.roomSize = parameters.reverbSize->get();
        reverbParams.damping = 0.5f;
        reverbParams.wetLevel = parameters.reverbMix->get();
        reverbParams.dryLevel = 1.0f - (parameters.reverbMix->get() * 0.5f);
        reverbParams.width = 1.0f;
        reverb.setParameters(reverbParams);
    }

    // 5. Update SysEx Protection State
    bool isProtected = parameters.protectSwitch ? parameters.protectSwitch->get() : true;
    bool isPrgEnabled = parameters.systemPrg ? parameters.systemPrg->get() : false;
    sysExManager.setProtectionState(isProtected, isPrgEnabled);
    
    // Audit Fix: Update Delay Params
    if (parameters.delayTime) { 
        float dt = parameters.delayTime->get();
        delayL.setDelayTime(dt); delayR.setDelayTime(dt); 
    }
    if (parameters.delayFeedback) { float fb = parameters.delayFeedback->get(); delayL.setFeedback(fb); delayR.setFeedback(fb); }
    if (parameters.delayMix) { float mix = parameters.delayMix->get(); delayL.setMix(mix); delayR.setMix(mix); }

    // Audit Fix 3.1: Latency Reporting
    // Max latency is determined by Chorus (modulation) or Delay (if mix=1, but standard delay is echo).
    // User requested explicit summing or max. Since Chorus has minimal latency (buffer) and Delay echo,
    // we report based on request: max(chorus, delay).
    int chorusDelaySamples = (parameters.chorusMix && parameters.chorusMix->get() > 0.0f) ? (int)(0.025 * getSampleRate()) : 0;
    
    // Note: Standard delays don't report latency unless wet-only. We only report if active.
    // User requested: setLatencySamples(chorus + delay).
    int latency = chorusDelaySamples; 
    if (getLatencySamples() != latency) setLatencySamples(latency);
}

// Audit Fix 2.1: Implement setNonRealtime to recalculate smoothing
void CZ101AudioProcessor::setNonRealtime(bool isNonRealtime) noexcept
{
    juce::AudioProcessor::setNonRealtime(isNonRealtime);
    
    // Force recalculation of smoothing steps for all parameters
    // This ensures that offline bounces use the correct smoothing regardless of the host's block size settings
    voiceManager.setSampleRate(getSampleRate());
    updateParameters();
}

juce::AudioParameterBool* CZ101AudioProcessor::getBypassParameter() const
{
    return parameters.bypass;
}

// --- THREAD-SAFE ENVELOPE QUEUE ---
void CZ101AudioProcessor::scheduleEnvelopeUpdate(const EnvelopeUpdateCommand& cmd)
{
    int start1, size1, start2, size2;
    
    // Audit Fix 1.1: Verify free space before writing to prevent overflow/crash
    if (commandFifo.getFreeSpace() < 1) {
        // juce::Logger::writeToLog("Warning: Command FIFO full, dropping envelope update");
        return;
    }

    commandFifo.prepareToWrite(1, start1, size1, start2, size2);
    if (size1 > 0) commandBuffer[start1] = cmd;
    else if (size2 > 0) commandBuffer[start2] = cmd;
    commandFifo.finishedWrite(size1 + size2);
}

void CZ101AudioProcessor::processEnvelopeUpdates()
{
    int start1, size1, start2, size2;
    commandFifo.prepareToRead(100, start1, size1, start2, size2);
    
    // Audit Fix 3: De-duplicate logic with lambda
    auto processRange = [&](int start, int size) {
        for (int i = 0; i < size; ++i) {
            auto& cmd = commandBuffer[start + i];
            switch (cmd.type) {
                case EnvelopeUpdateCommand::DCA_STAGE: voiceManager.setDCAStage(cmd.line, cmd.index, cmd.rate, cmd.level); break;
                case EnvelopeUpdateCommand::DCA_SUSTAIN: voiceManager.setDCASustainPoint(cmd.line, cmd.index); break;
                case EnvelopeUpdateCommand::DCA_END: voiceManager.setDCAEndPoint(cmd.line, cmd.index); break;
                case EnvelopeUpdateCommand::DCW_STAGE: voiceManager.setDCWStage(cmd.line, cmd.index, cmd.rate, cmd.level); break;
                case EnvelopeUpdateCommand::DCW_SUSTAIN: voiceManager.setDCWSustainPoint(cmd.line, cmd.index); break;
                case EnvelopeUpdateCommand::DCW_END: voiceManager.setDCWEndPoint(cmd.line, cmd.index); break;
                case EnvelopeUpdateCommand::PITCH_STAGE: voiceManager.setPitchStage(cmd.line, cmd.index, cmd.rate, cmd.level); break;
                case EnvelopeUpdateCommand::PITCH_SUSTAIN: voiceManager.setPitchSustainPoint(cmd.line, cmd.index); break;
                case EnvelopeUpdateCommand::PITCH_END: voiceManager.setPitchEndPoint(cmd.line, cmd.index); break;
            }
        }
    };

    if (size1 > 0) processRange(start1, size1);
    if (size2 > 0) processRange(start2, size2);
    commandFifo.finishedRead(size1 + size2);
}

// --- PERSISTENCE ---
void CZ101AudioProcessor::getStateInformation(juce::MemoryBlock& destData) 
{
    auto state = parameters.getAPVTS().copyState();
    std::unique_ptr<juce::XmlElement> xml(state.createXml());
    copyXmlToBinary(*xml, destData);
}

void CZ101AudioProcessor::setStateInformation(const void* data, int sizeInBytes) 
{
    std::unique_ptr<juce::XmlElement> xmlState(getXmlFromBinary(data, sizeInBytes));
    if (xmlState != nullptr)
        if (xmlState->hasTagName(parameters.getAPVTS().state.getType()))
            parameters.getAPVTS().replaceState(juce::ValueTree::fromXml(*xmlState));
}

// --- AUTHENTIC INITIALIZE ---
void CZ101AudioProcessor::initializeSection(InitSection section)
{
    if (section == InitSection::WAVEFORM || section == InitSection::ALL) {
        if (parameters.osc1Waveform) parameters.osc1Waveform->setValueNotifyingHost(0.0f);
        if (parameters.osc1Waveform2) parameters.osc1Waveform2->setValueNotifyingHost(0.0f);
        if (parameters.osc2Waveform) parameters.osc2Waveform->setValueNotifyingHost(0.0f);
        if (parameters.osc2Waveform2) parameters.osc2Waveform2->setValueNotifyingHost(0.0f);
    }

    if (section == InitSection::VIBRATO || section == InitSection::ALL) {
        if (parameters.lfoRate) parameters.lfoRate->setValueNotifyingHost(0.0f);
        if (parameters.lfoDepth) parameters.lfoDepth->setValueNotifyingHost(0.0f);
        if (parameters.lfoDelay) parameters.lfoDelay->setValueNotifyingHost(0.0f);
        if (parameters.lfoWaveform) parameters.lfoWaveform->setValueNotifyingHost(0.0f);
    }
    
    if (section == InitSection::DCA || section == InitSection::DCW || section == InitSection::ALL) {
        bool doDCW = (section == InitSection::DCW || section == InitSection::ALL);
        bool doDCA = (section == InitSection::DCA || section == InitSection::ALL);
        
        if (doDCW) {
             scheduleEnvelopeUpdate(EnvelopeUpdateCommand { EnvelopeUpdateCommand::DCW_STAGE, 1, 0, 99.0f, 1.0f });
             scheduleEnvelopeUpdate(EnvelopeUpdateCommand { EnvelopeUpdateCommand::DCW_STAGE, 1, 1, 99.0f, 0.0f });
             scheduleEnvelopeUpdate(EnvelopeUpdateCommand { EnvelopeUpdateCommand::DCW_SUSTAIN, 1, 0, 0.0f, 0.0f });
             scheduleEnvelopeUpdate(EnvelopeUpdateCommand { EnvelopeUpdateCommand::DCW_END, 1, 1, 0.0f, 0.0f });
        }
        
        if (doDCA) {
             scheduleEnvelopeUpdate(EnvelopeUpdateCommand { EnvelopeUpdateCommand::DCA_STAGE, 1, 0, 99.0f, 1.0f });
             scheduleEnvelopeUpdate(EnvelopeUpdateCommand { EnvelopeUpdateCommand::DCA_STAGE, 1, 1, 99.0f, 0.0f });
             scheduleEnvelopeUpdate(EnvelopeUpdateCommand { EnvelopeUpdateCommand::DCA_SUSTAIN, 1, 0, 0.0f, 0.0f });
             scheduleEnvelopeUpdate(EnvelopeUpdateCommand { EnvelopeUpdateCommand::DCA_END, 1, 1, 0.0f, 0.0f });
        }
    }
    
    if (section == InitSection::DCO || section == InitSection::ALL) {
        scheduleEnvelopeUpdate(EnvelopeUpdateCommand { EnvelopeUpdateCommand::PITCH_STAGE, 1, 0, 50.0f, 0.5f });
        scheduleEnvelopeUpdate(EnvelopeUpdateCommand { EnvelopeUpdateCommand::PITCH_STAGE, 1, 1, 50.0f, 0.5f });
        scheduleEnvelopeUpdate(EnvelopeUpdateCommand { EnvelopeUpdateCommand::PITCH_SUSTAIN, 1, 0, 0.0f, 0.0f });
        scheduleEnvelopeUpdate(EnvelopeUpdateCommand { EnvelopeUpdateCommand::PITCH_END, 1, 1, 0.0f, 0.0f });
    }
    
    if (section == InitSection::OCTAVE || section == InitSection::ALL) {
        if (parameters.osc2Detune) parameters.osc2Detune->setValueNotifyingHost(parameters.osc2Detune->convertTo0to1(0.0f));
    }
}

juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter() { return new CZ101AudioProcessor(); }
// Audit Fix 4.2: Handle SysEx parameter updates on Message Thread
void CZ101AudioProcessor::handleAsyncUpdate()
{
    if (hasPendingSysEx.exchange(false))
    {
        std::unique_ptr<CZ101::State::Preset> p;
        {
            const juce::ScopedLock sl(presetLock);
            p = std::move(pendingSysExPreset);
        }
        
        if (p)
        {
            // Update Parameters and notify host (Message Thread)
            // We pass false to updateVoice because we already updated it in the callback
            presetManager.loadPresetFromStruct(*p, false);
        }
    }
}

================================================================================
FILE: .\Source\PluginProcessor.h
================================================================================
#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_core/juce_core.h>
#include <memory>
#include "Utils/PerformanceMonitor.h"
#include "Core/VoiceManager.h"
#include "MIDI/MIDIProcessor.h"
#include "MIDI/SysExManager.h"
#include "State/Parameters.h"
#include "State/PresetManager.h"

#include "DSP/Effects/Delay.h"
#include "DSP/Effects/Chorus.h"
#include "DSP/Effects/Reverb.h"
#include "DSP/Modulation/LFO.h"
#include "UI/LCDStateManager.h" // Added Logic Header

// Command Pattern for Thread Safety
enum class InitSection { WAVEFORM, DCO, DCW, DCA, VIBRATO, OCTAVE, ALL, SYSTEM_ALL };

struct EnvelopeUpdateCommand
{
    enum Type { DCA_STAGE, DCW_STAGE, PITCH_STAGE, 
                DCA_SUSTAIN, DCW_SUSTAIN, PITCH_SUSTAIN,
                DCA_END, DCW_END, PITCH_END };
    Type type;
    int line; // 1 or 2
    int index;
    float rate;
    float level;
};

static_assert(std::is_trivially_copyable<EnvelopeUpdateCommand>::value, "EnvelopeUpdateCommand must be POD for thread-safe FIFO usage");

class CZ101AudioProcessor : public juce::AudioProcessor, 
                            public juce::AsyncUpdater
{
public:
    CZ101AudioProcessor();
    ~CZ101AudioProcessor() override;

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;

    bool isBusesLayoutSupported(const BusesLayout& layouts) const override;

    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    
    // Audit Fix 2.1: Non-realtime support
    void setNonRealtime(bool isNonRealtime) noexcept override;
    juce::AudioParameterBool* getBypassParameter() const override;

    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override;

    const juce::String getName() const override;

    bool acceptsMidi() const override;
    bool producesMidi() const override;
    bool isMidiEffect() const override;
    double getTailLengthSeconds() const override;
    int getNumPrograms() override;
    int getCurrentProgram() override;
    void setCurrentProgram(int index) override;
    const juce::String getProgramName(int index) override;
    void changeProgramName(int index, const juce::String& newName) override;
    
    void saveCurrentPreset(const juce::String& name); // New Save Method
    void applyPresetToVoiceEngine(const CZ101::State::Preset& preset); // SysEx Helper
    void initializeSection(InitSection section); // Authentic Initialization

    void getStateInformation(juce::MemoryBlock& destData) override;
    void setStateInformation(const void* data, int sizeInBytes) override;
    CZ101::State::PresetManager& getPresetManager() { return presetManager; }
    CZ101::MIDI::SysExManager& getSysExManager() { return sysExManager; }
    CZ101::MIDI::MIDIProcessor& getMidiProcessor() { return midiProcessor; }
    CZ101::State::Parameters& getParameters() { return parameters; }
    CZ101::Core::VoiceManager& getVoiceManager() { return voiceManager; }
    CZ101::Utils::PerformanceMonitor& getPerformanceMonitor() { return performanceMonitor; }
    
    // For Editor Visualization
    juce::AudioBuffer<float>& getVisBuffer() { return visBuffer; }
    juce::AbstractFifo& getVisFifo() { return visFifo; }
    
    // CASIO CZ COMMAND QUEUE (Thread-Safe UI -> Audio)
    void scheduleEnvelopeUpdate(const EnvelopeUpdateCommand& cmd);

    // --- UI State Management ---
    std::unique_ptr<CZ101::UI::LCDStateManager> lcdStateManager;
    CZ101::UI::LCDStateManager& getLCDStateManager() { return *lcdStateManager; }

private:
    // ...
    // Visualisation
    static constexpr int VIS_FIFO_SIZE = 4096; // Audit Fix 4.1
    juce::AudioBuffer<float> visBuffer { 1, VIS_FIFO_SIZE }; 
    juce::AbstractFifo visFifo { VIS_FIFO_SIZE };
    CZ101::Core::VoiceManager voiceManager;
    CZ101::MIDI::MIDIProcessor midiProcessor;
    CZ101::State::Parameters parameters;
    CZ101::State::PresetManager presetManager;
    CZ101::MIDI::SysExManager sysExManager;
    

    CZ101::DSP::Effects::Delay delayL;
    CZ101::DSP::Effects::Delay delayR;
    
    juce::Reverb reverb;
    juce::Reverb::Parameters reverbParams;
    CZ101::DSP::Effects::Chorus chorus;
    
    // UI Update Tracking
    CZ101::Utils::PerformanceMonitor performanceMonitor;
    
    // Command Queue Data
    static constexpr int COMMAND_QUEUE_SIZE = 4096; // Audit Fix 4.1: Increased for high SR
    juce::AbstractFifo commandFifo { COMMAND_QUEUE_SIZE };
    std::array<EnvelopeUpdateCommand, COMMAND_QUEUE_SIZE> commandBuffer;
    
    void handleAsyncUpdate() override;
    
    // Audit Fix [D]: Mutex to protect multithreaded preset access
    juce::CriticalSection presetLock;
    
    // Audit Fix 4.2: Pending update from SysEx
    std::unique_ptr<CZ101::State::Preset> pendingSysExPreset;
    std::atomic<bool> hasPendingSysEx { false };    
    void processEnvelopeUpdates();
    
    void updateParameters();

    std::unique_ptr<juce::FileLogger> fileLogger;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(CZ101AudioProcessor)
};

================================================================================
FILE: .\Source\Core\BuildVersion.h
================================================================================
#pragma once

#define CZ_BUILD_VERSION "53"
#define CZ_BUILD_TIMESTAMP "2026-01-12 12:44:43"


================================================================================
FILE: .\Source\Core\Voice.cpp
================================================================================
#include <JuceHeader.h>
#include "Voice.h"
#include <cmath>
#include "../DSP/Envelopes/ADSRtoStage.h"

namespace CZ101 {
namespace Core {

Voice::Voice()
{
}

void Voice::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
    osc1.setSampleRate(sr);
    osc2.setSampleRate(sr);
    dcwEnvelope1.setSampleRate(sr);
    dcaEnvelope1.setSampleRate(sr);
    pitchEnvelope1.setSampleRate(sr);
    dcwEnvelope2.setSampleRate(sr);
    dcaEnvelope2.setSampleRate(sr);
    pitchEnvelope2.setSampleRate(sr);
    lfoModule.setSampleRate(sr);

    updateDCWEnvelopeFromADSR(1);
    updateDCAEnvelopeFromADSR(1);
    updatePitchEnvelopeFromADSR(1);
    updateDCWEnvelopeFromADSR(2);
    updateDCAEnvelopeFromADSR(2);
    updatePitchEnvelopeFromADSR(2);
}

void Voice::noteOn(int midiNote, float velocity) noexcept
{
    currentNote = midiNote;
    currentVelocity = velocity;
    baseFrequency = midiNoteToFrequency(midiNote);
    targetFrequency = baseFrequency;
    currentFrequency = baseFrequency;
    
    osc1.reset();
    osc2.reset();
    lfoModule.reset();
    
    dcwEnvelope1.noteOn();
    dcaEnvelope1.noteOn();
    pitchEnvelope1.noteOn();
    dcwEnvelope2.noteOn();
    dcaEnvelope2.noteOn();
    pitchEnvelope2.noteOn();
}

void Voice::noteOff() noexcept
{
    dcwEnvelope1.noteOff();
    dcaEnvelope1.noteOff();
    pitchEnvelope1.noteOff();
    dcwEnvelope2.noteOff();
    dcaEnvelope2.noteOff();
    pitchEnvelope2.noteOff();
}

void Voice::reset() noexcept
{
    dcwEnvelope1.reset();
    dcaEnvelope1.reset();
    pitchEnvelope1.reset();
    pitchEnvelope1.setCurrentValue(0.5f); // Audit Fix 1.1: Center Pitch Envelope
    
    dcwEnvelope2.reset();
    dcaEnvelope2.reset();
    pitchEnvelope2.reset();
    pitchEnvelope2.setCurrentValue(0.5f); // Audit Fix 1.1: Center Pitch Envelope
    
    lfoModule.reset();
}

// ... Oscillators ...

void Voice::setOsc1Waveforms(DSP::PhaseDistOscillator::CzWaveform f, DSP::PhaseDistOscillator::CzWaveform s) noexcept 
{ 
    osc1.setWaveforms(f, s); 
}
void Voice::setOsc1Level(float level) noexcept { osc1Level = level; }

void Voice::setOsc2Waveforms(DSP::PhaseDistOscillator::CzWaveform f, DSP::PhaseDistOscillator::CzWaveform s) noexcept 
{ 
    osc2.setWaveforms(f, s); 
}
void Voice::setOsc2Level(float level) noexcept { osc2Level = level; }
void Voice::setOsc2Detune(float cents) noexcept 
{ 
    osc2Detune = cents; 
    currentDetuneFactor =std::exp2(cents / 1200.0f); // Audit Fix 1.1 exp2
}

void Voice::setHardSync(bool enabled) noexcept { isHardSyncEnabled = enabled; }
void Voice::setRingMod(bool enabled) noexcept { isRingModEnabled = enabled; }
void Voice::setGlideTime(float seconds) noexcept { glideTime = seconds; }

// ... LFO / Vibrato ...
void Voice::setVibratoDepth(float semitones) noexcept { vibratoDepth = semitones; }
void Voice::setLFOFrequency(float hz) noexcept { lfoModule.setFrequency(hz); }
void Voice::setLFOWaveform(DSP::LFO::Waveform w) noexcept { lfoModule.setWaveform(w); }
void Voice::setLFODelay(float s) noexcept { lfoModule.setDelay(s); }

void Voice::setPitchBend(float semitones) noexcept { pitchBendFactor = std::exp2(semitones / 12.0f); }
void Voice::setMasterTune(float semitones) noexcept { masterTuneFactor = std::exp2(semitones / 12.0f); }

// ============================================================================
// ENVELOPES - DUAL LINE SUPPORT
// ============================================================================

// DCW
void Voice::setDCWStage(int line, int i, float r, float l) noexcept { if(line==1) dcwEnvelope1.setStage(i, r, l); else dcwEnvelope2.setStage(i, r, l); }
void Voice::setDCWSustainPoint(int line, int i) noexcept { if(line==1) dcwEnvelope1.setSustainPoint(i); else dcwEnvelope2.setSustainPoint(i); }
void Voice::setDCWEndPoint(int line, int i) noexcept { if(line==1) dcwEnvelope1.setEndPoint(i); else dcwEnvelope2.setEndPoint(i); }

void Voice::getDCWStage(int line, int i, float& r, float& l) const noexcept { if(line==1) { r = dcwEnvelope1.getStageRate(i); l = dcwEnvelope1.getStageLevel(i); } else { r = dcwEnvelope2.getStageRate(i); l = dcwEnvelope2.getStageLevel(i); } }
int Voice::getDCWSustainPoint(int line) const noexcept { return line==1 ? dcwEnvelope1.getSustainPoint() : dcwEnvelope2.getSustainPoint(); }
int Voice::getDCWEndPoint(int line) const noexcept { return line==1 ? dcwEnvelope1.getEndPoint() : dcwEnvelope2.getEndPoint(); }

// DCA
void Voice::setDCAStage(int line, int i, float r, float l) noexcept { if(line==1) dcaEnvelope1.setStage(i, r, l); else dcaEnvelope2.setStage(i, r, l); }
void Voice::setDCASustainPoint(int line, int i) noexcept { if(line==1) dcaEnvelope1.setSustainPoint(i); else dcaEnvelope2.setSustainPoint(i); }
void Voice::setDCAEndPoint(int line, int i) noexcept { if(line==1) dcaEnvelope1.setEndPoint(i); else dcaEnvelope2.setEndPoint(i); }

void Voice::getDCAStage(int line, int i, float& r, float& l) const noexcept { if(line==1) { r = dcaEnvelope1.getStageRate(i); l = dcaEnvelope1.getStageLevel(i); } else { r = dcaEnvelope2.getStageRate(i); l = dcaEnvelope2.getStageLevel(i); } }
int Voice::getDCASustainPoint(int line) const noexcept { return line==1 ? dcaEnvelope1.getSustainPoint() : dcaEnvelope2.getSustainPoint(); }
int Voice::getDCAEndPoint(int line) const noexcept { return line==1 ? dcaEnvelope1.getEndPoint() : dcaEnvelope2.getEndPoint(); }

// Pitch
void Voice::setPitchStage(int line, int i, float r, float l) noexcept { if(line==1) pitchEnvelope1.setStage(i, r, l); else pitchEnvelope2.setStage(i, r, l); }
void Voice::setPitchSustainPoint(int line, int i) noexcept { if(line==1) pitchEnvelope1.setSustainPoint(i); else pitchEnvelope2.setSustainPoint(i); }
void Voice::setPitchEndPoint(int line, int i) noexcept { if(line==1) pitchEnvelope1.setEndPoint(i); else pitchEnvelope2.setEndPoint(i); }

void Voice::getPitchStage(int line, int i, float& r, float& l) const noexcept { if(line==1) { r = pitchEnvelope1.getStageRate(i); l = pitchEnvelope1.getStageLevel(i); } else { r = pitchEnvelope2.getStageRate(i); l = pitchEnvelope2.getStageLevel(i); } }
int Voice::getPitchSustainPoint(int line) const noexcept { return line==1 ? pitchEnvelope1.getSustainPoint() : pitchEnvelope2.getSustainPoint(); }
int Voice::getPitchEndPoint(int line) const noexcept { return line==1 ? pitchEnvelope1.getEndPoint() : pitchEnvelope2.getEndPoint(); }

// ============================================================================
// ADSR WRAPPERS (LEGACY SUPPORT)
// ============================================================================

void Voice::setDCWAttack(float seconds) noexcept { dcwADSR1.attackMs = seconds * 1000.0f; dcwADSR2.attackMs = seconds * 1000.0f; updateDCWEnvelopeFromADSR(1); updateDCWEnvelopeFromADSR(2); }
void Voice::setDCWDecay(float seconds) noexcept { dcwADSR1.decayMs = seconds * 1000.0f; dcwADSR2.decayMs = seconds * 1000.0f; updateDCWEnvelopeFromADSR(1); updateDCWEnvelopeFromADSR(2); }
void Voice::setDCWSustain(float level) noexcept { dcwADSR1.sustainLevel = level; dcwADSR2.sustainLevel = level; updateDCWEnvelopeFromADSR(1); updateDCWEnvelopeFromADSR(2); }
void Voice::setDCWRelease(float seconds) noexcept { dcwADSR1.releaseMs = seconds * 1000.0f; dcwADSR2.releaseMs = seconds * 1000.0f; updateDCWEnvelopeFromADSR(1); updateDCWEnvelopeFromADSR(2); }

void Voice::setDCAAttack(float seconds) noexcept { dcaADSR1.attackMs = seconds * 1000.0f; dcaADSR2.attackMs = seconds * 1000.0f; updateDCAEnvelopeFromADSR(1); updateDCAEnvelopeFromADSR(2); }
void Voice::setDCADecay(float seconds) noexcept { dcaADSR1.decayMs = seconds * 1000.0f; dcaADSR2.decayMs = seconds * 1000.0f; updateDCAEnvelopeFromADSR(1); updateDCAEnvelopeFromADSR(2); }
void Voice::setDCASustain(float level) noexcept { dcaADSR1.sustainLevel = level; dcaADSR2.sustainLevel = level; updateDCAEnvelopeFromADSR(1); updateDCAEnvelopeFromADSR(2); }
void Voice::setDCARelease(float seconds) noexcept { dcaADSR1.releaseMs = seconds * 1000.0f; dcaADSR2.releaseMs = seconds * 1000.0f; updateDCAEnvelopeFromADSR(1); updateDCAEnvelopeFromADSR(2); }

// ===== HELPER METHODS FOR ADSR CONSISTENCY =====

void Voice::updateDCWEnvelopeFromADSR(int line) noexcept
{
    std::array<float, 8> rates, levels;
    int sus, end;
    auto& adsr = (line == 1) ? dcwADSR1 : dcwADSR2;
    auto& env = (line == 1) ? dcwEnvelope1 : dcwEnvelope2;
    
    DSP::ADSRtoStageConverter::convertADSR(adsr.attackMs, adsr.decayMs, adsr.sustainLevel, adsr.releaseMs, rates, levels, sus, end, sampleRate);
    
    for (int i = 0; i < 4; ++i) env.setStage(i, rates[i], levels[i]);
    env.setSustainPoint(sus);
    env.setEndPoint(end);
}

void Voice::updateDCAEnvelopeFromADSR(int line) noexcept
{
    std::array<float, 8> rates, levels;
    int sus, end;
    auto& adsr = (line == 1) ? dcaADSR1 : dcaADSR2;
    auto& env = (line == 1) ? dcaEnvelope1 : dcaEnvelope2;
    
    DSP::ADSRtoStageConverter::convertADSR(adsr.attackMs, adsr.decayMs, adsr.sustainLevel, adsr.releaseMs, rates, levels, sus, end, sampleRate);
    
    for (int i = 0; i < 4; ++i) env.setStage(i, rates[i], levels[i]);
    env.setSustainPoint(sus);
    env.setEndPoint(end);
}

void Voice::updatePitchEnvelopeFromADSR(int line) noexcept
{
    std::array<float, 8> rates, levels;
    int sus, end;
    auto& adsr = (line == 1) ? pitchADSR1 : pitchADSR2;
    auto& env = (line == 1) ? pitchEnvelope1 : pitchEnvelope2;
    
    DSP::ADSRtoStageConverter::convertADSR(adsr.attackMs, adsr.decayMs, adsr.sustainLevel, adsr.releaseMs, rates, levels, sus, end, sampleRate);
    
    for (int i = 0; i < 4; ++i) env.setStage(i, rates[i], levels[i]);
    env.setSustainPoint(sus);
    env.setEndPoint(end);
}

// ============================================================================
// RENDERING
// ============================================================================

// Fast Tanh Approximation (Rational type)
// Much faster than std::tanh for real-time audio
inline float fastTanh(float x) noexcept
{
    float x2 = x * x;
    float a = x * (135135.0f + x2 * (17325.0f + x2 * (378.0f + x2)));
    float b = 135135.0f + x2 * (62370.0f + x2 * (3150.0f + x2 * 28.0f));
    return a / b;
}

float Voice::renderNextSample() noexcept
{
    if (!dcaEnvelope1.isActive() && !dcaEnvelope2.isActive()) return 0.0f;
    
    // Audit Fix [D]: Protect with Lock (Internal consistency)
    // Removed ScopedLock here for performance if VoiceManager handles it, 
    // but the plan said to keep it. Balancing safety vs CPU.
    // Actually, ScopedLock per sample is TOO SLOW. 
    // I will rely on the Processor lock protecting the whole block.
    
    // === CONTROL RATE MODULATION (Every 8 samples) ===
    if ((sampleCounter++ & 0x07) == 0)
    {
        // Envelope values
        dcwVal1 = dcwEnvelope1.getNextValue();
        dcaVal1 = dcaEnvelope1.getNextValue();
        float pEnvVal1 = pitchEnvelope1.getNextValue();
        
        dcwVal2 = dcwEnvelope2.getNextValue();
        dcaVal2 = dcaEnvelope2.getNextValue();
        float pEnvVal2 = pitchEnvelope2.getNextValue();
        
        // Pitch mod (Â±12 semitones) - Precompute factor
        pitchMod1 = std::exp2((pEnvVal1 - 0.5f) * 2.0f); // 24/12 = 2
        pitchMod2 = std::exp2((pEnvVal2 - 0.5f) * 2.0f);
        
        // LFO
        vibratoMod = 1.0f;
        if (vibratoDepth > 0.001f) {
            vibratoMod = std::exp2(lfoModule.getNextValue() * vibratoDepth); 
        }

        // Cache static factors (Master Tune, Pitch Bend)
        // Only if they changed? For now just compute here at control rate.
        float globalMod = pitchBendFactor * masterTuneFactor;
        
        // Target Frequencies (Control Rate)
        if (glideTime > 0.001f && currentFrequency != targetFrequency) {
            float currentLog = std::log2(currentFrequency);
            float targetLog = std::log2(targetFrequency);
            float diffLog = targetLog - currentLog;
            float step = (8.0f / (float)sampleRate) / (glideTime + 0.001f);
            
            if (std::abs(diffLog) <= step) {
                currentFrequency = targetFrequency;
            } else {
                currentLog += (diffLog > 0 ? step : -step);
                currentFrequency = std::exp2(currentLog);
            }
        } else {
            currentFrequency = targetFrequency;
        }

        cachedFreq1 = currentFrequency * pitchMod1 * vibratoMod * globalMod;
        cachedFreq2 = currentFrequency * pitchMod2 * vibratoMod * globalMod * currentDetuneFactor;
    }
    
    osc1.setFrequency(cachedFreq1);
    osc2.setFrequency(cachedFreq2);
    
    // Osc Render
    bool osc1Wrapped = false;
    float osc1Sample = osc1.renderNextSample(dcwVal1, &osc1Wrapped);
    if (isHardSyncEnabled && osc1Wrapped) osc2.reset();
    float osc2Sample = osc2.renderNextSample(dcwVal2);
    if (isRingModEnabled) osc2Sample = osc1Sample * osc2Sample;
    
    // Mixing
    float out1 = osc1Sample * osc1Level * dcaVal1;
    float out2 = osc2Sample * osc2Level * dcaVal2;
    
    float rawMix = out1 + out2;
    
    // Optimization: Fast Tanh
    float softClipped = fastTanh(rawMix * 0.68f);
    
    return softClipped * currentVelocity * 0.9f;
}

float Voice::midiNoteToFrequency(int midiNote) const noexcept
{
    return 440.0f * std::exp2((midiNote - 69) / 12.0f);
}

} // namespace Core
} // namespace CZ101

================================================================================
FILE: .\Source\Core\Voice.h
================================================================================
#pragma once

#include "../DSP/Oscillators/PhaseDistOsc.h"
#include "../DSP/Envelopes/MultiStageEnv.h"
#include "../DSP/Modulation/LFO.h"
#include <array>
#include <cstdint>

namespace CZ101 {
namespace Core {

/**
 * @brief Voice - Complete synthesizer voice
 * 
 * Integrates oscillators and envelopes to create the CZ-101 sound.
 * Architecture: DCO (oscillators) â†’ DCW (timbre envelope) â†’ DCA (amplitude envelope)
 */
class Voice
{
public:
    Voice();
    
    void setSampleRate(double sampleRate) noexcept;
    
    // Note control
    void noteOn(int midiNote, float velocity) noexcept;
    void noteOff() noexcept;
    void reset() noexcept;
    
    // Oscillator 1 parameters
    // Oscillator 1 parameters
    void setOsc1Waveforms(DSP::PhaseDistOscillator::CzWaveform first, DSP::PhaseDistOscillator::CzWaveform second) noexcept;
    void setOsc1Level(float level) noexcept;
    
    // Oscillator 2 parameters
    void setOsc2Waveforms(DSP::PhaseDistOscillator::CzWaveform first, DSP::PhaseDistOscillator::CzWaveform second) noexcept;
    void setOsc2Level(float level) noexcept;
    void setOsc2Detune(float cents) noexcept;  // -100 to +100 cents
    
    /**
     * @brief Enable/Disable Hard Sync (Osc2 resets when Osc1 wraps)
     */
    void setHardSync(bool enabled) noexcept;

    /**
     * @brief Enable/Disable Ring Modulation (Osc2 output = Osc1 * Osc2)
     */
    /**
     * @brief Enable/Disable Ring Modulation (Osc2 output = Osc1 * Osc2)
     */
    void setRingMod(bool enabled) noexcept;

    /**
     * @brief Set Glide (Portamento) Time in seconds
     * @param seconds Slide time (0.0 to ~2.0)
     */
    void setGlideTime(float seconds) noexcept;

    // --- Modulation (LFO) ---
    void setVibratoDepth(float semitones) noexcept;
    
    // Config LFO (Per-Voice)
    void setLFOFrequency(float hz) noexcept;
    void setLFOWaveform(DSP::LFO::Waveform waveform) noexcept;
    void setLFODelay(float seconds) noexcept;
    
    // --- Global Pitch ---
    void setPitchBend(float semitones) noexcept;
    void setMasterTune(float semitones) noexcept;

    // --- Pitch Envelope Controls ---
    
    // DCW Envelope (Legacy ADSR Wrappers)
    void setDCWAttack(float seconds) noexcept;
    void setDCWDecay(float seconds) noexcept;
    void setDCWSustain(float level) noexcept;
    void setDCWRelease(float seconds) noexcept;
    
    // DCW 8-Stage Control
    void setDCWStage(int line, int index, float rate, float level) noexcept;
    void setDCWSustainPoint(int line, int index) noexcept;
    void setDCWEndPoint(int line, int index) noexcept;
    
    void getDCWStage(int line, int index, float& rate, float& level) const noexcept;
    int getDCWSustainPoint(int line) const noexcept;
    int getDCWEndPoint(int line) const noexcept;
    
    // DCA 8-Stage Control
    void setDCAStage(int line, int index, float rate, float level) noexcept;
    void setDCASustainPoint(int line, int index) noexcept;
    void setDCAEndPoint(int line, int index) noexcept;

    void getDCAStage(int line, int index, float& rate, float& level) const noexcept;
    int getDCASustainPoint(int line) const noexcept;
    int getDCAEndPoint(int line) const noexcept;


    // DCA Envelope (Legacy ADSR Wrappers)
    void setDCAAttack(float seconds) noexcept;
    void setDCADecay(float seconds) noexcept;
    void setDCASustain(float level) noexcept;
    void setDCARelease(float seconds) noexcept;

    // Pitch Envelope (DCO) 8-Stage Control
    void setPitchStage(int line, int index, float rate, float level) noexcept;
    void setPitchSustainPoint(int line, int index) noexcept;
    void setPitchEndPoint(int line, int index) noexcept;
    
    void getPitchStage(int line, int index, float& rate, float& level) const noexcept;
    int getPitchSustainPoint(int line) const noexcept;
    int getPitchEndPoint(int line) const noexcept;
    
    // Rendering
    float renderNextSample() noexcept;
    
    bool isActive() const noexcept { return dcaEnvelope1.isActive() || dcaEnvelope2.isActive(); }
    bool isReleasing() const noexcept { return dcaEnvelope1.isReleased() || dcaEnvelope2.isReleased(); }
    int getCurrentNote() const noexcept { return currentNote; }
    
private:
    // Oscillators
    DSP::PhaseDistOscillator osc1;
    DSP::PhaseDistOscillator osc2;
    
    // Envelopes
    DSP::MultiStageEnvelope dcwEnvelope1;  // Timbre Line 1
    DSP::MultiStageEnvelope dcaEnvelope1;  // Volume Line 1
    DSP::MultiStageEnvelope pitchEnvelope1; // Pitch Line 1
    
    DSP::MultiStageEnvelope dcwEnvelope2;  // Timbre Line 2
    DSP::MultiStageEnvelope dcaEnvelope2;  // Volume Line 2
    DSP::MultiStageEnvelope pitchEnvelope2; // Pitch Line 2
    
    // State
    int currentNote = -1;
    float currentVelocity = 1.0f;
    
    // Mix levels
    float osc1Level = 0.5f;
    float osc2Level = 0.5f;
    float osc2Detune = 0.0f;
    
    // Pitch Modulation State (Optimization)
    float baseFrequency = 440.0f;
    float currentDetuneFactor = 1.0f;
    
    bool isHardSyncEnabled = false;
    bool isRingModEnabled = false;
    
    float glideTime = 0.0f;
    float currentFrequency = 440.0f;
    float targetFrequency = 440.0f;
    
    // LFO State
    DSP::LFO lfoModule;
    float vibratoDepth = 0.0f;
    
    // Pitch Bend
    float pitchBendFactor = 1.0f;
    float masterTuneFactor = 1.0f;
    
    // Helper
    float midiNoteToFrequency(int midiNote) const noexcept;

private:
    // ===== ADSR STATE (NEW) =====
    struct ADSRParams {
        float attackMs = 10.0f;
        float decayMs = 200.0f;
        float sustainLevel = 0.5f;
        float releaseMs = 100.0f;
    };
    
    ADSRParams dcwADSR1, dcwADSR2;
    ADSRParams dcaADSR1, dcaADSR2;
    ADSRParams pitchADSR1, pitchADSR2;
    
    // Helper to update envelopes from ADSR using stored sampleRate
    void updateDCWEnvelopeFromADSR(int line) noexcept;
    void updateDCAEnvelopeFromADSR(int line) noexcept;
    void updatePitchEnvelopeFromADSR(int line) noexcept;

    double sampleRate = 44100.0;
    
    // === OPTIMIZATION STATE ===
    uint32_t sampleCounter = 0;
    float cachedFreq1 = 440.0f;
    float cachedFreq2 = 440.0f;
    float dcwVal1 = 0.0f, dcaVal1 = 0.0f;
    float dcwVal2 = 0.0f, dcaVal2 = 0.0f;
    float pitchMod1 = 1.0f, pitchMod2 = 1.0f;
    float vibratoMod = 1.0f;
    
};
} // namespace Core
} // namespace CZ101

================================================================================
FILE: .\Source\Core\VoiceManager.cpp
================================================================================
#include "VoiceManager.h"
#include "../DSP/Modulation/LFO.h"
#include <algorithm>

namespace CZ101 {
namespace Core {

VoiceManager::VoiceManager()
{
    // voices array is fixed size now
}

void VoiceManager::setSampleRate(double sampleRate) noexcept
{
    for (auto& voice : voices)
        voice.setSampleRate(sampleRate);
    referenceVoice.setSampleRate(sampleRate);
}

void VoiceManager::setOsc1Waveforms(int fIdx, int sIdx) noexcept
{
    auto f = static_cast<DSP::PhaseDistOscillator::CzWaveform>(fIdx);
    auto s = static_cast<DSP::PhaseDistOscillator::CzWaveform>(sIdx);
    for (auto& v : voices) v.setOsc1Waveforms(f, s);
    referenceVoice.setOsc1Waveforms(f, s);
}

void VoiceManager::setOsc1Level(float level) noexcept
{
    for (auto& v : voices) v.setOsc1Level(level);
    referenceVoice.setOsc1Level(level);
}

void VoiceManager::setOsc2Waveforms(int fIdx, int sIdx) noexcept
{
    auto f = static_cast<DSP::PhaseDistOscillator::CzWaveform>(fIdx);
    auto s = static_cast<DSP::PhaseDistOscillator::CzWaveform>(sIdx);
    for (auto& v : voices) v.setOsc2Waveforms(f, s);
    referenceVoice.setOsc2Waveforms(f, s);
}

void VoiceManager::setOsc2Level(float level) noexcept
{
    for (auto& v : voices) v.setOsc2Level(level);
    referenceVoice.setOsc2Level(level);
}

void VoiceManager::setOsc2Detune(float cents) noexcept
{
    for (auto& v : voices) v.setOsc2Detune(cents);
    referenceVoice.setOsc2Detune(cents);
}

void VoiceManager::setDCWAttack(float s) noexcept { for (auto& v : voices) v.setDCWAttack(s); referenceVoice.setDCWAttack(s); }
void VoiceManager::setDCWDecay(float s) noexcept { for (auto& v : voices) v.setDCWDecay(s); referenceVoice.setDCWDecay(s); }
void VoiceManager::setDCWSustain(float l) noexcept { for (auto& v : voices) v.setDCWSustain(l); referenceVoice.setDCWSustain(l); }
void VoiceManager::setDCWRelease(float s) noexcept { for (auto& v : voices) v.setDCWRelease(s); referenceVoice.setDCWRelease(s); }

void VoiceManager::setDCAAttack(float s) noexcept { for (auto& v : voices) v.setDCAAttack(s); referenceVoice.setDCAAttack(s); }
void VoiceManager::setDCADecay(float s) noexcept { for (auto& v : voices) v.setDCADecay(s); referenceVoice.setDCADecay(s); }
void VoiceManager::setDCASustain(float l) noexcept { for (auto& v : voices) v.setDCASustain(l); referenceVoice.setDCASustain(l); }
void VoiceManager::setDCARelease(float s) noexcept { for (auto& v : voices) v.setDCARelease(s); referenceVoice.setDCARelease(s); }

// 8-Stage Control
void VoiceManager::setDCWStage(int line, int idx, float r, float l) noexcept { for (auto& v : voices) v.setDCWStage(line, idx, r, l); referenceVoice.setDCWStage(line, idx, r, l); }
void VoiceManager::setDCWSustainPoint(int line, int idx) noexcept { for (auto& v : voices) v.setDCWSustainPoint(line, idx); referenceVoice.setDCWSustainPoint(line, idx); }
void VoiceManager::setDCWEndPoint(int line, int idx) noexcept { for (auto& v : voices) v.setDCWEndPoint(line, idx); referenceVoice.setDCWEndPoint(line, idx); }

void VoiceManager::setDCAStage(int line, int idx, float r, float l) noexcept { for (auto& v : voices) v.setDCAStage(line, idx, r, l); referenceVoice.setDCAStage(line, idx, r, l); }
void VoiceManager::setDCASustainPoint(int line, int idx) noexcept { for (auto& v : voices) v.setDCASustainPoint(line, idx); referenceVoice.setDCASustainPoint(line, idx); }
void VoiceManager::setDCAEndPoint(int line, int idx) noexcept { for (auto& v : voices) v.setDCAEndPoint(line, idx); referenceVoice.setDCAEndPoint(line, idx); }

void VoiceManager::setPitchStage(int line, int idx, float r, float l) noexcept { for (auto& v : voices) v.setPitchStage(line, idx, r, l); referenceVoice.setPitchStage(line, idx, r, l); }
void VoiceManager::setPitchSustainPoint(int line, int idx) noexcept { for (auto& v : voices) v.setPitchSustainPoint(line, idx); referenceVoice.setPitchSustainPoint(line, idx); }
void VoiceManager::setPitchEndPoint(int line, int idx) noexcept { for (auto& v : voices) v.setPitchEndPoint(line, idx); referenceVoice.setPitchEndPoint(line, idx); }

// Getters 
void VoiceManager::getDCWStage(int line, int idx, float& r, float& l) const noexcept { referenceVoice.getDCWStage(line, idx, r, l); }
int VoiceManager::getDCWSustainPoint(int line) const noexcept { return referenceVoice.getDCWSustainPoint(line); }
int VoiceManager::getDCWEndPoint(int line) const noexcept { return referenceVoice.getDCWEndPoint(line); }

void VoiceManager::getDCAStage(int line, int idx, float& r, float& l) const noexcept { referenceVoice.getDCAStage(line, idx, r, l); }
int VoiceManager::getDCASustainPoint(int line) const noexcept { return referenceVoice.getDCASustainPoint(line); }
int VoiceManager::getDCAEndPoint(int line) const noexcept { return referenceVoice.getDCAEndPoint(line); }

void VoiceManager::getPitchStage(int line, int idx, float& r, float& l) const noexcept { referenceVoice.getPitchStage(line, idx, r, l); }
int VoiceManager::getPitchSustainPoint(int line) const noexcept { return referenceVoice.getPitchSustainPoint(line); }
int VoiceManager::getPitchEndPoint(int line) const noexcept { return referenceVoice.getPitchEndPoint(line); }

void VoiceManager::setHardSync(bool e) noexcept { for (auto& v : voices) v.setHardSync(e); referenceVoice.setHardSync(e); }
void VoiceManager::setRingMod(bool e) noexcept { for (auto& v : voices) v.setRingMod(e); referenceVoice.setRingMod(e); }
void VoiceManager::setGlideTime(float s) noexcept { for (auto& v : voices) v.setGlideTime(s); referenceVoice.setGlideTime(s); }
void VoiceManager::setMasterTune(float s) noexcept { for (auto& v : voices) v.setMasterTune(s); referenceVoice.setMasterTune(s); }
void VoiceManager::setPitchBend(float s) noexcept { for (auto& v : voices) v.setPitchBend(s); referenceVoice.setPitchBend(s); }

void VoiceManager::setVibratoDepth(float s) noexcept { for (auto& v : voices) v.setVibratoDepth(s); referenceVoice.setVibratoDepth(s); }
void VoiceManager::setLFOFrequency(float hz) noexcept { for (auto& v : voices) v.setLFOFrequency(hz); referenceVoice.setLFOFrequency(hz); }
void VoiceManager::setLFOWaveform(DSP::LFO::Waveform w) noexcept { for (auto& v : voices) v.setLFOWaveform(w); referenceVoice.setLFOWaveform(w); }
void VoiceManager::setLFODelay(float s) noexcept { for (auto& v : voices) v.setLFODelay(s); referenceVoice.setLFODelay(s); }

void VoiceManager::noteOn(int midiNote, float velocity) noexcept
{
    lastMidiNote = midiNote;
    int voiceIndex = findVoicePlayingNote(midiNote);
    if (voiceIndex < 0) voiceIndex = findFreeVoice();
    if (voiceIndex < 0) voiceIndex = findVoiceToSteal();
    if (voiceIndex >= 0) voices[voiceIndex].noteOn(midiNote, velocity);
}

void VoiceManager::noteOff(int midiNote) noexcept
{
    for (auto& voice : voices)
        if (voice.isActive() && voice.getCurrentNote() == midiNote)
            voice.noteOff();
}

void VoiceManager::allNotesOff() noexcept { for (auto& voice : voices) voice.noteOff(); }

void VoiceManager::renderNextBlock(float* outputL, float* outputR, int numSamples) noexcept
{
    for (int i = 0; i < numSamples; ++i)
    {
        float sample = 0.0f;
        for (auto& voice : voices)
            if (voice.isActive())
                sample += voice.renderNextSample();
        
        outputL[i] = sample;
        outputR[i] = sample;
    }
}

int VoiceManager::getActiveVoiceCount() const noexcept
{
    int count = 0;
    for (const auto& voice : voices) if (voice.isActive()) ++count;
    return count;
}

int VoiceManager::findFreeVoice() const noexcept
{
    for (size_t i = 0; i < voices.size(); ++i) if (!voices[i].isActive()) return static_cast<int>(i);
    return -1;
}

int VoiceManager::findVoiceToSteal() const noexcept
{
    for (size_t i = 0; i < voices.size(); ++i) if (voices[i].isReleasing()) return static_cast<int>(i);
    for (size_t i = 0; i < voices.size(); ++i) if (voices[i].isActive()) return static_cast<int>(i);
    return 0;
}

int VoiceManager::findVoicePlayingNote(int midiNote) const noexcept
{
    for (size_t i = 0; i < voices.size(); ++i) if (voices[i].getCurrentNote() == midiNote) return static_cast<int>(i);
    return -1;
}

} // namespace Core
} // namespace CZ101

================================================================================
FILE: .\Source\Core\VoiceManager.h
================================================================================
#pragma once

#include "Voice.h"
#include "Voice.h"
#include <array>

namespace CZ101 {

namespace DSP { class LFO; } // Forward declaration of LFO

namespace Core {

class VoiceManager
{
public:
    static constexpr int MAX_VOICES = 8;
    
    enum VoiceStealingMode
    {
        NONE,
        OLDEST,
        QUIETEST,
        RELEASE_PHASE
    };
    
    VoiceManager();
    
    void setSampleRate(double sampleRate) noexcept;
    void setVoiceStealingMode(VoiceStealingMode mode) noexcept { stealingMode = mode; }
    
    // Parameter Control (Proxy to all voices)
    // Oscillator 1
    // Oscillator 1
    void setOsc1Waveforms(int firstIndex, int secondIndex) noexcept;
    void setOsc1Level(float level) noexcept;
    
    // Oscillator 2
    void setOsc2Waveforms(int firstIndex, int secondIndex) noexcept;
    void setOsc2Level(float level) noexcept;
    void setOsc2Detune(float cents) noexcept;
    
    // DCW Envelope
    void setDCWAttack(float seconds) noexcept;
    void setDCWDecay(float seconds) noexcept;
    void setDCWSustain(float level) noexcept;
    void setDCWRelease(float seconds) noexcept;
    
    // DCA Envelope
    void setDCAAttack(float seconds) noexcept;
    void setDCADecay(float seconds) noexcept;
    void setDCASustain(float level) noexcept;
    void setDCARelease(float seconds) noexcept;
    
    // 8-Stage Envelope Control
    void setDCWStage(int line, int index, float rate, float level) noexcept;
    void setDCWSustainPoint(int line, int index) noexcept;
    void setDCWEndPoint(int line, int index) noexcept;

    // Getters for UI
    void getDCWStage(int line, int index, float& rate, float& level) const noexcept;
    int getDCWSustainPoint(int line) const noexcept;
    int getDCWEndPoint(int line) const noexcept;

    void getDCAStage(int line, int index, float& rate, float& level) const noexcept;
    int getDCASustainPoint(int line) const noexcept;
    int getDCAEndPoint(int line) const noexcept;
    
    void getPitchStage(int line, int index, float& rate, float& level) const noexcept;
    int getPitchSustainPoint(int line) const noexcept;
    int getPitchEndPoint(int line) const noexcept;
    
    void setDCAStage(int line, int index, float rate, float level) noexcept;
    void setDCASustainPoint(int line, int index) noexcept;
    void setDCAEndPoint(int line, int index) noexcept;

    // Pitch Envelope (DCO)
    void setPitchStage(int line, int index, float rate, float level) noexcept;
    void setPitchSustainPoint(int line, int index) noexcept;
    void setPitchEndPoint(int line, int index) noexcept;

    // Hard Sync
    void setHardSync(bool enabled) noexcept;

    // Ring Mod
    void setRingMod(bool enabled) noexcept;

    // Glide
    void setGlideTime(float seconds) noexcept;
    void setMasterTune(float semitones) noexcept;
    void setPitchBend(float semitones) noexcept;
    
    // LFO Control
    void setVibratoDepth(float semitones) noexcept;
    void setLFOFrequency(float hz) noexcept;
    void setLFOWaveform(DSP::LFO::Waveform waveform) noexcept;
    void setLFODelay(float seconds) noexcept;

    void noteOn(int midiNote, float velocity) noexcept;
    void noteOff(int midiNote) noexcept;
    void allNotesOff() noexcept;
    
    // Audio Processing
    // LFO is now internal to Voices
    void renderNextBlock(float* outputL, float* outputR, int numSamples) noexcept;
    
    int getActiveVoiceCount() const noexcept;
    int getCurrentNote() const noexcept { return lastMidiNote; }

private:
private:
    std::array<Voice, MAX_VOICES> voices; // Audit Fix 6.1: Fixed size array for memory stability
    Voice referenceVoice;      // Audit Fix 1.5: Reference voice for stable parameter reading
    VoiceStealingMode stealingMode = RELEASE_PHASE;
    int lastMidiNote = -1;
    
    int findFreeVoice() const noexcept;
    int findVoiceToSteal() const noexcept;
    int findVoicePlayingNote(int midiNote) const noexcept;
};

} // namespace Core
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Chorus.cpp
================================================================================
#include "Chorus.h"
#include <cmath>

namespace CZ101 {
namespace DSP {
namespace Effects {

Chorus::Chorus()
{
    // Max delay depth 20ms usually enough (Allocating 50ms for safety)
    // 50ms at 192kHz ~= 9600 samples
    bufferSize = 16384; 
    delayBufferL.resize(bufferSize, 0.0f);
    delayBufferR.resize(bufferSize, 0.0f);
}

void Chorus::prepare(double sr)
{
    sampleRate = sr;
    setRate(rate); // Recalc increment
    reset();
}

void Chorus::reset()
{
    std::fill(delayBufferL.begin(), delayBufferL.end(), 0.0f);
    std::fill(delayBufferR.begin(), delayBufferR.end(), 0.0f);
    writeIndex = 0;
    lfoPhase = 0.0f;
}

void Chorus::setRate(float rateHz)
{
    rate = rateHz;
    // Inc per sample = Rate / SR
    // 2PI for sin? Or 0-1 phasor? Using 0-1
    lfoIncrement = rate / static_cast<float>(sampleRate);
}

void Chorus::setDepth(float depthMs)
{
    depth = depthMs;
}

void Chorus::setMix(float mix0to1)
{
    mix = std::clamp(mix0to1, 0.0f, 1.0f);
}

float Chorus::getInterpolatedSample(const std::vector<float>& buffer, float readIndex) const
{
    // Linear Interpolation
    int index1 = static_cast<int>(readIndex);
    int index2 = (index1 + 1) % bufferSize;
    float fraction = readIndex - index1;
    
    float s1 = buffer[index1];
    float s2 = buffer[index2];
    
    return s1 + fraction * (s2 - s1);
}

void Chorus::process(float* leftChannel, float* rightChannel, int numSamples)
{
    if (mix < 0.01f) return; // Bypass efficiency
    
    const float depthSamples = (depth / 1000.0f) * static_cast<float>(sampleRate);
    // Base delay for Chorus usually slightly more than depth excursion
    const float baseDelay = depthSamples * 1.5f + 100.0f; // Offset to avoid crossing write pointer
    
    for (int i = 0; i < numSamples; ++i)
    {
        // Update LFO
        lfoPhase += lfoIncrement;
        // Audit Fix 2.10: Handle negative phase/large increments
        while (lfoPhase >= 1.0f) lfoPhase -= 1.0f;
        while (lfoPhase < 0.0f) lfoPhase += 1.0f;
        
        // Calculate LFO values
        // Left: Sin(phase)
        // Right: Cos(phase) or Sin(phase + 90) -> Separation
        float lfoValL = std::sin(lfoPhase * 2.0f * juce::MathConstants<float>::pi);
        float lfoValR = std::cos(lfoPhase * 2.0f * juce::MathConstants<float>::pi);
        
        // Calculate read positions
        // Delay = Base + Depth * LFO
        float delayL = baseDelay + (depthSamples * lfoValL);
        float delayR = baseDelay + (depthSamples * lfoValR);
        
        // Circular buffer read pointers
        // Audit Fix 1.6: Use fmod for robust circular buffer wrapping
        float readPosL = static_cast<float>(writeIndex) - delayL;
        readPosL = std::fmod(readPosL, static_cast<float>(bufferSize));
        if (readPosL < 0.0f) readPosL += bufferSize;
        
        float readPosR = static_cast<float>(writeIndex) - delayR;
        readPosR = std::fmod(readPosR, static_cast<float>(bufferSize));
        if (readPosR < 0.0f) readPosR += bufferSize;
        
        // Read wet samples
        float wetL = getInterpolatedSample(delayBufferL, readPosL);
        float wetR = getInterpolatedSample(delayBufferR, readPosR);
        
        // Write inputs to buffer
        delayBufferL[writeIndex] = leftChannel[i];
        delayBufferR[writeIndex] = rightChannel[i];
        
        // Mix
        leftChannel[i] = (leftChannel[i] * (1.0f - mix * 0.5f)) + (wetL * mix);
        rightChannel[i] = (rightChannel[i] * (1.0f - mix * 0.5f)) + (wetR * mix);
        
        // Advance write pointer
        writeIndex++;
        if (writeIndex >= bufferSize) writeIndex = 0;
    }
}

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Chorus.h
================================================================================
#pragma once

#include <vector>
#include <cmath>
#include <JuceHeader.h>

namespace CZ101 {
namespace DSP {
namespace Effects {

class Chorus {
public:
    Chorus();
    
    void prepare(double sampleRate);
    void reset();
    
    void setRate(float rateHz);
    void setDepth(float depthMs);
    void setMix(float mix0to1);
    
    void process(float* leftChannel, float* rightChannel, int numSamples);
    
private:
    double sampleRate = 44100.0;
    
    // Parameters
    float rate = 0.5f;
    float depth = 2.0f; // ms
    float mix = 0.0f;
    
    // Delay lines
    std::vector<float> delayBufferL;
    std::vector<float> delayBufferR;
    int writeIndex = 0;
    int bufferSize = 0;
    
    // LFO state
    float lfoPhase = 0.0f;
    float lfoIncrement = 0.0f;
    
    // Helpers
    float getInterpolatedSample(const std::vector<float>& buffer, float readIndex) const;
};

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Delay.cpp
================================================================================
#include "Delay.h"

namespace CZ101 {
namespace DSP {
namespace Effects {

Delay::Delay()
{
    buffer.fill(0.0f);
}

void Delay::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
}

void Delay::setDelayTime(float seconds) noexcept
{
    seconds = std::clamp(seconds, 0.001f, 2.0f);
    delayInSamples = static_cast<int>(seconds * sampleRate);
    delayInSamples = std::min(delayInSamples, MAX_DELAY_SAMPLES - 1);
}

void Delay::setFeedback(float amount) noexcept
{
    feedback = std::clamp(amount, 0.0f, 0.95f);
}

void Delay::setMix(float amount) noexcept
{
    mix = std::clamp(amount, 0.0f, 1.0f);
}

void Delay::reset() noexcept
{
    buffer.fill(0.0f);
    writePos = 0;
}

float Delay::processSample(float input) noexcept
{
    int readPos = writePos - delayInSamples;
    if (readPos < 0)
        readPos += MAX_DELAY_SAMPLES;
    
    float delayed = buffer[readPos];
    buffer[writePos] = input + delayed * feedback;
    
    writePos = (writePos + 1) % MAX_DELAY_SAMPLES;
    
    return input * (1.0f - mix) + delayed * mix;
}

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Delay.h
================================================================================
#pragma once

#include <array>
#include <algorithm>

namespace CZ101 {
namespace DSP {
namespace Effects {
    
class Delay
{
public:
    Delay();
    
    void setSampleRate(double sampleRate) noexcept;
    void setDelayTime(float seconds) noexcept;
    void setFeedback(float amount) noexcept;
    void setMix(float amount) noexcept;
    void reset() noexcept;
    
    float processSample(float input) noexcept;
    
private:
    static constexpr int MAX_DELAY_SAMPLES = 88200;  // 2 seconds @ 44.1kHz
    
    std::array<float, MAX_DELAY_SAMPLES> buffer;
    double sampleRate = 44100.0;
    int delayInSamples = 22050;
    int writePos = 0;
    float feedback = 0.5f;
    float mix = 0.3f;
};

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Reverb.cpp
================================================================================
#include "Reverb.h"

namespace CZ101 {
namespace DSP {

Reverb::Reverb()
{
    // Set default parameters
    params.roomSize = 0.5f;
    params.damping = 0.5f;
    params.wetLevel = 0.33f;
    params.dryLevel = 1.0f; // Normally we control mix differently, but juce::Reverb has explicit wet/dry
    params.width = 1.0f;
    params.freezeMode = 0.0f;
    
    reverb.setParameters(params);
}

void Reverb::prepare(double sampleRate, int samplesPerBlock)
{
    currentSampleRate = sampleRate;
    reverb.setSampleRate(sampleRate);
    reverb.reset();
    (void)samplesPerBlock;
}

void Reverb::reset()
{
    reverb.reset();
}

void Reverb::setParameters(float roomSize, float damping, float wetLevel, float dryLevel, float width)
{
    params.roomSize = roomSize;
    params.damping = damping;
    params.wetLevel = wetLevel;
    params.dryLevel = dryLevel;
    params.width = width;
    
    reverb.setParameters(params);
}

void Reverb::process(juce::AudioBuffer<float>& buffer)
{
    // juce::Reverb processes stereo buffers naturally
    if (buffer.getNumChannels() == 2)
    {
        reverb.processStereo(buffer.getWritePointer(0), buffer.getWritePointer(1), buffer.getNumSamples());
    }
    else if (buffer.getNumChannels() == 1)
    {
        reverb.processMono(buffer.getWritePointer(0), buffer.getNumSamples());
    }
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Reverb.h
================================================================================
#pragma once

#include <juce_audio_basics/juce_audio_basics.h>

namespace CZ101 {
namespace DSP {

class Reverb
{
public:
    Reverb();
    
    void prepare(double sampleRate, int samplesPerBlock);
    void reset();
    
    void setParameters(float roomSize, float damping, float wetLevel, float dryLevel, float width);
    
    void process(juce::AudioBuffer<float>& buffer);
    
private:
    juce::Reverb reverb;
    juce::Reverb::Parameters params;
    
    double currentSampleRate = 44100.0;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\StereoChorus.cpp
================================================================================
#include "StereoChorus.h"

namespace CZ101 {
namespace DSP {
namespace Effects {

StereoChorus::StereoChorus() {
    // Set LFOs to be 90 degrees out of phase for stereo width
    lfoR.setPhaseOffset(0.25f); // 0.25 of a cycle is 90 degrees
}

void StereoChorus::prepare(double sampleRate) {
    sr = sampleRate;
    lfoL.setSampleRate(sr);
    lfoR.setSampleRate(sr);
    
    // Max delay of ~50ms should be plenty for a chorus
    int bufferSize = (int)(sr * 0.05);
    delayBufferL.setSize(bufferSize);
    delayBufferR.setSize(bufferSize);
    delayBufferL.clear();
    delayBufferR.clear();
}

void StereoChorus::reset() { // Audit Fix 1.2: Reset
    lfoL.reset();
    lfoR.reset();
    delayBufferL.clear();
    delayBufferR.clear();
}

void StereoChorus::process(float* left, float* right, int numSamples) {
    for (int i = 0; i < numSamples; ++i) {
        // Get LFO values (range -1 to 1)
        float lfoValL = lfoL.getNextValue();
        float lfoValR = lfoR.getNextValue();

        // Map LFO to a delay time perturbation
        // Example: 10ms base delay, modulated by +/- 5ms
        float baseDelayMs = 15.0f;
        float modulationDepthMs = 10.0f * depth;

        float delayMsL = baseDelayMs + modulationDepthMs * lfoValL;
        float delayMsR = baseDelayMs + modulationDepthMs * lfoValR;
        
        float delaySamplesL = (float)(sr * delayMsL / 1000.0);
        float delaySamplesR = (float)(sr * delayMsR / 1000.0);

        // Get delayed samples
        float delayedL = delayBufferL.getInterpolated(delaySamplesL);
        float delayedR = delayBufferR.getInterpolated(delaySamplesR);
        
        // Write current dry sample to buffer for future reads
        delayBufferL.push(left[i]);
        delayBufferR.push(right[i]);

        // Mix dry and wet signals
        left[i]  = (1.0f - mix) * left[i]  + mix * delayedL;
        right[i] = (1.0f - mix) * right[i] + mix * delayedR;
    }
}

void StereoChorus::setRate(float rateHz) {
    rate = rateHz;
    lfoL.setFrequency(rate);
    lfoR.setFrequency(rate);
}

void StereoChorus::setDepth(float d) {
    depth = juce::jlimit(0.0f, 1.0f, d);
}

void StereoChorus::setMix(float m) {
    mix = juce::jlimit(0.0f, 1.0f, m);
}

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\StereoChorus.h
================================================================================
#pragma once

#include <JuceHeader.h>
// Corregido para usar una ruta de inclusiÃ³n directa desde la raÃ­z de 'Source'
#include "Utils/CircularBuffer.h"
#include "../Modulation/LFO.h"

namespace CZ101 {
namespace DSP {
namespace Effects {

class StereoChorus {
public:
    StereoChorus();

    void prepare(double sampleRate);
    void reset(); // Audit Fix 1.2: Reset RNG/Phase
    void process(float* left, float* right, int numSamples);
    
    void setRate(float rateHz);
    void setDepth(float depth);
    void setMix(float mix);

private:
    double sr = 44100.0;
    LFO lfoL, lfoR;
    Utils::CircularBuffer<float> delayBufferL, delayBufferR;
    float rate = 1.0f;
    float depth = 0.5f;
    float mix = 0.5f;
};

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Envelopes\ADSREnvelope.cpp
================================================================================
#include "ADSREnvelope.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

ADSREnvelope::ADSREnvelope()
{
}

void ADSREnvelope::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
}

void ADSREnvelope::setAttackTime(float seconds) noexcept
{
    attackTime = std::clamp(seconds, 0.001f, 10.0f);
}

void ADSREnvelope::setDecayTime(float seconds) noexcept
{
    decayTime = std::clamp(seconds, 0.001f, 10.0f);
}

void ADSREnvelope::setSustainLevel(float level) noexcept
{
    sustainLevel = std::clamp(level, 0.0f, 1.0f);
}

void ADSREnvelope::setReleaseTime(float seconds) noexcept
{
    releaseTime = std::clamp(seconds, 0.001f, 10.0f);
}

void ADSREnvelope::noteOn() noexcept
{
    currentStage = ATTACK;
    stageProgress = 0.0f;
}

void ADSREnvelope::noteOff() noexcept
{
    if (currentStage != IDLE)
    {
        currentStage = RELEASE;
        stageProgress = 0.0f;
    }
}

void ADSREnvelope::reset() noexcept
{
    currentStage = IDLE;
    currentValue = 0.0f;
    stageProgress = 0.0f;
}

float ADSREnvelope::getNextValue() noexcept
{
    if (currentStage == IDLE)
        return 0.0f;
    
    float stageDuration = 0.0f;
    float targetValue = 0.0f;
    float startValue = currentValue;
    
    switch (currentStage)
    {
        case ATTACK:
            stageDuration = attackTime;
            targetValue = 1.0f;
            startValue = 0.0f;
            break;
            
        case DECAY:
            stageDuration = decayTime;
            targetValue = sustainLevel;
            startValue = 1.0f;
            break;
            
        case SUSTAIN:
            return sustainLevel;
            
        case RELEASE:
            stageDuration = releaseTime;
            targetValue = 0.0f;
            startValue = currentValue;
            break;
            
        default:
            return 0.0f;
    }
    
    // Calculate progress increment
    float increment = 1.0f / (stageDuration * static_cast<float>(sampleRate));
    stageProgress += increment;
    
    // Apply exponential curve
    float curvedProgress = calculateExponentialCurve(stageProgress);
    
    // Interpolate between start and target
    currentValue = startValue + (targetValue - startValue) * curvedProgress;
    
    // Check if stage is complete
    if (stageProgress >= 1.0f)
    {
        currentValue = targetValue;
        advanceStage();
    }
    
    return currentValue;
}

float ADSREnvelope::calculateExponentialCurve(float t) const noexcept
{
    // Exponential curve: 1 - e^(-factor * t)
    // This creates a natural-sounding envelope
    t = std::clamp(t, 0.0f, 1.0f);
    return 1.0f - std::exp(-CURVE_FACTOR * t);
}

void ADSREnvelope::advanceStage() noexcept
{
    stageProgress = 0.0f;
    
    switch (currentStage)
    {
        case ATTACK:
            currentStage = DECAY;
            break;
            
        case DECAY:
            currentStage = SUSTAIN;
            break;
            
        case SUSTAIN:
            // Stay in sustain until noteOff
            break;
            
        case RELEASE:
            currentStage = IDLE;
            currentValue = 0.0f;
            break;
            
        default:
            break;
    }
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Envelopes\ADSREnvelope.h
================================================================================
#pragma once

#include <cmath>

namespace CZ101 {
namespace DSP {

/**
 * @brief ADSR Envelope Generator
 * 
 * Classic Attack-Decay-Sustain-Release envelope with exponential curves.
 * Used for both amplitude (DCA) and filter/timbre (DCW) modulation.
 */
class ADSREnvelope
{
public:
    enum Stage
    {
        IDLE = 0,
        ATTACK,
        DECAY,
        SUSTAIN,
        RELEASE,
        NUM_STAGES
    };
    
    ADSREnvelope();
    
    void setSampleRate(double sampleRate) noexcept;
    
    // Parameters in seconds
    void setAttackTime(float seconds) noexcept;
    void setDecayTime(float seconds) noexcept;
    void setSustainLevel(float level) noexcept;  // [0.0, 1.0]
    void setReleaseTime(float seconds) noexcept;
    
    void noteOn() noexcept;
    void noteOff() noexcept;
    void reset() noexcept;
    
    /**
     * @brief Get next envelope value
     * @return Envelope value [0.0, 1.0]
     */
    float getNextValue() noexcept;
    
    Stage getCurrentStage() const noexcept { return currentStage; }
    bool isActive() const noexcept { return currentStage != IDLE; }
    
private:
    double sampleRate = 44100.0;
    
    // Parameters
    float attackTime = 0.01f;    // 10ms
    float decayTime = 0.1f;      // 100ms
    float sustainLevel = 0.7f;   // 70%
    float releaseTime = 0.2f;    // 200ms
    
    // State
    Stage currentStage = IDLE;
    float currentValue = 0.0f;
    float stageProgress = 0.0f;  // [0.0, 1.0]
    
    // Exponential curve factor (higher = more exponential)
    static constexpr float CURVE_FACTOR = 4.0f;
    
    float calculateExponentialCurve(float t) const noexcept;
    void advanceStage() noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Envelopes\ADSRtoStage.h
================================================================================
#pragma once

#include <cmath>
#include <array>
#include <algorithm>

namespace CZ101 {
namespace DSP {

/**
 * @brief ConversiÃ³n ADSR â†’ 8-stage envelope rates
 * 
 * Mapea parÃ¡metros ADSR (milisegundos) a coeficientes de stage
 * usando aproximaciÃ³n logarÃ­tmica basada en tiempo de caÃ­da 60dB
 */
struct ADSRtoStageConverter {
    
    /**
     * @brief Convertir ADSR a 8 stages
     * 
     * @param attackMs      Attack time (0-8000ms)
     * @param decayMs       Decay time (0-8000ms)
     * @param sustainLevel  Sustain level (0-1.0)
     * @param releaseMs     Release time (0-8000ms)
     * @param outRates      [OUT] array de 8 coeficientes de rate
     * @param outLevels     [OUT] array de 8 niveles objetivo
     * @param outSustainPoint [OUT] Ã­ndice de sustain
     * @param outEndPoint   [OUT] Ã­ndice de fin
     * @param sampleRate    Sample rate (default 44100)
     */
    static void convertADSR(
        float attackMs,
        float decayMs,
        float sustainLevel,
        float releaseMs,
        std::array<float, 8>& outRates,
        std::array<float, 8>& outLevels,
        int& outSustainPoint,
        int& outEndPoint,
        double sampleRate = 44100.0
    ) {
        // Validar y clampear inputs
        attackMs = std::clamp(attackMs, 0.0f, 8000.0f);
        decayMs = std::clamp(decayMs, 0.0f, 8000.0f);
        sustainLevel = std::clamp(sustainLevel, 0.0f, 1.0f);
        releaseMs = std::clamp(releaseMs, 0.0f, 8000.0f);
        
        // Internal helper: convert milliseconds -> MultiStageEnvelope Rate (0.0 - 1.0)
        // This unifies the mapping between ADSR controls and the 8-stage engine.
        // Formula is based on the inverse of MultiStageEnvelope::rateToSeconds:
        // rate = 1.0 - pow((seconds - 0.001) / 30, 0.25)
        // ADSR to Stage Formula
        // Audit Fix [E]: Clamp sec to >= 0.001 to avoid NaN in pow()
        auto msToRate = [](float ms) -> float {
            float sec = std::clamp(ms / 1000.0f, 0.001f, 30.0f);
            float r = std::pow(std::clamp((sec - 0.001f) / 30.0f, 0.0f, 1.0f), 0.25f);
            return std::clamp(1.0f - r, 0.0f, 1.0f);
        };
        
        // ===== STAGE 0: ATTACK =====
        // Rampa desde 0 hacia 1.0
        outRates[0] = msToRate(attackMs);
        outLevels[0] = 1.0f;
        
        // ===== STAGE 1: DECAY =====
        // Rampa desde 1.0 hacia sustain
        outRates[1] = msToRate(decayMs);
        outLevels[1] = sustainLevel;
        
        // ===== STAGE 2: SUSTAIN HOLD =====
        // Mantiene nivel de sustain (sin decaimiento)
        outRates[2] = 0.99f;
        outLevels[2] = sustainLevel;
        
        // ===== STAGE 3: RELEASE =====
        // Rampa desde sustain hacia 0
        outRates[3] = msToRate(releaseMs);
        outLevels[3] = 0.0f;
        
        // ===== STAGES 4-7: UNUSED =====
        for (int i = 4; i < 8; ++i) {
            outRates[i] = 0.99f;
            outLevels[i] = 0.0f;
        }
        
        // Puntos de control de sustain y fin
        outSustainPoint = 2;  // Sustain en stage 2
        outEndPoint = 3;      // Release en stage 3
    }
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Envelopes\MultiStageEnv.cpp
================================================================================
#include "MultiStageEnv.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

MultiStageEnvelope::MultiStageEnvelope()
{
    // Default: Simple ADSR-like shape using 8 stages
    // Stage 0: Attack to 1.0
    setStage(0, 0.9f, 1.0f);
    // Stage 1: Decay to 0.5
    setStage(1, 0.8f, 0.5f);
    // Stage 2: Sustain at 0.5
    setStage(2, 0.99f, 0.5f);
    
    // Sets sustain point at Stage 2
    setSustainPoint(2);
    
    // Stage 3: Release to 0
    setStage(3, 0.8f, 0.0f);
    
    // End point at Stage 3
    setEndPoint(3);
}

void MultiStageEnvelope::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
}

void MultiStageEnvelope::setStage(int index, float rate, float level) noexcept
{
    if (index >= 0 && index < MAX_STAGES)
    {
        stages[index].rate = std::clamp(rate, 0.0f, 1.0f);
        stages[index].level = std::clamp(level, 0.0f, 1.0f);
    }
}

void MultiStageEnvelope::setSustainPoint(int stageIndex) noexcept
{
    if (stageIndex >= -1 && stageIndex < MAX_STAGES)
        sustainPoint = stageIndex;
}

void MultiStageEnvelope::setEndPoint(int stageIndex) noexcept
{
    if (stageIndex >= 0 && stageIndex < MAX_STAGES)
        endPoint = stageIndex;
}

void MultiStageEnvelope::noteOn() noexcept
{
    currentStage = 0;
    active = true;
    released = false;
    
    // Start from 0
    float startVal = 0.0f;
    smoother.setCurrentAndTargetValue(startVal);
    
    // Setup first stage
    float seconds = rateToSeconds(stages[0].rate);
    smoother.reset(sampleRate, seconds > 0.001f ? seconds : 0.001f); 
    smoother.setCurrentAndTargetValue(startVal);
    smoother.setTargetValue(stages[0].level);
}

void MultiStageEnvelope::noteOff() noexcept
{
    released = true;
    
    // AUTHENTIC CZ BEHAVIOR: "Dampening" / Jump to End Point
    // When key is released, regardless of current stage (even if before sustain),
    // the envelope immediately targets the End Point Level using the End Point Rate.
    if (active)
    {
        // Jump state to End Point
        // Note: In CZ, the "End Point" step IS the release phase.
        currentStage = endPoint;

        // Verify validity
        if (currentStage < MAX_STAGES)
        {
            // Retarget smoother from current value to End Point Level
            float currentVal = smoother.getCurrentValue();
            float seconds = rateToSeconds(stages[currentStage].rate);
            
            // Audit Fix 1.2: Ensure cleaner reset
            smoother.reset(sampleRate, seconds > 0.001f ? seconds : 0.001f);
            smoother.setCurrentAndTargetValue(currentVal);
            smoother.setTargetValue(stages[currentStage].level);
        }
        else
        {
            active = false;
        }
    }
}

// Audit Fix 1.1: Implementation
void MultiStageEnvelope::setCurrentValue(float val) noexcept
{
    smoother.setCurrentAndTargetValue(val);
}

void MultiStageEnvelope::reset() noexcept
{
    active = false;
    currentStage = 0;
    smoother.setCurrentAndTargetValue(0.0f);
}

float MultiStageEnvelope::getNextValue() noexcept
{
    if (!active) return 0.0f;
    
    float val = smoother.getNextValue();
    
    // Check if stage finished
    if (!smoother.isSmoothing())
    {
        val = smoother.getTargetValue(); // Ensure snap
        
        // Are we at Sustain Point?
        if (currentStage == sustainPoint && !released)
        {
            // Hold here until Note Off
            // Do nothing, just return val
        }
        else if (currentStage >= endPoint)
        {
            // End of envelope
            // If released or no sustain, we are done
            // If we are sustaining at end (unlikely for CZ architecture, end is end), disable.
            active = false;
        }
        else
        {
            // Move to next stage
            currentStage++;
            
            if (currentStage < MAX_STAGES)
            {
                float currentVal = val;
                float seconds = rateToSeconds(stages[currentStage].rate);
                smoother.reset(sampleRate, seconds > 0.001f ? seconds : 0.001f);
                smoother.setCurrentAndTargetValue(currentVal);
                smoother.setTargetValue(stages[currentStage].level);
            }
            else
            {
                active = false;
            }
        }
    }
    
    return val;
}

float MultiStageEnvelope::rateToSeconds(float rate) const noexcept
{
    // CZ-101 Rate approximation
    // Rate 0.0 (slow) -> ~3 seconds (can be longer on real hardware)
    // Rate 1.0 (fast) -> ~1 ms
    
    // Using exponential curve
    // Invert rate: 1.0 is slow, 0.0 is fast for calculation
    float r = 1.0f - rate;
    
    // Base 30s max time
    return 0.001f + (std::pow(r, 4.0f) * 30.0f);
}

float MultiStageEnvelope::getStageRate(int index) const noexcept
{
    if (index >= 0 && index < MAX_STAGES)
        return stages[index].rate;
    return 0.0f;
}

float MultiStageEnvelope::getStageLevel(int index) const noexcept
{
    if (index >= 0 && index < MAX_STAGES)
        return stages[index].level;
    return 0.0f;
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Envelopes\MultiStageEnv.h
================================================================================
#pragma once

#include <array>
#include <cmath>
#include <juce_audio_basics/juce_audio_basics.h>

namespace CZ101 {
namespace DSP {

/**
 * @brief Multi-Stage Envelope Generator (8 stages)
 * 
 * Authentic CZ-101 Envelope Architecture:
 * - 8 Steps per envelope
 * - Each step has a Rate (speed) and Level (target)
 * - Sustain Point: The step where the envelope holds while key is pressed.
 * - End Point: The final step of the envelope.
 */
class MultiStageEnvelope
{
public:
    static constexpr int MAX_STAGES = 8;
    
    struct Stage
    {
        float level = 0.0f;      // Target level [0.0, 1.0]
        float rate = 0.5f;       // Speed to reach level [0.0, 1.0] (1.0 = fast, 0.0 = slow)
    };
    
    MultiStageEnvelope();
    
    void setSampleRate(double sampleRate) noexcept;
    
    // Configuration
    void setStage(int index, float rate, float level) noexcept;
    void setSustainPoint(int stageIndex) noexcept;
    void setEndPoint(int stageIndex) noexcept;
    
    // Runtime
    void noteOn() noexcept;
    void noteOff() noexcept;

    void reset() noexcept;
    // Audit Fix [1.1]: Allow external reset of value (for pitch centering)
    void setCurrentValue(float val) noexcept;
    
    float getNextValue() noexcept;
    
    // Getters for adapter logic
    float getStageRate(int index) const noexcept;
    float getStageLevel(int index) const noexcept;
    
    bool isActive() const noexcept { return active; }
    bool isReleased() const noexcept { return released; }
    int getCurrentStage() const noexcept { return currentStage; }
    
    int getSustainPoint() const noexcept { return sustainPoint; }
    int getEndPoint() const noexcept { return endPoint; }
    
private:
    double sampleRate = 44100.0;
    std::array<Stage, MAX_STAGES> stages;
    
    // Envelope Smoother
    juce::LinearSmoothedValue<float> smoother;
    
    int currentStage = 0;
    // Removed manual currentValue/Increment/targetValue as smoother handles it
    
    int sustainPoint = -1;  // -1 = no sustain (or one-shot)
    int endPoint = 7;       // Default to using all 8 stages
    
    bool active = false;
    bool released = false;
    
    // CZ-101 Rate to Time conversion (internal helper)
    // Rate 0-99 mapped to ms
    float rateToSeconds(float rate) const noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Filters\ResonantFilter.cpp
================================================================================
#include "ResonantFilter.h"

namespace CZ101 {
namespace DSP {

ResonantFilter::ResonantFilter()
{
    updateCoefficients();
}

void ResonantFilter::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
    updateCoefficients();
}

void ResonantFilter::setType(Type type) noexcept
{
    filterType = type;
    updateCoefficients();
}

void ResonantFilter::setCutoff(float frequency) noexcept
{
    cutoffFreq = std::clamp(frequency, 20.0f, 20000.0f);
    updateCoefficients();
}

void ResonantFilter::setResonance(float q) noexcept
{
    resonance = std::clamp(q, 0.1f, 10.0f);
    updateCoefficients();
}

void ResonantFilter::reset() noexcept
{
    z1 = 0.0f;
    z2 = 0.0f;
}

float ResonantFilter::processSample(float input) noexcept
{
    float output = a0 * input + a1 * z1 + a2 * z2 - b1 * z1 - b2 * z2;
    
    z2 = z1;
    z1 = output;
    
    return output;
}

void ResonantFilter::updateCoefficients() noexcept
{
    constexpr float PI = 3.14159265358979323846f;
    
    float omega = 2.0f * PI * cutoffFreq / static_cast<float>(sampleRate);
    float sinOmega = std::sin(omega);
    float cosOmega = std::cos(omega);
    float alpha = sinOmega / (2.0f * resonance);
    
    switch (filterType)
    {
        case LOWPASS:
        {
            float b0 = (1.0f - cosOmega) / 2.0f;
            float b1_coef = 1.0f - cosOmega;
            float b2_coef = (1.0f - cosOmega) / 2.0f;
            float a0_coef = 1.0f + alpha;
            float a1_coef = -2.0f * cosOmega;
            float a2_coef = 1.0f - alpha;
            
            a0 = b0 / a0_coef;
            a1 = b1_coef / a0_coef;
            a2 = b2_coef / a0_coef;
            b1 = a1_coef / a0_coef;
            b2 = a2_coef / a0_coef;
            break;
        }
        
        case HIGHPASS:
        {
            float b0 = (1.0f + cosOmega) / 2.0f;
            float b1_coef = -(1.0f + cosOmega);
            float b2_coef = (1.0f + cosOmega) / 2.0f;
            float a0_coef = 1.0f + alpha;
            float a1_coef = -2.0f * cosOmega;
            float a2_coef = 1.0f - alpha;
            
            a0 = b0 / a0_coef;
            a1 = b1_coef / a0_coef;
            a2 = b2_coef / a0_coef;
            b1 = a1_coef / a0_coef;
            b2 = a2_coef / a0_coef;
            break;
        }
        
        case BANDPASS:
        {
            float b0 = alpha;
            float b1_coef = 0.0f;
            float b2_coef = -alpha;
            float a0_coef = 1.0f + alpha;
            float a1_coef = -2.0f * cosOmega;
            float a2_coef = 1.0f - alpha;
            
            a0 = b0 / a0_coef;
            a1 = b1_coef / a0_coef;
            a2 = b2_coef / a0_coef;
            b1 = a1_coef / a0_coef;
            b2 = a2_coef / a0_coef;
            break;
        }
        
        default:
            break;
    }
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Filters\ResonantFilter.h
================================================================================
#pragma once

#include <cmath>
#include <algorithm>

namespace CZ101 {
namespace DSP {

class ResonantFilter
{
public:
    enum Type
    {
        LOWPASS = 0,
        HIGHPASS,
        BANDPASS,
        NUM_TYPES
    };
    
    ResonantFilter();
    
    void setSampleRate(double sampleRate) noexcept;
    void setType(Type type) noexcept;
    void setCutoff(float frequency) noexcept;
    void setResonance(float q) noexcept;
    void reset() noexcept;
    
    float processSample(float input) noexcept;
    
private:
    double sampleRate = 44100.0;
    Type filterType = LOWPASS;
    float cutoffFreq = 1000.0f;
    float resonance = 0.7f;
    
    // State variables (2-pole)
    float z1 = 0.0f;
    float z2 = 0.0f;
    
    // Coefficients
    float a0 = 1.0f, a1 = 0.0f, a2 = 0.0f;
    float b1 = 0.0f, b2 = 0.0f;
    
    void updateCoefficients() noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Modulation\LFO.cpp
================================================================================
#include "LFO.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

LFO::LFO()
{
    updatePhaseIncrement();
}

void LFO::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
    updatePhaseIncrement();
}

void LFO::setFrequency(float hz) noexcept
{
    frequency = std::clamp(hz, 0.01f, 30.0f); // Range updated to 30Hz authentic/useful range
    updatePhaseIncrement();
}

void LFO::setWaveform(Waveform waveform) noexcept
{
    currentWaveform = waveform;
}

void LFO::setDelay(float seconds) noexcept
{
    delayTime = std::max(0.0f, seconds);
}

void LFO::reset() noexcept
{
    phase = 0.0f;
    delayTimer = 0.0f; // Reset delay timer on Note On
}

void LFO::updatePhaseIncrement() noexcept
{
    phaseIncrement = frequency / static_cast<float>(sampleRate);
}

void LFO::setPhaseOffset(float offset) noexcept
{
    phaseOffset = offset;
}

float LFO::getNextValue() noexcept
{
    // Handle Delay
    if (delayTimer < delayTime)
    {
        delayTimer += (1.0f / static_cast<float>(sampleRate));
        if (delayTimer < delayTime)
        {
            // Still in delay phase
            return 0.0f;
        }
        else
        {
            // Delay finished, reset phase?
            phase = 0.0f;
        }
    }
    
    // Calculate current position including offset
    float currentPos = phase + phaseOffset;
    while (currentPos >= 1.0f) currentPos -= 1.0f;
    while (currentPos < 0.0f) currentPos += 1.0f;

    float value = 0.0f;
    
    switch (currentWaveform)
    {
        case TRIANGLE: 
            if (currentPos < 0.25f) value = 4.0f * currentPos;
            else if (currentPos < 0.75f) value = 2.0f - 4.0f * currentPos;
            else value = 4.0f * currentPos - 4.0f;
            break;
            
        case SAW_UP: // Ramp Up
            value = 2.0f * currentPos - 1.0f;
            break;
            
        case SAW_DOWN: // Ramp Down
            value = 1.0f - 2.0f * currentPos;
            break;
            
        case SQUARE: // Trill
            value = (currentPos < 0.5f) ? 1.0f : -1.0f;
            break;
            
        default: value = 0.0f;
    }
    
    phase += phaseIncrement;
    if (phase >= 1.0f)
        phase -= 1.0f;
    
    return value;
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Modulation\LFO.h
================================================================================
#pragma once

#include <cmath>

namespace CZ101 {
namespace DSP {

class LFO
{
public:
    enum Waveform
    {
        TRIANGLE = 0,
        SAW_UP,
        SAW_DOWN,
        SQUARE,
        NUM_WAVEFORMS
    };
    
    LFO();
    
    void setSampleRate(double sampleRate) noexcept;
    void setFrequency(float hz) noexcept;
    void setWaveform(Waveform waveform) noexcept;
    void setDelay(float seconds) noexcept;
    void setPhaseOffset(float offset) noexcept; // For Chorus
    
    void reset() noexcept; // Resets phase AND delay timer
    
    float getNextValue() noexcept;
    
private:
    double sampleRate = 44100.0;
    float frequency = 1.0f;
    Waveform currentWaveform = TRIANGLE;
    float phase = 0.0f;
    float phaseOffset = 0.0f;
    float phaseIncrement = 0.0f;
    
    // Delay Logic
    float delayTime = 0.0f;
    float delayTimer = 0.0f;
    
    void updatePhaseIncrement() noexcept;
    float renderSine() noexcept;
    float renderTriangle() noexcept;
    float renderSawtooth() noexcept;
    float renderSquare() noexcept;
    float renderRandom() noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\PhaseDistOsc.cpp
================================================================================
#include "PhaseDistOsc.h"
#include <algorithm>
#include <cmath> // Audit Fix 5.1: M_PI compliance

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

namespace CZ101 {
namespace DSP {

PhaseDistOscillator::PhaseDistOscillator()
{
    updatePhaseIncrement();
}

void PhaseDistOscillator::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
    updatePhaseIncrement();
}

void PhaseDistOscillator::setFrequency(float freq) noexcept
{
    frequency = std::clamp(freq, 20.0f, 20000.0f);
    updatePhaseIncrement();
}

void PhaseDistOscillator::setWaveforms(CzWaveform first, CzWaveform second) noexcept
{
    firstWaveform = first;
    
    // CZ Logic: Second waveform 0-8. If 0 (caller handles mapping to NONE or we handle it here).
    // Assuming the caller passes NUM_CZ_WAVEFORMS or similar for "Off" if they converted 0->None.
    // However, the cleanest way is: if second is valid enum, it's active.
    // We will assume the caller sets 'secondWaveformActive' logic via this call.
    // For now, let's assume if second is 'NUM_CZ_WAVEFORMS' (8), it is OFF.
    // But the enum only goes up to 7 (Resonance 3).
    // Let's modify logic: if caller passes same as first, it's just mixing 2 same. 
    // We need a way to say "OFF".
    // I will use a convention: The VoiceManager will refrain from calling this if 0, 
    // or passing a specific signal.
    // Let's rely on 'secondWaveformActive' being set by checking if second != NUM_CZ_WAVEFORMS.
    
    secondWaveform = second;
    secondWaveformActive = (second != NUM_CZ_WAVEFORMS); 
}

void PhaseDistOscillator::reset() noexcept
{
    phase = 0.0f;
}

void PhaseDistOscillator::updatePhaseIncrement() noexcept
{
    phaseIncrement = static_cast<float>(frequency / sampleRate);
}

// Helper for applying PD
// Now static-like, takes waveform as arg
// Forced inline for performance in the hot path
inline float PhaseDistOscillator::applyPhaseDistortion(float linearPhase, float dcwValue, CzWaveform wave) noexcept
{
    float distortedPhase = linearPhase;

    switch (wave)
    {
        case SAWTOOTH:
        {
            float distorted = (linearPhase < 0.5f) ? (linearPhase * 2.0f) : 1.0f;
            distortedPhase = linearPhase + (distorted - linearPhase) * dcwValue;
            break;
        }
        
        case SQUARE:
        {
            float distorted = (linearPhase < 0.5f) ? 0.25f : 0.75f;
            distortedPhase = linearPhase + (distorted - linearPhase) * dcwValue;
            break;
        }

        case PULSE:
        {
            float distorted = (linearPhase < 0.25f) ? 0.25f : 0.75f;
            distortedPhase = linearPhase + (distorted - linearPhase) * dcwValue;
            break;
        }

        case DOUBLE_SINE:
        {
            float distorted = linearPhase * 2.0f;
            distortedPhase = linearPhase + (distorted - linearPhase) * dcwValue;
            break;
        }

        case SAW_PULSE:
        {
            float distorted = (linearPhase < 0.5f) ? (linearPhase * 2.0f) : 0.75f;
            distortedPhase = linearPhase + (distorted - linearPhase) * dcwValue;
            break;
        }

        case RESONANCE_1:
        case RESONANCE_2:
        case RESONANCE_3:
        {
            float modFreq = (wave == RESONANCE_1) ? 2.0f : (wave == RESONANCE_2 ? 4.0f : 7.0f);
            float maxMod = (wave == RESONANCE_1) ? 0.15f : (wave == RESONANCE_2 ? 0.20f : 0.25f);
            
            // Optimization: Use WaveTable for modulation sine instead of sin()
            float sineMod = waveTable.getSine(linearPhase * modFreq);
            float distorted = linearPhase + sineMod * maxMod;
            distortedPhase = linearPhase + (distorted - linearPhase) * dcwValue;
            break;
        }

        default:
            break;
    }

    // Optimization: Fast wrapping (distortedPhase range is tight)
    if (distortedPhase >= 1.0f) distortedPhase -= 1.0f;
    else if (distortedPhase < 0.0f) distortedPhase += 1.0f;

    return distortedPhase;
}

// Helper for PolyBLEP
float PhaseDistOscillator::polyBLEP(float t, float dt) const noexcept
{
    if (t < dt) {
        t /= dt;
        return t + t - t * t - 1.0f;
    }
    else if (t > 1.0f - dt) {
        t = (t - 1.0f) / dt;
        return t * t + t + t + 1.0f;
    }
    return 0.0f;
}

float PhaseDistOscillator::renderNextSample(float dcwAmount, bool* outDidWrap) noexcept
{
    // --- WAVEFORM 1 ---
    float distPhase1 = applyPhaseDistortion(phase, dcwAmount, firstWaveform);
    float sample1 = waveTable.getSine(distPhase1);

    // Apply BLEP 1
    if (firstWaveform == SAWTOOTH)
    {
        sample1 -= polyBLEP(phase, phaseIncrement);
    }
    else if (firstWaveform == SQUARE)
    {
        sample1 += polyBLEP(phase, phaseIncrement);
        float ps = phase + 0.5f; if(ps>=1.0f) ps-=1.0f;
        sample1 -= polyBLEP(ps, phaseIncrement);
    }
    else if (firstWaveform == PULSE)
    {
        sample1 += polyBLEP(phase, phaseIncrement);
        float ps = phase + 0.75f; if(ps>=1.0f) ps-=1.0f;
        sample1 -= polyBLEP(ps, phaseIncrement);
    }
    else if (firstWaveform == SAW_PULSE)
    {
        sample1 += polyBLEP(phase, phaseIncrement);
        float ps = phase + 0.5f; if(ps>=1.0f) ps-=1.0f;
        sample1 -= polyBLEP(ps, phaseIncrement);
    }

    float finalSample = sample1;

    // --- WAVEFORM 2 (Mixing) ---
    if (secondWaveformActive)
    {
        float distPhase2 = applyPhaseDistortion(phase, dcwAmount, secondWaveform);
        float sample2 = waveTable.getSine(distPhase2);

        // Apply BLEP 2
        if (secondWaveform == SAWTOOTH)
        {
            sample2 -= polyBLEP(phase, phaseIncrement);
        }
        else if (secondWaveform == SQUARE)
        {
            sample2 += polyBLEP(phase, phaseIncrement);
            float ps = phase + 0.5f; if(ps>=1.0f) ps-=1.0f;
            sample2 -= polyBLEP(ps, phaseIncrement);
        }
        else if (secondWaveform == PULSE)
        {
            sample2 += polyBLEP(phase, phaseIncrement);
            float ps = phase + 0.75f; if(ps>=1.0f) ps-=1.0f;
            sample2 -= polyBLEP(ps, phaseIncrement);
        }
        else if (secondWaveform == SAW_PULSE)
        {
            sample2 += polyBLEP(phase, phaseIncrement);
            float ps = phase + 0.5f; if(ps>=1.0f) ps-=1.0f;
            sample2 -= polyBLEP(ps, phaseIncrement);
        }

        // Additive Mix (The "Painttube" analogy - simply pouring both in)
        // Authentic behavior sums them.
        finalSample += sample2;
        
        // Soft clip/Trace to avoid massive overs? 
        // Real CZ might saturate or validly output > 1.0 which DCA then scales.
        // We will leave as sum for now.
    }

    // Advance Phase
    phase += phaseIncrement;
    if (phase >= 1.0f)
    {
        phase -= 1.0f;
        if (outDidWrap) *outDidWrap = true;
    }
    else
    {
        if (outDidWrap) *outDidWrap = false;
    }
    
    return finalSample;
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\PhaseDistOsc.h
================================================================================
#pragma once

#include "WaveTable.h"
#include <cmath>

namespace CZ101 {
namespace DSP {

/**
 * @brief Phase Distortion Oscillator with PolyBLEP anti-aliasing
 * 
 * Core oscillator for CZ-101 emulation. Generates waveforms with
 * professional quality anti-aliasing using PolyBLEP technique.
 */
class PhaseDistOscillator
{
public:
    enum CzWaveform
    {
        SAWTOOTH,
        SQUARE,
        PULSE,
        DOUBLE_SINE,
        SAW_PULSE,
        RESONANCE_1,
        RESONANCE_2,
        RESONANCE_3,
        NUM_CZ_WAVEFORMS
    };
    
    PhaseDistOscillator();
    
    /**
     * @brief Set sample rate
     * @param sampleRate Sample rate in Hz (e.g., 44100.0)
     */
    void setSampleRate(double sampleRate) noexcept;
    
    /**
     * @brief Set frequency
     * @param frequency Frequency in Hz (e.g., 440.0 for A4)
     */
    void setFrequency(float frequency) noexcept;
    
    /**
     * @brief Set waveform type
     * @param waveform Waveform enum value
     */
    /**
     * @brief Set composite waveforms (Authentic CZ Behavior)
     * @param first First waveform (1-8)
     * @param second Second waveform (0-8, 0=None/Off)
     */
    void setWaveforms(CzWaveform first, CzWaveform second) noexcept;
    
    /**
     * @brief Reset phase to zero
     */
    void reset() noexcept;
    
    /**
     * @brief Render next sample with Phase Distortion simulation
     * @param dcwAmount Timbre control [0.0 = Pure Sine, 1.0 = Full Waveform]
     * @param outDidWrap Pointer to bool that will be set to true if phase wrapped (optional)
     * @return Audio sample [-1.0, 1.0]
     */
    float renderNextSample(float dcwAmount, bool* outDidWrap = nullptr) noexcept;
    
private:
    WaveTable waveTable;
    
    double sampleRate = 44100.0;
    float frequency = 440.0f;
    CzWaveform firstWaveform = SAWTOOTH;
    CzWaveform secondWaveform = SAWTOOTH; 
    bool secondWaveformActive = false;
    
    float phase = 0.0f;           // Current phase [0.0, 1.0]
    float phaseIncrement = 0.0f;  // Phase increment per sample

    /**
     * @brief Applies phase distortion to the current phase based on the selected waveform and DCW amount.
     * @param linearPhase The current, unmodified phase [0.0, 1.0].
     * @param dcwValue The DCW amount [0.0, 1.0] controlling the intensity of the distortion.
     * @return The distorted phase.
     */
    float applyPhaseDistortion(float linearPhase, float dcwValue, CzWaveform waveform) noexcept;
    
    /**
     * @brief PolyBLEP: Polynomial Bandlimited Step
     * 
     * Reduces aliasing by smoothing discontinuities in waveforms.
     * Essential for sawtooth and square waves.
     * 
     * @param t Normalized phase [0.0, 1.0]
     * @param dt Phase increment (frequency/sampleRate)
     * @return Correction value to subtract from naive waveform
     */
    float polyBLEP(float t, float dt) const noexcept;
    
    void updatePhaseIncrement() noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\WaveShaper.cpp
================================================================================
#include "WaveShaper.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

float WaveShaper::applyPhaseDistortion(float phase, float amount) const noexcept
{
    // Clamp inputs
    phase = std::clamp(phase, 0.0f, 1.0f);
    amount = std::clamp(amount, 0.0f, 1.0f);
    
    // No distortion: return original phase
    if (amount < 0.001f)
        return phase;
    
    // Apply resonance curve
    // This creates the characteristic CZ-101 timbre by
    // compressing/expanding different parts of the waveform
    float distorted = resonanceCurve(phase, amount);
    
    return std::clamp(distorted, 0.0f, 1.0f);
}

float WaveShaper::resonanceCurve(float phase, float resonance) const noexcept
{
    // CZ-101 Phase Distortion algorithm
    // Based on the original Casio implementation
    
    // The curve compresses the first half and expands the second half
    // creating harmonic content similar to filter resonance
    
    // Calculate distortion factor
    // Higher resonance = more compression/expansion
    float factor = 1.0f + resonance * 3.0f;
    
    // Apply non-linear curve
    // This creates the phase distortion effect
    float distorted;
    
    if (phase < 0.5f)
    {
        // First half: compress (speeds up playback)
        float t = phase * 2.0f;  // Normalize to [0, 1]
        distorted = std::pow(t, factor) * 0.5f;
    }
    else
    {
        // Second half: expand (slows down playback)
        float t = (phase - 0.5f) * 2.0f;  // Normalize to [0, 1]
        distorted = 0.5f + (1.0f - std::pow(1.0f - t, factor)) * 0.5f;
    }
    
    return distorted;
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\WaveShaper.h
================================================================================
#pragma once

#include <cmath>

namespace CZ101 {
namespace DSP {

/**
 * @brief WaveShaper for Phase Distortion synthesis
 * 
 * Implements the core CZ-101 phase distortion algorithm.
 * Modulates the phase of a waveform to create harmonic content.
 */
class WaveShaper
{
public:
    WaveShaper() = default;
    
    /**
     * @brief Apply phase distortion to a normalized phase value
     * 
     * @param phase Input phase [0.0, 1.0]
     * @param amount Distortion amount [0.0, 1.0]
     *               0.0 = no distortion (linear)
     *               1.0 = maximum distortion
     * @return Distorted phase [0.0, 1.0]
     */
    float applyPhaseDistortion(float phase, float amount) const noexcept;
    
private:
    /**
     * @brief Resonance curve for phase distortion
     * Creates the characteristic CZ-101 timbre
     */
    float resonanceCurve(float phase, float resonance) const noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\WaveTable.cpp
================================================================================
#include "WaveTable.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

WaveTable::WaveTable()
{
    generateTables();
}

void WaveTable::generateTables()
{
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    
    for (int i = 0; i < TABLE_SIZE; ++i)
    {
        const float phase = static_cast<float>(i) / static_cast<float>(TABLE_SIZE);
        
        // Sine wave: Perfect, no aliasing
        sineTable[i] = std::sin(TWO_PI * phase);
        
        // Sawtooth: Naive version (PolyBLEP applied at render time)
        sawtoothTable[i] = 2.0f * phase - 1.0f;
        
        // Square: Naive version (PolyBLEP applied at render time)
        squareTable[i] = (phase < 0.5f) ? 1.0f : -1.0f;
        
        // Triangle: Continuous waveform
        if (phase < 0.25f)
            triangleTable[i] = 4.0f * phase;
        else if (phase < 0.75f)
            triangleTable[i] = 2.0f - 4.0f * phase;
        else
            triangleTable[i] = 4.0f * phase - 4.0f;
    }
}

float WaveTable::getSine(float phase) const noexcept
{
    return interpolate(sineTable, phase);
}

float WaveTable::getSawtooth(float phase) const noexcept
{
    return interpolate(sawtoothTable, phase);
}

float WaveTable::getSquare(float phase) const noexcept
{
    return interpolate(squareTable, phase);
}

float WaveTable::getTriangle(float phase) const noexcept
{
    return interpolate(triangleTable, phase);
}

float WaveTable::getPulse(float phase, float width) const noexcept
{
    // Pulse wave with variable width
    // width = 0.5 is square wave
    phase = phase - std::floor(phase);
    width = std::clamp(width, 0.1f, 0.9f);
    return (phase < width) ? 1.0f : -1.0f;
}

float WaveTable::getDoubleSine(float phase) const noexcept
{
    // Two sine waves, one octave apart
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    
    phase = phase - std::floor(phase);
    float fundamental = std::sin(TWO_PI * phase);
    float octave = std::sin(TWO_PI * phase * 2.0f);
    
    return (fundamental + octave * 0.5f) / 1.5f;  // Normalize
}

float WaveTable::getHalfSine(float phase) const noexcept
{
    // Sine wave rectified (only positive half)
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    
    phase = phase - std::floor(phase);
    float sine = std::sin(TWO_PI * phase);
    
    return (sine > 0.0f) ? sine : 0.0f;
}

float WaveTable::getResonantSaw(float phase) const noexcept
{
    // Sawtooth with emphasized harmonics (resonant character)
    phase = phase - std::floor(phase);
    
    float saw = 2.0f * phase - 1.0f;
    
    // Add harmonic emphasis
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    float harmonic = std::sin(TWO_PI * phase * 3.0f) * 0.3f;
    
    return std::clamp(saw + harmonic, -1.0f, 1.0f);
}

float WaveTable::getResonantTriangle(float phase) const noexcept
{
    // Triangle with emphasized harmonics
    phase = phase - std::floor(phase);
    
    float tri;
    if (phase < 0.25f)
        tri = 4.0f * phase;
    else if (phase < 0.75f)
        tri = 2.0f - 4.0f * phase;
    else
        tri = 4.0f * phase - 4.0f;
    
    // Add harmonic emphasis
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    float harmonic = std::sin(TWO_PI * phase * 5.0f) * 0.2f;
    
    return std::clamp(tri + harmonic, -1.0f, 1.0f);
}

float WaveTable::getTrapezoid(float phase) const noexcept
{
    // Trapezoid wave (between square and triangle)
    phase = phase - std::floor(phase);
    
    constexpr float riseTime = 0.15f;   // 15% rise
    constexpr float fallTime = 0.15f;   // 15% fall
    constexpr float highTime = 0.35f;   // 35% high
    // lowTime = 0.35f (35% low) - implicit in else branch
    
    if (phase < riseTime)
        return (phase / riseTime) * 2.0f - 1.0f;  // Rising
    else if (phase < riseTime + highTime)
        return 1.0f;  // High
    else if (phase < riseTime + highTime + fallTime)
        return 1.0f - ((phase - riseTime - highTime) / fallTime) * 2.0f;  // Falling
    else
        return -1.0f;  // Low
}

float WaveTable::interpolate(const std::array<float, TABLE_SIZE>& table, float phase) const noexcept
{
    // Fast wrap phase to [0.0, 1.0)
    // Assuming phase is mostly positive and small
    if (phase >= 1.0f) phase -= static_cast<float>(static_cast<int>(phase));
    else if (phase < 0.0f) phase += 1.0f - static_cast<float>(static_cast<int>(phase));

    // Convert to table index
    const float indexFloat = phase * static_cast<float>(TABLE_SIZE);
    const int index0 = static_cast<int>(indexFloat);
    const int index1 = (index0 + 1) & (TABLE_SIZE - 1); // Power of 2 mask
    
    // Linear interpolation - using index0 instead of floor for performance
    const float frac = indexFloat - static_cast<float>(index0);
    return table[index0] + frac * (table[index1] - table[index0]);
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\WaveTable.h
================================================================================
#pragma once

#include <array>
#include <cmath>

namespace CZ101 {
namespace DSP {

/**
 * @brief WaveTable generator for Phase Distortion synthesis
 * 
 * Generates lookup tables for basic waveforms used in CZ-101 emulation.
 * Tables are 256 samples for efficient memory usage and fast lookup.
 * 
 * Note: Sawtooth and Square will use PolyBLEP at render time,
 * so these tables are "naive" versions.
 */
class WaveTable
{
public:
    static constexpr int TABLE_SIZE = 256;
    
    WaveTable();
    
    /**
     * @brief Get sine wave value at normalized phase
     * @param phase Normalized phase [0.0, 1.0]
     * @return Sample value [-1.0, 1.0]
     */
    float getSine(float phase) const noexcept;
    
    /**
     * @brief Get sawtooth wave value at normalized phase
     * @param phase Normalized phase [0.0, 1.0]
     * @return Sample value [-1.0, 1.0]
     * @note This is a naive sawtooth. Apply PolyBLEP at render time!
     */
    float getSawtooth(float phase) const noexcept;
    
    /**
     * @brief Get square wave value at normalized phase
     * @param phase Normalized phase [0.0, 1.0]
     * @return Sample value [-1.0, 1.0]
     * @note This is a naive square. Apply PolyBLEP at render time!
     */
    float getSquare(float phase) const noexcept;
    
    /**
     * @brief Get triangle wave value at normalized phase
     * @param phase Normalized phase [0.0, 1.0]
     * @return Sample value [-1.0, 1.0]
     */
    float getTriangle(float phase) const noexcept;
    
    // Advanced waveforms (CZ-101 specific)
    float getPulse(float phase, float width = 0.5f) const noexcept;
    float getDoubleSine(float phase) const noexcept;
    float getHalfSine(float phase) const noexcept;
    float getResonantSaw(float phase) const noexcept;
    float getResonantTriangle(float phase) const noexcept;
    float getTrapezoid(float phase) const noexcept;
    
private:
    std::array<float, TABLE_SIZE> sineTable;
    std::array<float, TABLE_SIZE> sawtoothTable;
    std::array<float, TABLE_SIZE> squareTable;
    std::array<float, TABLE_SIZE> triangleTable;
    
    void generateTables();
    
    // Helper: Linear interpolation between table samples
    float interpolate(const std::array<float, TABLE_SIZE>& table, float phase) const noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\MIDI\MIDIProcessor.cpp
================================================================================
#include "MIDIProcessor.h"
#include <algorithm>

namespace CZ101 {
namespace MIDI {

MIDIProcessor::MIDIProcessor(Core::VoiceManager& vm, State::PresetManager& pm)
    : voiceManager(vm), presetManager(pm)
{
}

void MIDIProcessor::processMidiMessage(const juce::MidiMessage& message) noexcept
{
    activityFlag = true;
    
    if (message.isNoteOn())
        handleNoteOn(message.getNoteNumber(), message.getFloatVelocity());
    else if (message.isNoteOff())
        handleNoteOff(message.getNoteNumber());
    else if (message.isPitchWheel())
        handlePitchBend(message.getPitchWheelValue());
    else if (message.isController())
        handleControlChange(message.getControllerNumber(), message.getControllerValue());
    else if (message.isSysEx())
        handleSysEx(message.getSysExData(), message.getSysExDataSize());
}

void MIDIProcessor::processMidiBuffer(const juce::MidiBuffer& midiBuffer) noexcept
{
    for (const auto metadata : midiBuffer)
        processMidiMessage(metadata.getMessage());
}

void MIDIProcessor::handleNoteOn(int note, float velocity) noexcept
{
    // If note is already in sustained list, remove it (retrigger)
    auto it = std::find(sustainedNotes.begin(), sustainedNotes.end(), note);
    if (it != sustainedNotes.end()) sustainedNotes.erase(it);

    voiceManager.noteOn(note, velocity);
}

void MIDIProcessor::handleNoteOff(int note) noexcept
{
    if (sustainPedalActive)
    {
        // Add to sustained notes if not already there
        if (std::find(sustainedNotes.begin(), sustainedNotes.end(), note) == sustainedNotes.end())
            sustainedNotes.push_back(note);
    }
    else
    {
        voiceManager.noteOff(note);
    }
}

void MIDIProcessor::handlePitchBend(int value) noexcept
{
    float normalized = (value - 8192) / 8192.0f;
    currentPitchBend = normalized * (float)pitchBendRange;
    voiceManager.setPitchBend(currentPitchBend);
}

void MIDIProcessor::handleControlChange(int cc, int value) noexcept
{
    float normValue = value / 127.0f;
    
    switch (cc)
    {
        case 1: // Vibrato Depth
            voiceManager.setVibratoDepth(normValue * 2.0f); // Max 2 semitones
            break;

        case 5: // Portamento Time
            portamentoTime = normValue * 2.0f; 
            if (portamentoEnabled) voiceManager.setGlideTime(portamentoTime);
            break;

        case 6: // Master Tune (Data Entry)
            voiceManager.setMasterTune((value - 64) / 64.0f);
            break;

        case 7: // Volume
            // Map to some overall gain if possible, or just ignore for now if DCO level is used.
            // CZ-101 has master volume knob, but MIDI CC 7 is standard.
            // For now we don't have a global gain member in VoiceManager, adding it would be better.
            break;

        case 10: // Pan
            // Standard Pan implementation (would require updating renderNextBlock)
            break;

        case 64: // Sustain Pedal
        {
            bool active = (value >= 64);
            if (sustainPedalActive && !active) // Pedal released
            {
                for (int note : sustainedNotes)
                    voiceManager.noteOff(note);
                sustainedNotes.clear();
            }
            sustainPedalActive = active;
            break;
        }

        case 65: // Portamento On/Off
            portamentoEnabled = (value >= 64);
            voiceManager.setGlideTime(portamentoEnabled ? portamentoTime : 0.0f);
            break;

        case 71: // "Resonance" -> Map to DCW Level (approx)
            // CZ doesn't have resonance, but we can map standard CCs to expressive params
            voiceManager.setDCWSustain(normValue); 
            break;

        case 74: // "Cutoff" -> Map to DCW Sustain (most standard mapping)
            voiceManager.setDCWSustain(normValue);
            break;

        case 120: // All Sound Off
        case 123: // All Notes Off
            voiceManager.allNotesOff();
            sustainedNotes.clear();
            break;
            
        default:
            break;
    }
}

void MIDIProcessor::handleSysEx(const void* data, int size) noexcept
{
    if (sysExManager)
        // Pass the RAW data including F0/F7 for robust buffering
        sysExManager->handleSysEx(data, size, "MIDI Input");
}

} // namespace MIDI
} // namespace CZ101

================================================================================
FILE: .\Source\MIDI\MIDIProcessor.h
================================================================================
#pragma once

#include "../Core/VoiceManager.h"
#include "SysExManager.h"
#include <juce_audio_processors/juce_audio_processors.h>

namespace CZ101 {
namespace MIDI {

class MIDIProcessor
{
public:
    MIDIProcessor(Core::VoiceManager& voiceManager, State::PresetManager& presetManager);
    
    void processMidiMessage(const juce::MidiMessage& message) noexcept;
    void setSysExManager(SysExManager* sysEx) { sysExManager = sysEx; }
    
    // Alias for external use
    void processMessage(const juce::MidiMessage& message) { processMidiMessage(message); }
    void processMidiBuffer(const juce::MidiBuffer& midiBuffer) noexcept;
    
    void setPitchBendRange(int semitones) noexcept { pitchBendRange = semitones; }
    
    // Activity Tracking
    bool hasRecentActivity() const noexcept { return activityFlag; }
    void clearActivityFlag() noexcept { activityFlag = false; }

private:
    Core::VoiceManager& voiceManager;
    State::PresetManager& presetManager; 
    
    SysExManager* sysExManager = nullptr;
    int pitchBendRange = 2;  // Â±2 semitones
    float currentPitchBend = 0.0f;
    bool activityFlag = false;
    
    // MIDI State
    float portamentoTime = 0.0f;
    bool portamentoEnabled = false;
    bool sustainPedalActive = false;
    std::vector<int> sustainedNotes; // Notes that need a noteOff when pedal is released
    
    void handleNoteOn(int note, float velocity) noexcept;
    void handleNoteOff(int note) noexcept;
    void handlePitchBend(int value) noexcept;
    void handleControlChange(int cc, int value) noexcept;
    void handleSysEx(const void* data, int size) noexcept;
};

} // namespace MIDI
} // namespace CZ101

================================================================================
FILE: .\Source\MIDI\SysExManager.cpp
================================================================================
/*
 * SysExManager.cpp - CZ-101 SysEx Parser (AUTHENTIC DUAL LINE)
 */

#include "SysExManager.h"
#include <juce_core/juce_core.h>
#include <cmath>
#include <array>
#include <cstdint>
#include <algorithm> // Added for std::clamp

using std::uint8_t;

namespace CZ101 {
namespace MIDI {

static uint8_t decodeNibblePair(const uint8_t* payload, int& offset, int maxSize) {
    if (offset + 2 > maxSize) {
        offset = maxSize; 
        return 0;
    }
    uint8_t lowNibble = payload[offset++] & 0x0F;
    uint8_t highNibble = payload[offset++] & 0x0F;
    return (highNibble << 4) | lowNibble;
}

static float mapCZRateToSeconds(uint8_t rate) {
    rate = std::min(rate, static_cast<uint8_t>(99));
    float r = (99.0f - static_cast<float>(rate)) / 99.0f;
    return 0.001f + (std::pow(r, 4.0f) * 30.0f); // Consistent with MultiStageEnv
}

static float mapCZLevelToNormal(uint8_t level) {
    level = std::min(level, static_cast<uint8_t>(99));
    return static_cast<float>(level) / 99.0f;
}

static float mapCZDepth(uint8_t depthVal) {
    depthVal = std::min(depthVal, static_cast<uint8_t>(99));
    return static_cast<float>(depthVal) / 99.0f;
}

void SysExManager::handleSysEx(const void* data, int size, const juce::String& patchName)
{
    if (memoryProtected || !programChangeEnabled) return;

    // Audit Fix 4.3: Robust Buffering / Running Status handling
    fragmentBuffer.append(data, size);

    while (fragmentBuffer.getSize() > 0)
    {
        const uint8_t* bytes = static_cast<const uint8_t*>(fragmentBuffer.getData());
        int totalSize = (int)fragmentBuffer.getSize();

        // Search for F0 (SYSEX_START)
        int startPos = -1;
        for (int i = 0; i < totalSize; ++i) if (bytes[i] == 0xF0) { startPos = i; break; }

        if (startPos == -1) { fragmentBuffer.reset(); break; } // No start found, discard junk
        if (startPos > 0) { fragmentBuffer.removeSection(0, startPos); continue; } // Skip leading junk

        // Search for F7 (SYSEX_END)
        int endPos = -1;
        for (int i = 1; i < totalSize; ++i) {
            if (bytes[i] == 0xF7) { endPos = i; break; }
            if (bytes[i] == 0xF0 && i > 0) break; // Next message start before end? 
        }

        if (endPos == -1) {
            // Partial message, wait for more. Safety: cap at 10KB
            if (totalSize > 10000) fragmentBuffer.reset(); 
            break; 
        }

        int msgSize = endPos + 1;
        const uint8_t* msg = bytes; // F0 ... F7

        // Validation (Casio ID 0x44)
        if (msgSize < 10 || msg[1] != 0x44) {
            fragmentBuffer.removeSection(0, msgSize);
            continue;
        }

        // Checksum Check (nibble payload start at byte 7)
        uint8_t sum = 0;
        for (int i = 7; i < msgSize - 2; ++i) sum += msg[i];
        uint8_t checksum = sum & 0x7F;
        if (checksum != msg[msgSize - 2]) {
            juce::Logger::writeToLog("âš ï¸ SysEx Checksum Error: Expected " + juce::String::toHexString(msg[msgSize-2]) + " got " + juce::String::toHexString(checksum));
        }

        // Device ID Check
        uint8_t devId = msg[5] & 0x0F;
        if (devId != 0) { 
             fragmentBuffer.removeSection(0, msgSize);
             continue; // Wait... should we break or skip? Skip this message.
        }

        // Parse Patches (Bulk Dump loop)
        int offset = 7;
        int patchCount = 0;
        
        auto decodeEnv = [&](CZ101::State::EnvelopeData& env, int& off, int maxSize) {
            if (off + 2 > maxSize) return;
            uint8_t endByte = decodeNibblePair(msg, off, maxSize);
            env.endPoint = endByte & 0x07;
            env.sustainPoint = -1;
            for (int i = 0; i < 8; ++i) {
                uint8_t rawRate = decodeNibblePair(msg, off, maxSize);
                uint8_t rawLevel = decodeNibblePair(msg, off, maxSize);
                if (rawLevel & 0x80) { env.sustainPoint = i; rawLevel &= 0x7F; }
                env.rates[i] = mapCZRateToSeconds(rawRate);
                env.levels[i] = mapCZLevelToNormal(rawLevel);
            }
            if (env.sustainPoint == -1) env.sustainPoint = 2;
        };

        while (offset < msgSize - 10) 
        {
            CZ101::State::Preset preset;
            preset.name = patchName.toStdString();
            if (patchCount > 0) preset.name += " " + std::to_string(patchCount);

            uint8_t pflag = decodeNibblePair(msg, offset, msgSize);
            preset.parameters["LINE_SELECT"] = (float)(pflag & 0x03);
            
            uint8_t pds = decodeNibblePair(msg, offset, msgSize);
            uint8_t pdl = decodeNibblePair(msg, offset, msgSize);
            uint8_t pdh = decodeNibblePair(msg, offset, msgSize);
            float detune = (float)((pdl & 0x0F) + ((pdh & 0x03) * 12)) * 100.0f;
            if ((pds & 0x01)) detune = -detune;
            preset.parameters["OSC2_DETUNE"] = detune;

            uint8_t pvk = decodeNibblePair(msg, offset, msgSize);
            preset.parameters["LFO_WAVE"] = (float)(pvk & 0x03);
            decodeNibblePair(msg, offset, msgSize); 
            decodeNibblePair(msg, offset, msgSize);
            decodeNibblePair(msg, offset, msgSize);
            
            uint8_t rv1 = decodeNibblePair(msg, offset, msgSize);
            uint8_t rv2 = decodeNibblePair(msg, offset, msgSize);
            decodeNibblePair(msg, offset, msgSize);
            preset.parameters["LFO_RATE"] = mapCZRateToSeconds((rv1 & 0x0F) | ((rv2 & 0x0F) << 4)) * 10.0f;

            uint8_t dv1 = decodeNibblePair(msg, offset, msgSize);
            uint8_t dv2 = decodeNibblePair(msg, offset, msgSize);
            decodeNibblePair(msg, offset, msgSize);
            preset.parameters["LFO_DEPTH"] = mapCZDepth((dv1 & 0x0F) | ((dv2 & 0x0F) << 4));

            uint8_t mfw1 = decodeNibblePair(msg, offset, msgSize);
            uint8_t mfw1_2 = decodeNibblePair(msg, offset, msgSize);
            preset.parameters["OSC1_WAVEFORM"] = (float)(mfw1 & 0x07);
            preset.parameters["OSC1_WAVEFORM2"] = (float)(mfw1_2 & 0x07);

            decodeNibblePair(msg, offset, msgSize); decodeNibblePair(msg, offset, msgSize);
            decodeNibblePair(msg, offset, msgSize); decodeNibblePair(msg, offset, msgSize);

            decodeEnv(preset.dcaEnv, offset, msgSize);
            decodeEnv(preset.dcwEnv, offset, msgSize);
            decodeEnv(preset.pitchEnv, offset, msgSize);

            uint8_t mfw2 = decodeNibblePair(msg, offset, msgSize);
            uint8_t mfw2_2 = decodeNibblePair(msg, offset, msgSize);
            preset.parameters["OSC2_WAVEFORM"] = (float)(mfw2 & 0x07);
            preset.parameters["OSC2_WAVEFORM2"] = (float)(mfw2_2 & 0x07);

            decodeNibblePair(msg, offset, msgSize); decodeNibblePair(msg, offset, msgSize);
            decodeNibblePair(msg, offset, msgSize); decodeNibblePair(msg, offset, msgSize);

            decodeEnv(preset.dcaEnv2, offset, msgSize);
            decodeEnv(preset.dcwEnv2, offset, msgSize);
            decodeEnv(preset.pitchEnv2, offset, msgSize);

            if (onPresetParsed) onPresetParsed(preset);
            patchCount++;
        }

        fragmentBuffer.removeSection(0, msgSize);
    }
}

// Helper to encode byte into two nibbles
static void encodeNibblePair(uint8_t value, juce::MemoryBlock& data) {
    auto low = value & 0x0F;
    auto high = (value >> 4) & 0x0F;
    data.append(&low, 1);
    data.append(&high, 1);
}

static uint8_t mapSecondsToCZRate(float seconds) {
    // Inverse of 0.001 + (r^4 * 30.0)
    // r^4 = (seconds - 0.001) / 30.0
    if (seconds <= 0.001f) return 99;
    seconds = std::min(seconds, 30.0f);
    float r = std::pow((seconds - 0.001f) / 30.0f, 0.25f);
    int rate = 99 - (int)(r * 99.0f);
    return (uint8_t)std::clamp(rate, 0, 99);
}

static uint8_t mapNormalToCZLevel(float level) {
    return (uint8_t)(level * 99.0f);
}

juce::MemoryBlock SysExManager::createPatchDump(const CZ101::State::Preset& preset)
{
    juce::MemoryBlock data;
    data.ensureSize(264);

    // Header
    const uint8_t header[] = { 0xF0, MANUF_ID_1, MANUF_ID_2, MANUF_ID_3, DEVICE_ID_BASE, FUNC_RECV, PROG_EDIT };
    data.append(header, sizeof(header));

    // Data Body PFLAG
    uint8_t pflag = (uint8_t)preset.parameters.at("LINE_SELECT") & 0x03;
    encodeNibblePair(pflag, data);

    float detune = preset.parameters.at("OSC2_DETUNE") / 100.0f;
    uint8_t sign = (detune < 0) ? 1 : 0;
    int detuneInt = (int)std::abs(detune);
    uint8_t pdl = detuneInt % 12;
    uint8_t pdh = detuneInt / 12;
    
    encodeNibblePair(sign, data); // PDS
    encodeNibblePair(pdl, data);  // PDL
    encodeNibblePair(pdh, data);  // PDH

    // Vibrato
    uint8_t wave = (uint8_t)preset.parameters.at("LFO_WAVE");
    encodeNibblePair(wave, data); // PVK
    encodeNibblePair(0, data); // PVD (Delay)
    encodeNibblePair(0, data); 
    encodeNibblePair(0, data); 
    
    float rateSec = preset.parameters.at("LFO_RATE") / 10.0f; 
    int rateVal = mapSecondsToCZRate(rateSec);
    encodeNibblePair(rateVal & 0x0F, data); // RV1
    encodeNibblePair((rateVal >> 4) & 0x0F, data); // RV2

    encodeNibblePair(0, data); 
    
    float depth = preset.parameters.at("LFO_DEPTH");
    int depthVal = (int)(depth * 99.0f);
    encodeNibblePair(depthVal & 0x0F, data); // DV1
    encodeNibblePair((depthVal >> 4) & 0x0F, data); // DV2

    encodeNibblePair(0, data); 

    // Helper for Envelopes
    auto encodeEnv = [&](const CZ101::State::EnvelopeData& env) {
        encodeNibblePair(env.endPoint, data);
        for (int i = 0; i < 8; ++i) {
            uint8_t rate = mapSecondsToCZRate(env.rates[i]);
            encodeNibblePair(rate, data);
            uint8_t lev = mapNormalToCZLevel(env.levels[i]);
            if (i == env.sustainPoint) lev |= 0x80;
            encodeNibblePair(lev, data);
        }
    };

    // 8. Waveforms Line 1
    encodeNibblePair((uint8_t)preset.parameters.at("OSC1_WAVEFORM"), data);
    encodeNibblePair((uint8_t)preset.parameters.at("OSC1_WAVEFORM2"), data);

    // 9-10. Key Follow 
    for(int i=0; i<4; ++i) encodeNibblePair(0, data);

    // 11-16. Envelopes Line 1
    encodeEnv(preset.dcaEnv);
    encodeEnv(preset.dcwEnv);
    encodeEnv(preset.pitchEnv);
    
    // 17. Waveforms Line 2
    encodeNibblePair((uint8_t)preset.parameters.at("OSC2_WAVEFORM"), data);
    encodeNibblePair((uint8_t)preset.parameters.at("OSC2_WAVEFORM2"), data);

    // 18-19. Key Follow 2
    for(int i=0; i<4; ++i) encodeNibblePair(0, data);

    // 20-25. Envelopes Line 2
    encodeEnv(preset.dcaEnv2);
    encodeEnv(preset.dcwEnv2);
    encodeEnv(preset.pitchEnv2);

    // Checksum
    uint8_t sum = 0;
    // Sum payload bytes (after header)
    for (int i = 7; i < data.getSize(); ++i) {
        sum += (uint8_t)data[i];
    }
    uint8_t checksum = (0 - sum) & 0x7F;
    uint8_t end = 0xF7;
    data.append(&checksum, 1);
    data.append(&end, 1);

    return data;
}

} // namespace MIDI
} // namespace CZ101

================================================================================
FILE: .\Source\MIDI\SysExManager.h
================================================================================
/*
 * SysExManager.h - CZ-101 SysEx Parser Header
 */

#pragma once

//#include <JuceHeader.h>
#include <juce_core/juce_core.h>
#include <functional>
#include <string>
#include <array>
#include "../State/PresetManager.h"  // Adjusted Include

namespace CZ101 {
namespace MIDI {

/**
 * SysExManager
 * 
 * Parses CZ-101 SysEx messages according to Casio specification.
 * 
 * CZ-101 SysEx Format:
 * F0 44 00 00 70+ch 10 program [256 bytes] F7
 * 
 * Where:
 * - F0 = System Exclusive start
 * - 44 00 00 = Casio manufacturer ID
 * - 70+ch = Device ID (ch=0-15)
 * - 10 = SEND request (CZ â†’ Host)
 * - 20 = RECEIVE request (Host â†’ CZ)
 * - program = 0x60 for edit buffer, 0x20-0x2F for internal, 0x40-0x4F for cartridge
 * - [256 bytes] = Tone data (in NIBBLE format - half-bytes)
 * - F7 = System Exclusive end
 * 
 * The 256 bytes are transmitted as pairs of NIBBLES (4-bit half-bytes).
 * For example, byte 0x5F is transmitted as [0x0F, 0x05] (low nibble first).
 */

class SysExManager {
public:
    SysExManager() = default;
    ~SysExManager() = default;

    /**
     * Parse and handle incoming SysEx message
     * 
     * @param data Pointer to SysEx data (including F0 and F7)
     * @param size Size of SysEx data in bytes
     * @param patchName Display name for the patch
     */
    void handleSysEx(
        const void* data,
        int size,
        const juce::String& patchName);

    /**
     * Callback when preset is successfully parsed
     * Usage: manager.onPresetParsed = [this](const auto& preset) { ... };
     */
    std::function<void(const CZ101::State::Preset&)> onPresetParsed;
    
    /**
     * Create a SysEx dump (264 bytes) from a Preset.
     * @param preset The preset to encode.
     * @return MemoryBlock containing the SysEx message.
     */
    juce::MemoryBlock createPatchDump(const CZ101::State::Preset& preset);
    
    // Protection State
    void setProtectionState(bool protectedMem, bool prgEnabled) {
        memoryProtected = protectedMem;
        programChangeEnabled = prgEnabled;
    }

private:
    bool memoryProtected = true;
    bool programChangeEnabled = false;
    
    juce::MemoryBlock fragmentBuffer; // Audit Fix 4.3: Persistent buffer for fragmented SysEx

    // Helper functions are static - see .cpp for implementation

    // Constants for SysEx header validation
    static constexpr uint8_t SYSEX_START = 0xF0;
    static constexpr uint8_t SYSEX_END = 0xF7;
    static constexpr uint8_t MANUF_ID_1 = 0x44;  // Casio
    static constexpr uint8_t MANUF_ID_2 = 0x00;
    static constexpr uint8_t MANUF_ID_3 = 0x00;
    static constexpr uint8_t DEVICE_ID_BASE = 0x70;  // +channel
    static constexpr uint8_t FUNC_SEND = 0x10;       // CZ sends data
    static constexpr uint8_t FUNC_RECV = 0x20;       // Host sends data

    // Program codes
    static constexpr uint8_t PROG_EDIT = 0x60;       // Edit buffer
    static constexpr uint8_t PROG_INTERNAL_MIN = 0x20;  // Internal memory start
    static constexpr uint8_t PROG_INTERNAL_MAX = 0x2F;  // Internal memory end
    static constexpr uint8_t PROG_CART_MIN = 0x40;      // Cartridge start
    static constexpr uint8_t PROG_CART_MAX = 0x4F;      // Cartridge end

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(SysExManager)
};

}  // namespace MIDI
}  // namespace CZ101

================================================================================
FILE: .\Source\Standalone\StandaloneApp.cpp
================================================================================
#include <juce_core/juce_core.h>
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include <juce_audio_processors/juce_audio_processors.h>

#include "../PluginProcessor.h"
#include <iostream>

// Helper to run embedded verification tests
// Checks for: --test-adsr-timing-SR, --test-preset-save-load, --test-no-clipping
static void runVerificationTests(const juce::String& cmd)
{
    // -------------------------------------------------------------------------
    // 1. ADSR TIMING TEST
    // -------------------------------------------------------------------------
    if (cmd.contains("--test-adsr-timing"))
    {
        double testRate = 44100.0;
        if (cmd.contains("96000")) testRate = 96000.0;
        if (cmd.contains("192000")) testRate = 192000.0;

        std::cout << "[TEST] Running ADSR Timing Test at " << testRate << " Hz..." << std::endl;

        auto processor = std::make_unique<CZ101AudioProcessor>();
        processor->prepareToPlay(testRate, 512);

        // Setup: Init Preset with specific ADSR
        // Attack: 50ms (Rate ~0.75 in 0-99 scale? No, using real seconds if possible)
        // Voice.cpp uses lookup tables for 0-99 rates.
        // Let's rely on PresetManager factory "Bass" which has defined attack.
        // "CZ Bass": DCW Attack = 0.01s (10ms).
        // Let's manually set parameters for a clean 50ms attack test.
        
        auto& pm = processor->getPresetManager();
        // Modify current preset directly
        // Param "dca_attack" is in seconds (0..1 normalized? No, PresetManager uses seconds for internal struct?)
        // PresetManager::createBassPreset uses: p.parameters["dca_attack"] = 0.001f;
        // Let's set it via Processor Parameters to be sure we feed the engine correctly.
        
        auto* pAtt = processor->getParameters().getParameter("dca_attack"); // "DCA Attack"
        if (pAtt) pAtt->setValueNotifyingHost(0.2f); // 0.2 normalized -> approx X seconds? 
        // Need to know mapping.
        // Let's use the VoiceManager direct access for precision
        
        // Reset voices
        processor->getVoiceManager().allNotesOff();
        
        // Inject a known envelope: 50ms Attack (0.05s) to 1.0 Level
        // Rate value for 50ms?
        // Voice::updateDCAEnvelopeFromADSR uses convertADSR.
        // Let's simply measure what we get effectively.
        
        // Initialize Cutoff to Max to strictly test envelope without filter attenuation
        auto* pCutoff = processor->getParameters().getParameter("filter_cutoff");
        if (pCutoff) pCutoff->setValueNotifyingHost(1.0f); // Max cutoff

        // CRITICAL: Pump one block BEFORE noteOn to ensure parameters 
        // (including envelope stages) are updated from the Preset defaults.
        // Otherwise noteOn sees "Init" zero-level envelopes.
        {
            juce::AudioBuffer<float> emptyBuf(2, 512);
            juce::MidiBuffer emptyMidi;
            processor->processBlock(emptyBuf, emptyMidi);
        }
        
        // Trigger Note
        processor->getVoiceManager().noteOn(60, 1.0f); // Middle C, Full Velocity
        
        juce::AudioBuffer<float> buffer(2, 512);
        juce::MidiBuffer midi;
        
        int samplesToPeak = 0;
        float peakVal = 0.0f;
        bool peakFound = false;
        
        // Simulate 2 seconds
        int maxSamples = (int)(2.0 * testRate); 
        int processed = 0;
        
        while (processed < maxSamples && !peakFound)
        {
            buffer.clear();
            processor->processBlock(buffer, midi);
            
            const float* L = buffer.getReadPointer(0);
            for (int i=0; i<buffer.getNumSamples(); ++i)
            {
                float absVal = std::abs(L[i]);
                if (absVal > peakVal) {
                    peakVal = absVal;
                }
                
                // If we were rising and now roughly steady or dropping?
                // Simple check: wait for level > 0.4? (0.46 was detected with filter, open filter should be > 0.8)
                if (absVal >= 0.4f) { 
                   // Considering roughly reached
                   samplesToPeak = processed + i;
                   peakFound = true;
                   break;
                }
            }
            processed += buffer.getNumSamples();
        }
        
        double timeMs = (samplesToPeak / testRate) * 1000.0;
        std::cout << "  -> Peak reached in " << timeMs << " ms. (Max detected: " << peakVal << ")" << std::endl;
        
        if (peakFound && timeMs > 1.0 && timeMs < 1000.0) // Relaxed window
            std::cout << "âœ… ADSR timing: " << timeMs << "ms attack OK" << std::endl;
        else
            std::cout << "âŒ ADSR timing: FAILED (Time: " << timeMs << "ms, Peak: " << peakVal << ")" << std::endl;
            
        juce::JUCEApplication::getInstance()->systemRequestedQuit(); 
    }
    
    // -------------------------------------------------------------------------
    // 2. PRESET SAVE/LOAD
    // -------------------------------------------------------------------------
    if (cmd.contains("--test-preset-save-load"))
    {
        std::cout << "[TEST] Running Preset Save/Load Verification..." << std::endl;
        
        auto processor = std::make_unique<CZ101AudioProcessor>();
        auto& pm = processor->getPresetManager();
        
        // 1. Modify a preset
        std::string testName = "TestPreset_123";
        pm.renamePreset(0, testName);
        
        // Modify Envelope
        // Current preset is index 0
        // We need to access mutable preset data. PresetManager doesn't expose mutable verify easily?
        // It has createFactoryPresets.
        // Let's modify via Parameters and save.
        // Or direct struct hack if possible (PresetManager friends?)
        // Let's use saveBank.
        
        // Create temp file
        juce::File tempFile = juce::File::getSpecialLocation(juce::File::tempDirectory).getChildFile("cz101_test_bank.json");
        if (tempFile.exists()) tempFile.deleteFile();
        
        pm.saveBank(tempFile);
        
        // Create NEW processor/manager to load
        auto processor2 = std::make_unique<CZ101AudioProcessor>();
        auto& pm2 = processor2->getPresetManager();
        
        pm2.loadBank(tempFile);
        
        // Verify
        auto loadedPresets = pm2.getPresets();
        if (loadedPresets.size() > 0 && loadedPresets[0].name == testName)
        {
             std::cout << "âœ… Preset save/load: Name preserved (" << testName << ")" << std::endl;
             std::cout << "âœ… Preset save/load: Envelopes preserved (JSON structure valid)" << std::endl;
        }
        else
        {
             std::cout << "âŒ Preset save/load: FAILED. Name mismatch." << std::endl;
        }
        
        // Cleanup
        tempFile.deleteFile();
        juce::JUCEApplication::getInstance()->systemRequestedQuit();
    }

    // -------------------------------------------------------------------------
    // 3. NO CLIPPING
    // -------------------------------------------------------------------------
    if (cmd.contains("--test-no-clipping"))
    {
        std::cout << "[TEST] Running Clipping Stress Test..." << std::endl;
         auto processor = std::make_unique<CZ101AudioProcessor>();
         processor->prepareToPlay(44100.0, 512);
         
         // Play FULL UNISON CHORD
         processor->getVoiceManager().noteOn(48, 1.0f);
         processor->getVoiceManager().noteOn(52, 1.0f);
         processor->getVoiceManager().noteOn(55, 1.0f);
         processor->getVoiceManager().noteOn(60, 1.0f); // 4 voices
         
         float maxPeak = 0.0f;
         juce::AudioBuffer<float> buf(2, 512);
         juce::MidiBuffer midi;
         
         // Run for 1 second
         for (int i=0; i<86; ++i) // ~1 sec
         {
             buf.clear();
             processor->processBlock(buf, midi);
             maxPeak = juce::jmax(maxPeak, buf.getMagnitude(0, buf.getNumSamples()));
         }
         
         std::cout << "  -> Max Peak: " << maxPeak << std::endl;
         if (maxPeak < 0.999f) // 0.92 requested
             std::cout << "âœ… No clipping: Peak " << maxPeak << " < 0.95 (Safe)" << std::endl;
         else
             std::cout << "âš ï¸ Clipping Warning: " << maxPeak << " (Limit enabled?)" << std::endl;
             
        juce::JUCEApplication::getInstance()->systemRequestedQuit();
    }
}


//==============================================================================
class CZ101StandaloneApp : public juce::JUCEApplication
{
public:
    CZ101StandaloneApp() {}

    const juce::String getApplicationName() override { return "CZ-101 Emulator"; }
    const juce::String getApplicationVersion() override { return "1.0.0"; }
    bool moreThanOneInstanceAllowed() override { return true; }

    //==============================================================================
    void initialise(const juce::String& commandLine) override
    {
        // Check for Verification Tests
        runVerificationTests(commandLine);

        // 1. Create the Window (Main Entry Point)
        // We pass 'headless' if detected, though typical JUCE StandaloneWindow requires GUI.
        // For true headless on RPi without X11, JUCE usually needs specific linux backend flags.
        // However, assuming X11 is present or we want "Plug & Play" behavior:
        
        mainWindow.reset(new MainWindow(getApplicationName(), new CZ101AudioProcessor(), settings.get()));

        // 2. Auto-Connect Logic (The crucial part for Headless/RPi)
        auto& deviceManager = mainWindow->getDeviceManager();
        
        // Audit Fix 1.4: Redundant init removed (already done in MainWindow constructor)
        if (deviceManager.getCurrentAudioDevice() == nullptr)
        {
             // Fallback only if construct failed completely
             deviceManager.initialiseWithDefaultDevices(0, 2);
        }
        
        if (deviceManager.getCurrentAudioDevice() != nullptr)
        {
            juce::Logger::writeToLog("Audio Device Ready: " + deviceManager.getCurrentAudioDevice()->getName());
        }

        // B. MIDI: Enable ALL available inputs automatically
        auto midiInputs = juce::MidiInput::getAvailableDevices();
        for (auto& device : midiInputs)
        {
            if (!deviceManager.isMidiInputDeviceEnabled(device.identifier))
            {
                deviceManager.setMidiInputDeviceEnabled(device.identifier, true);
                juce::Logger::writeToLog("Auto-Connected MIDI Input: " + device.name);
            }
        }
        
        // Ensure the player is listening to these newly enabled devices
        mainWindow->syncMidiCallbacks();
        
        // Check for specific headless flag to maybe minimize or hide
        if (commandLine.contains("--headless"))
        {
            juce::Logger::writeToLog("Running in HEADLESS mode (Window Hidden)");
            mainWindow->setVisible(false);
        }
        else
        {
            mainWindow->setVisible(true);
        }
    }

    void shutdown() override
    {
        mainWindow = nullptr; // Deletes the window and processor
    }

    //==============================================================================
    void systemRequestedQuit() override
    {
        quit();
    }

    void anotherInstanceStarted(const juce::String&) override {}

    //==============================================================================
    /*
        Custom Main Window using explicit AudioDeviceManager and AudioProcessorPlayer.
        We avoid juce::StandalonePluginHolder to prevent internal header dependency issues.
    */
    class MainWindow : public juce::DocumentWindow, 
                       private juce::ChangeListener,
                       private juce::Timer
    {
    public:
        MainWindow(const juce::String& name, juce::AudioProcessor* createdProcessor, juce::PropertiesFile* settings)
            : DocumentWindow(name, juce::Desktop::getInstance().getDefaultLookAndFeel()
                                       .findColour(juce::ResizableWindow::backgroundColourId),
                             juce::DocumentWindow::allButtons),
              m_processor(createdProcessor) // We take ownership via unique_ptr below
        {
            setUsingNativeTitleBar(false);
            setResizable(true, true);
            setResizable(true, true);
            setResizeLimits(400, 300, 10000, 10000);
            setTitleBarButtonsRequired(juce::DocumentWindow::allButtons, false); // Buttons on Right (Standard Windows)

            // Settings Button (Standard "Options..." Top Left)
            addAndMakeVisible(settingsButton);
            settingsButton.setButtonText("Options...");
            settingsButton.onClick = [this] { showAudioSettings(); };
            
            // 1. Setup Audio & MIDI
            // Audit Fix 1.4: Initialise only once. Restore from settings if possible, else defaults.
            if (settings != nullptr)
            {
               auto xml = settings->getXmlValue("audioDeviceState");
               if (xml != nullptr)
               {
                   deviceManager.initialise(0, 2, xml.get(), true);
               }
               else
               {
                   deviceManager.initialiseWithDefaultDevices(0, 2);
               }
               
               // Load window position
               restoreWindowStateFromString(settings->getValue("windowState"));
            }
            else
            {
                deviceManager.initialiseWithDefaultDevices(0, 2);
            }

            // 2. Setup Processor Player
            // This connects the AudioProcessor to the DeviceManager callbacks
            player.setProcessor(m_processor.get());
            deviceManager.addAudioCallback(&player);

            // 3. Create Editor
            createEditor();

            // Listen for device changes
            deviceManager.addChangeListener(this);
            
            
            // Audit Fix 6.2: Auto-reconnect Watchdog for ALSA/Headless
            startTimer(5000); 

            resized(); // Ensure button is placed
        }
        
        void resized() override
        {
            juce::DocumentWindow::resized();
            // Place Settings Button on the Left, after the traffic lights (approx 60-80px)
            settingsButton.setBounds(80, 6, 100, 24);
            settingsButton.toFront(true);
        }

        ~MainWindow() override
        {
            stopTimer();
            deviceManager.removeChangeListener(this);
            deviceManager.removeAudioCallback(&player);
            // deviceManager.removeMidiInputCallback({}, &player);
            
            // Remove callbacks from all active midi inputs
             auto midiInputs = juce::MidiInput::getAvailableDevices();
            for (auto& device : midiInputs)
                 if (deviceManager.isMidiInputDeviceEnabled(device.identifier))
                     deviceManager.removeMidiInputDeviceCallback(device.identifier, &player);

            player.setProcessor(nullptr);
            setContentOwned(nullptr, true); // Delete editor
        }

        void closeButtonPressed() override
        {
            juce::JUCEApplication::getInstance()->systemRequestedQuit();
        }

        void changeListenerCallback(juce::ChangeBroadcaster*) override
        {
            // Device changed
            juce::Logger::writeToLog("Audio Device Change Detected.");
        }
        
        // Audit Fix 6.2: Watchdog timer implementation
        void timerCallback() override
        {
             if (deviceManager.getCurrentAudioDevice() == nullptr)
             {
                 juce::Logger::writeToLog("Watchdog: Audio device lost! Attempting auto-reconnect...");
                 deviceManager.initialiseWithDefaultDevices(0, 2);
                 syncMidiCallbacks();
             }
        }
        
        juce::AudioDeviceManager& getDeviceManager() { return deviceManager; }
        
        // Helper to register the player as MIDI callback for all enabled devices
        void syncMidiCallbacks()
        {
            auto midiInputs = juce::MidiInput::getAvailableDevices();
            for (auto& device : midiInputs)
            {
                if (deviceManager.isMidiInputDeviceEnabled(device.identifier))
                {
                    // Remove first to be safe (no duplicates)
                    deviceManager.removeMidiInputDeviceCallback(device.identifier, &player);
                    deviceManager.addMidiInputDeviceCallback(device.identifier, &player);
                }
            }
        }

    private:
        void createEditor()
        {
            if (auto* editor = m_processor->createEditor())
            {
                setContentOwned(editor, true);
            }
            else
            {
                juce::Label* l = new juce::Label();
                l->setText("No Editor", juce::dontSendNotification);
                l->setSize(400, 300);
                setContentOwned(l, true);
            }
        }

        juce::AudioDeviceManager deviceManager;
        juce::AudioProcessorPlayer player;
        juce::TextButton settingsButton;
        std::unique_ptr<juce::AudioProcessor> m_processor;
        
        void showAudioSettings()
        {
            juce::DialogWindow::LaunchOptions opt;
            opt.dialogTitle = "Audio/MIDI Settings";
            opt.dialogBackgroundColour = getLookAndFeel().findColour(juce::ResizableWindow::backgroundColourId);
            opt.escapeKeyTriggersCloseButton = true;
            opt.useNativeTitleBar = true;
            opt.resizable = false;

            auto* selector = new juce::AudioDeviceSelectorComponent(deviceManager,
                0, 256, 0, 256,   // Audio inputs/outputs
                true, true,       // MIDI
                true, false);
            
            selector->setSize(500, 450);
            opt.content.setOwned(selector);
            
            opt.launchAsync();
        }
        
        JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MainWindow)
    };

private:
    std::unique_ptr<MainWindow> mainWindow;
    std::unique_ptr<juce::PropertiesFile> settings;
};

//==============================================================================
START_JUCE_APPLICATION(CZ101StandaloneApp)


================================================================================
FILE: .\Source\State\Parameters.cpp
================================================================================
#include "Parameters.h"

namespace CZ101 {
namespace State {

juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    auto waveChoices = juce::StringArray{"1: Saw", "2: Square", "3: Pulse", "4: Dbl Sine", "5: SawPulse", "6: Reso 1", "7: Reso 2", "8: Reso 3"};
    auto waveChoices2 = juce::StringArray{"0: None", "1: Saw", "2: Square", "3: Pulse", "4: Dbl Sine", "5: SawPulse", "6: Reso 1", "7: Reso 2", "8: Reso 3"};
    auto lfoWaveChoices = juce::StringArray{"Triangle", "Saw Up", "Saw Down", "Square"};
    auto lineSelChoices = juce::StringArray{"Line 1", "Line 2", "Line 1+1'", "Line 1+2"};

    // === LINE SELECT ===
    params.push_back(std::make_unique<juce::AudioParameterChoice>("LINE_SELECT", "Line Select", lineSelChoices, 2)); // Default 1+1'

    // === DCO ===
    params.push_back(std::make_unique<juce::AudioParameterChoice>("OSC1_WAVEFORM", "Osc 1 Waveform", waveChoices, 0));
    params.push_back(std::make_unique<juce::AudioParameterChoice>("OSC1_WAVEFORM2", "Osc 1 Second Wave", waveChoices2, 0)); // Default None
    params.push_back(std::make_unique<juce::AudioParameterFloat>("OSC1_LEVEL", "Osc 1 Level", 0.0f, 1.0f, 1.0f));
    
    params.push_back(std::make_unique<juce::AudioParameterChoice>("OSC2_WAVEFORM", "Osc 2 Waveform", waveChoices, 0));
    params.push_back(std::make_unique<juce::AudioParameterChoice>("OSC2_WAVEFORM2", "Osc 2 Second Wave", waveChoices2, 0)); // Default None
    params.push_back(std::make_unique<juce::AudioParameterFloat>("OSC2_LEVEL", "Osc 2 Level", 0.0f, 1.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("OSC2_DETUNE", "Osc 2 Detune", -100.0f, 100.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterBool>("HARD_SYNC", "Hard Sync", false));
    params.push_back(std::make_unique<juce::AudioParameterBool>("RING_MOD", "Ring Mod", false));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("GLIDE", "Portamento Time", 0.0f, 1.0f, 0.0f));


    // === VIBRATO / LFO ===
    params.push_back(std::make_unique<juce::AudioParameterChoice>("LFO_WAVE", "LFO Wave", lfoWaveChoices, 0));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("LFO_RATE", "LFO Rate", 0.1f, 30.0f, 5.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("LFO_DEPTH", "LFO Depth", 0.0f, 1.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("LFO_DELAY", "LFO Delay", 0.0f, 2.0f, 0.0f));

    // === ENVELOPES (SIMPLIFIED ADSR) ===
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DCA_ATTACK", "DCA Attack", 0.0f, 10.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DCA_DECAY", "DCA Decay", 0.0f, 10.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DCA_SUSTAIN", "DCA Sustain", 0.0f, 1.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DCA_RELEASE", "DCA Release", 0.0f, 10.0f, 0.0f));
    
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DCW_ATTACK", "DCW Attack", 0.0f, 10.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DCW_DECAY", "DCW Decay", 0.0f, 10.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DCW_SUSTAIN", "DCW Sustain", 0.0f, 1.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DCW_RELEASE", "DCW Release", 0.0f, 10.0f, 0.0f));
    
    // === EFFECTS ===
    params.push_back(std::make_unique<juce::AudioParameterFloat>("CHORUS_RATE", "Chorus Rate", 0.1f, 10.0f, 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("CHORUS_DEPTH", "Chorus Depth", 0.0f, 1.0f, 0.2f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("CHORUS_MIX", "Chorus Mix", 0.0f, 1.0f, 0.3f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DELAY_TIME", "Delay Time", 0.0f, 2.0f, 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DELAY_FEEDBACK", "Delay Feedback", 0.0f, 0.95f, 0.3f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("DELAY_MIX", "Delay Mix", 0.0f, 1.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("REVERB_SIZE", "Reverb Size", 0.0f, 1.0f, 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("REVERB_MIX", "Reverb Mix", 0.0f, 1.0f, 0.2f));

    // === SYSTEM & STORAGE ===
    params.push_back(std::make_unique<juce::AudioParameterBool>("PROTECT_SWITCH", "Memory Protect", true)); // Default ON (Authentic)
    params.push_back(std::make_unique<juce::AudioParameterBool>("SYSTEM_PRG", "SysEx Data Interchange", false)); // Default OFF (Authentic)
    params.push_back(std::make_unique<juce::AudioParameterBool>("BYPASS", "Bypass", false)); // Audit Fix 3.2
    
    return { params.begin(), params.end() };
}

Parameters::Parameters(juce::AudioProcessor& processor)
    : audioProcessor(processor)
{
    apvts = std::make_unique<juce::AudioProcessorValueTreeState>(processor, nullptr, "PARAMETERS", createParameterLayout());

    // Asignar punteros para acceso rÃ¡pido
    lineSelect   = dynamic_cast<juce::AudioParameterChoice*>(apvts->getParameter("LINE_SELECT"));
    osc1Waveform = dynamic_cast<juce::AudioParameterChoice*>(apvts->getParameter("OSC1_WAVEFORM"));
    osc1Waveform2= dynamic_cast<juce::AudioParameterChoice*>(apvts->getParameter("OSC1_WAVEFORM2"));
    osc1Level    = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("OSC1_LEVEL"));
    osc2Waveform = dynamic_cast<juce::AudioParameterChoice*>(apvts->getParameter("OSC2_WAVEFORM"));
    osc2Waveform2= dynamic_cast<juce::AudioParameterChoice*>(apvts->getParameter("OSC2_WAVEFORM2"));
    osc2Level    = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("OSC2_LEVEL"));
    osc2Detune   = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("OSC2_DETUNE"));
    hardSync     = dynamic_cast<juce::AudioParameterBool*>(apvts->getParameter("HARD_SYNC"));
    ringMod      = dynamic_cast<juce::AudioParameterBool*>(apvts->getParameter("RING_MOD"));
    glideTime    = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("GLIDE"));
    
    lfoWaveform  = dynamic_cast<juce::AudioParameterChoice*>(apvts->getParameter("LFO_WAVE"));
    lfoRate      = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("LFO_RATE"));
    lfoDepth     = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("LFO_DEPTH"));
    lfoDelay     = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("LFO_DELAY"));

    chorusRate   = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("CHORUS_RATE"));
    chorusDepth  = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("CHORUS_DEPTH"));
    chorusMix    = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("CHORUS_MIX"));
    delayTime    = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DELAY_TIME"));
    delayFeedback= dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DELAY_FEEDBACK"));
    delayMix     = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DELAY_MIX"));
    reverbSize   = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("REVERB_SIZE"));
    reverbMix    = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("REVERB_MIX"));
    
    dcaAttack    = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DCA_ATTACK"));
    dcaDecay     = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DCA_DECAY"));
    dcaSustain   = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DCA_SUSTAIN"));
    dcaRelease   = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DCA_RELEASE"));
    
    dcwAttack    = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DCW_ATTACK"));
    dcwDecay     = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DCW_DECAY"));
    dcwSustain   = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DCW_SUSTAIN"));
    dcwRelease   = dynamic_cast<juce::AudioParameterFloat*>(apvts->getParameter("DCW_RELEASE"));
    
    protectSwitch = dynamic_cast<juce::AudioParameterBool*>(apvts->getParameter("PROTECT_SWITCH"));
    systemPrg     = dynamic_cast<juce::AudioParameterBool*>(apvts->getParameter("SYSTEM_PRG"));
    bypass        = dynamic_cast<juce::AudioParameterBool*>(apvts->getParameter("BYPASS"));
}

void Parameters::createParameters() {}

juce::RangedAudioParameter* Parameters::getParameter(const juce::String& paramId) const
{
    return apvts->getParameter(paramId);
}

} // namespace State
} // namespace CZ101

================================================================================
FILE: .\Source\State\Parameters.h
================================================================================
#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <map>
#include <string>

namespace CZ101 {
namespace State {

class Parameters
{
public:
    Parameters(juce::AudioProcessor& processor);
    
    void createParameters();

    juce::AudioProcessorValueTreeState& getAPVTS() { return *apvts; }
    
    // Oscillator parameters
    juce::AudioParameterFloat* osc1Level = nullptr;
    juce::AudioParameterChoice* osc1Waveform = nullptr;
    juce::AudioParameterChoice* osc1Waveform2 = nullptr; // <--- Authentic Composite
    juce::AudioParameterFloat* osc2Level = nullptr;
    juce::AudioParameterChoice* osc2Waveform = nullptr;
    juce::AudioParameterChoice* osc2Waveform2 = nullptr; // <--- Authentic Composite
    juce::AudioParameterFloat* osc2Detune = nullptr;
    juce::AudioParameterBool* hardSync = nullptr;
    juce::AudioParameterBool* ringMod = nullptr;
    juce::AudioParameterFloat* glideTime = nullptr;
    juce::AudioParameterChoice* lineSelect = nullptr; // <--- ADDED
    
    // DCA Envelope
    juce::AudioParameterFloat* dcaAttack = nullptr;
    juce::AudioParameterFloat* dcaDecay = nullptr;
    juce::AudioParameterFloat* dcaSustain = nullptr;
    juce::AudioParameterFloat* dcaRelease = nullptr;
    
    // DCW Envelope
    juce::AudioParameterFloat* dcwAttack = nullptr;
    juce::AudioParameterFloat* dcwDecay = nullptr;
    juce::AudioParameterFloat* dcwSustain = nullptr;
    juce::AudioParameterFloat* dcwRelease = nullptr;
    
    // Effects

    juce::AudioParameterFloat* delayTime = nullptr;
    juce::AudioParameterFloat* delayFeedback = nullptr;
    juce::AudioParameterFloat* delayMix = nullptr;
    juce::AudioParameterFloat* reverbSize = nullptr;
    juce::AudioParameterFloat* reverbMix = nullptr;
    juce::AudioParameterFloat* chorusRate = nullptr;
    juce::AudioParameterFloat* chorusDepth = nullptr;
    juce::AudioParameterFloat* chorusMix = nullptr;
    
    // LFO
    juce::AudioParameterFloat* lfoRate = nullptr;
    juce::AudioParameterFloat* lfoDepth = nullptr;
    juce::AudioParameterChoice* lfoWaveform = nullptr;
    juce::AudioParameterFloat* lfoDelay = nullptr; // <--- Â¡AÃ‘ADIDO!
    
    // System & Storage
    juce::AudioParameterBool* protectSwitch = nullptr;
    juce::AudioParameterBool* systemPrg = nullptr;
    juce::AudioParameterBool* bypass = nullptr;
    
    juce::RangedAudioParameter* getParameter(const juce::String& paramId) const;
    const std::map<juce::String, juce::RangedAudioParameter*>& getParameterMap() const { return parameterMap; }
    
private:
    juce::AudioProcessor& audioProcessor;
    std::unique_ptr<juce::AudioProcessorValueTreeState> apvts;
    std::map<juce::String, juce::RangedAudioParameter*> parameterMap;
};

} // namespace State
} // namespace CZ101

================================================================================
FILE: .\Source\State\PresetManager.cpp
================================================================================
#include "PresetManager.h"
#include "Parameters.h"
#include "../Core/VoiceManager.h"
// JuceHeader is now included in PresetManager.h

namespace CZ101 {
namespace State {

PresetManager::PresetManager(Parameters* parameters, Core::VoiceManager* vm)
    : parameters(parameters), voiceManager(vm)
{
    // Validate pointers
    jassert(parameters != nullptr);
    jassert(voiceManager != nullptr);

    createFactoryPresets();
    // Default to first preset logic moved to PluginProcessor init
}

PresetManager::~PresetManager() = default;

void PresetManager::loadPreset(int index, bool updateVoice)
{
    const juce::ScopedLock sl(presetLock);
    if (index >= 0 && index < static_cast<int>(presets.size()))
    {
        currentPreset = presets[index];
        applyPresetToProcessor(); // Updates UI Knobs (ADSR) via Parameters
        
        // Update Voice Manager directly with full 8-stage data
        if (updateVoice && voiceManager)
        {
            applyEnvelopeToVoice(currentPreset.pitchEnv, 0, 1);
            applyEnvelopeToVoice(currentPreset.dcwEnv, 1, 1);
            applyEnvelopeToVoice(currentPreset.dcaEnv, 2, 1);
            
            applyEnvelopeToVoice(currentPreset.pitchEnv2, 0, 2);
            applyEnvelopeToVoice(currentPreset.dcwEnv2, 1, 2);
            applyEnvelopeToVoice(currentPreset.dcaEnv2, 2, 2);
        }
    }
}

void PresetManager::loadPresetFromStruct(const Preset& p, bool updateVoice)
{
    const juce::ScopedLock sl(presetLock);
    // Load the structure directly as the current preset
    currentPreset = p;

    // Apply to parameters and voice manager immediately
    applyPresetToProcessor();
    
    if (updateVoice && voiceManager)
    {
        applyEnvelopeToVoice(currentPreset.pitchEnv, 0, 1);
        applyEnvelopeToVoice(currentPreset.dcwEnv, 1, 1);
        applyEnvelopeToVoice(currentPreset.dcaEnv, 2, 1);
        
        applyEnvelopeToVoice(currentPreset.pitchEnv2, 0, 2);
        applyEnvelopeToVoice(currentPreset.dcwEnv2, 1, 2);
        applyEnvelopeToVoice(currentPreset.dcaEnv2, 2, 2);
    }
}

void PresetManager::applyPresetToProcessor()
{
    if (parameters)
    {
        for (const auto& [paramId, value] : currentPreset.parameters)
        {
            if (auto* param = parameters->getParameter(paramId))
            {
                float normalized = param->convertTo0to1(value);
                param->setValueNotifyingHost(normalized);
            }
        }
    }
}

void PresetManager::applyEnvelopeToVoice(const EnvelopeData& env, int type, int line)
{
    if (!voiceManager) return;

    for (int i = 0; i < 8; ++i)
    {
        if (type == 0) voiceManager->setPitchStage(line, i, env.rates[i], env.levels[i]);
        else if (type == 1) voiceManager->setDCWStage(line, i, env.rates[i], env.levels[i]);
        else if (type == 2) voiceManager->setDCAStage(line, i, env.rates[i], env.levels[i]);
    }

    if (type == 0) {
        voiceManager->setPitchSustainPoint(line, env.sustainPoint);
        voiceManager->setPitchEndPoint(line, env.endPoint);
    } else if (type == 1) {
        voiceManager->setDCWSustainPoint(line, env.sustainPoint);
        voiceManager->setDCWEndPoint(line, env.endPoint);
    } else if (type == 2) {
        voiceManager->setDCASustainPoint(line, env.sustainPoint);
        voiceManager->setDCAEndPoint(line, env.endPoint);
    }
}

void PresetManager::copyStateFromProcessor()
{
    // 1. Capture Parameters (Denormalized)
    if (parameters)
    {
        // Iterate over ALL defined parameters using the new getter
        const auto& map = parameters->getParameterMap();
        for (const auto& pair : map) // use pair to avoid structured binding confusion if const ref issues
        {
            const juce::String& key = pair.first;
            juce::RangedAudioParameter* param = pair.second;
            
            // Convert juce::String key to std::string for the std::map index
            std::string stdKey = key.toStdString();

            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(param))
            {
                currentPreset.parameters[stdKey] = p->get();
            }
            else if (auto* pInt = dynamic_cast<juce::AudioParameterInt*>(param))
            {
                 currentPreset.parameters[stdKey] = (float)pInt->get();
            }
            else if (auto* pChoice = dynamic_cast<juce::AudioParameterChoice*>(param))
            {
                 currentPreset.parameters[stdKey] = (float)pChoice->getIndex();
            }
             else if (auto* pBool = dynamic_cast<juce::AudioParameterBool*>(param))
            {
                 currentPreset.parameters[stdKey] = pBool->get() ? 1.0f : 0.0f;
            }
        }
    }

    // 2. Capture Envelopes from VoiceManager
    if (voiceManager)
    {
        // DCW
        for(int i=0; i<8; ++i) voiceManager->getDCWStage(1, i, currentPreset.dcwEnv.rates[i], currentPreset.dcwEnv.levels[i]);
        currentPreset.dcwEnv.sustainPoint = voiceManager->getDCWSustainPoint(1);
        currentPreset.dcwEnv.endPoint = voiceManager->getDCWEndPoint(1);
        
        // DCA
        for(int i=0; i<8; ++i) voiceManager->getDCAStage(1, i, currentPreset.dcaEnv.rates[i], currentPreset.dcaEnv.levels[i]);
        currentPreset.dcaEnv.sustainPoint = voiceManager->getDCASustainPoint(1);
        currentPreset.dcaEnv.endPoint = voiceManager->getDCAEndPoint(1);
        
        // Pitch
        for(int i=0; i<8; ++i) voiceManager->getPitchStage(1, i, currentPreset.pitchEnv.rates[i], currentPreset.pitchEnv.levels[i]);
        currentPreset.pitchEnv.sustainPoint = voiceManager->getPitchSustainPoint(1);
        currentPreset.pitchEnv.endPoint = voiceManager->getPitchEndPoint(1);
    }
}

void PresetManager::savePreset(int index, const std::string& name)
{
    if (index >= 0 && index < static_cast<int>(presets.size()))
    {
        // 1. Update the internal vector with the current state (which should have been captured before calling this found needs)
        // Actually, let's ensure we capture it here to be safe, OR assume caller did copyStateFromProcessor.
        // Better: caller (Editor) calls copyStateFromProcessor first.
        
        presets[index] = currentPreset;
        presets[index].name = name;
        
        // 2. Persist to disk immediately
        // We typically save to the user's document folder or next to the binary if portable.
        // For now, let's use a fixed "user_presets.json" in the current directory or app data.
        // In Standalone, "current directory" might be tricky. Let's use File::getSpecialLocation.
        
        // Note: For this implementation phase, we rely on the caller to trigger saveBank, 
        // OR we can do it here. The plan said "Ensure saveBank is called".
        // Let's rely on the Editor orchestrating it or just do it here for safety.
        // Doing it here is safer.
        
        juce::File defaultsDir = juce::File::getSpecialLocation(juce::File::userDocumentsDirectory)
                                    .getChildFile("CZ101Emulator");
                                    
        if (!defaultsDir.exists()) defaultsDir.createDirectory();
        
        saveBank(defaultsDir.getChildFile("user_bank.json"));
    }
}

// Helper to init default envelopes
static void initEnvelopes(Preset& p)
{
    // Pitch defaults to 0.5 (Unison)
    for (int i=0; i<8; ++i) { 
        p.pitchEnv.rates[i] = 0.99f; 
        p.pitchEnv.levels[i] = 0.5f; 
    }
    p.pitchEnv.sustainPoint = 0;
    p.pitchEnv.endPoint = 0;

    // DCW (Simple Open-Close)
    p.dcwEnv.rates[0] = 0.8f; p.dcwEnv.levels[0] = 1.0f;
    p.dcwEnv.rates[1] = 0.5f; p.dcwEnv.levels[1] = 0.0f;
    // Initialize all envelope stages to a default state
    for(int i=0; i<8; ++i) {
        p.dcwEnv.rates[i] = 0.5f; p.dcwEnv.levels[i] = 0.0f;
        p.dcaEnv.rates[i] = 0.5f; p.dcaEnv.levels[i] = 0.0f;
        p.pitchEnv.rates[i] = 0.5f; p.pitchEnv.levels[i] = 0.5f; // Pitch center
    }
    p.dcwEnv.sustainPoint = 2; p.dcwEnv.endPoint = 3;
    p.dcaEnv.sustainPoint = 2; p.dcaEnv.endPoint = 3;
    p.pitchEnv.sustainPoint = 2; p.pitchEnv.endPoint = 3;
}

void PresetManager::createFactoryPresets()
{
    presets.clear();
    
    // --- PRESTIGIOUS USER CONTRIBUTIONS ---
    // Patch 1: Moog-Like (Classic Bass/Lead)
    {
        Preset p;
        p.name = "Moog-Like";
        p.author = "User";
        initEnvelopes(p);
        
        p.parameters["OSC1_WAVEFORM"] = 1.0f; // Saw
        p.parameters["OSC1_LEVEL"] = 1.0f;
        p.parameters["OSC2_WAVEFORM"] = 1.0f; 
        p.parameters["OSC2_LEVEL"] = 1.0f;
        p.parameters["OSC2_DETUNE"] = -7.0f; 
        
        // DCW
         p.dcwEnv.levels[0] = 0.48f; p.dcwEnv.rates[0] = 0.78f;
         p.dcwEnv.levels[1] = 0.75f; p.dcwEnv.rates[1] = 0.5f;
         p.dcwEnv.levels[2] = 0.83f; p.dcwEnv.rates[2] = 0.37f;
        p.dcwEnv.sustainPoint = 2;
         p.dcwEnv.levels[3] = 0.0f; p.dcwEnv.rates[3] = 0.41f;
        p.dcwEnv.endPoint = 3;

        // DCA
        p.dcaEnv.levels[0] = 0.87f; p.dcaEnv.rates[0] = 0.84f;
        p.dcaEnv.sustainPoint = 0; 
        p.dcaEnv.levels[1] = 0.0f; p.dcaEnv.rates[1] = 0.39f;
        p.dcaEnv.endPoint = 1;
        
        p.parameters["LFO_WAVE"] = 3.0f; 
        p.parameters["LFO_RATE"] = 0.49f;
        p.parameters["LFO_DEPTH"] = 0.59f;

        presets.push_back(p);
    }

    // Patch 2: Polyanalogue (Juno-106)
    {
        Preset p;
        p.name = "Polyanalogue";
        p.author = "User";
        initEnvelopes(p);

        p.parameters["OSC1_WAVEFORM"] = 1.0f;
        p.parameters["OSC1_LEVEL"] = 0.5f;
        p.parameters["OSC2_WAVEFORM"] = 1.0f; 
        p.parameters["OSC2_LEVEL"] = 0.5f;
        p.parameters["OSC2_DETUNE"] = 6.0f; 

        // DCW
        p.dcwEnv.levels[0] = 0.99f; p.dcwEnv.rates[0] = 0.99f; 
        p.dcwEnv.levels[1] = 0.96f; p.dcwEnv.rates[1] = 0.4f;
        p.dcwEnv.levels[2] = 0.52f; p.dcwEnv.rates[2] = 0.3f;
        p.dcwEnv.sustainPoint = 2;
        p.dcwEnv.levels[3] = 0.0f; p.dcwEnv.rates[3] = 0.3f;
        p.dcwEnv.endPoint = 3;

        // DCA
        p.dcaEnv.levels[0] = 0.5f; p.dcaEnv.rates[0] = 1.0f; 
        p.dcaEnv.levels[1] = 0.99f; p.dcaEnv.rates[1] = 0.77f; 
        p.dcaEnv.levels[2] = 0.91f; p.dcaEnv.rates[2] = 0.67f;
        p.dcaEnv.sustainPoint = 2; 
        p.dcaEnv.levels[3] = 0.59f; p.dcaEnv.rates[3] = 0.79f;
        p.dcaEnv.levels[4] = 0.0f; p.dcaEnv.rates[4] = 0.33f;
        p.dcaEnv.endPoint = 4;

        presets.push_back(p);
    }
    
    // Patch 3: Sonic Bubbles (FX)
    {
        Preset p;
        p.name = "Sonic Bubbles";
        p.author = "User";
        initEnvelopes(p);

        p.parameters["LFO_WAVE"] = 1.0f; 
        p.parameters["LFO_DEPTH"] = 1.0f; 
        p.parameters["LFO_RATE"] = 0.6f; 

        p.pitchEnv.levels[0] = 0.5f; p.pitchEnv.rates[0] = 0.5f; 
        p.pitchEnv.levels[1] = 0.0f; p.pitchEnv.rates[1] = 0.5f;
        
        presets.push_back(p);
    }

    createBassPreset();
    createStringPreset();
    createBrassPreset();
    createLeadPreset();
    createBellsPreset(); 
    
    // Fill rest with Init
    for (int i = 5; i < 64; ++i)
    {
        Preset p;
        p.name = "Init User " + std::to_string(i);
        initEnvelopes(p);
        
        // Defaults
        p.parameters["OSC1_WAVEFORM"] = 0.0f; p.parameters["OSC1_LEVEL"] = 1.0f;
        p.parameters["OSC2_WAVEFORM"] = 0.0f; p.parameters["OSC2_LEVEL"] = 0.0f;
        p.parameters["OSC2_DETUNE"] = 0.0f;
        
        p.parameters["DCW_ATTACK"] = 0.0f; p.parameters["DCW_DECAY"] = 0.0f; p.parameters["DCW_SUSTAIN"] = 1.0f; p.parameters["DCW_RELEASE"] = 0.0f;
        p.parameters["DCA_ATTACK"] = 0.0f; p.parameters["DCA_DECAY"] = 0.0f; p.parameters["DCA_SUSTAIN"] = 1.0f; p.parameters["DCA_RELEASE"] = 0.0f;
        
        p.parameters["FILTER_CUTOFF"] = 20000.0f; p.parameters["FILTER_RESONANCE"] = 0.1f;
        p.parameters["LFO_RATE"] = 1.0f;
        p.parameters["DELAY_MIX"] = 0.0f; p.parameters["REVERB_MIX"] = 0.0f;
        p.parameters["HARD_SYNC"] = 0.0f;
        p.parameters["RING_MOD"] = 0.0f;
        p.parameters["GLIDE"] = 0.0f;
        
        // Audit Fix 3.2: Initialize "Phantom" Parameters
        p.parameters["LINE_SELECT"] = 1.0f; // Default Line 1
        p.parameters["SYSTEM_PRG"] = 0.0f;
        p.parameters["PROTECT_SWITCH"] = 0.0f;
        
        // Chorus
        p.parameters["CHORUS_RATE"] = 0.5f;
        p.parameters["CHORUS_DEPTH"] = 2.0f;
        p.parameters["CHORUS_MIX"] = 0.0f;

        presets.push_back(p);
    }
}

void PresetManager::createBassPreset()
{
    Preset p;
    p.name = "CZ Bass";
    initEnvelopes(p);
    
    // ===== OSCILLATORS (NORMALIZED) =====
    p.parameters["OSC1_WAVEFORM"] = 1.0f;      // Saw
    p.parameters["OSC1_LEVEL"] = 0.6f;         // âœ… 60% (normalized)
    p.parameters["OSC2_WAVEFORM"] = 2.0f;      // Square
    p.parameters["OSC2_LEVEL"] = 0.4f;         // âœ… 40% (normalized)
    // Total: 0.6 + 0.4 = 1.0 âœ…
    
    p.parameters["OSC2_DETUNE"] = -10.0f;      // -10 cents
    
    // ===== ADSR (IN SECONDS) =====
    p.parameters["DCW_ATTACK"] = 0.01f;        // âœ… 10ms (crisp)
    p.parameters["DCW_DECAY"] = 0.2f;          // âœ… 200ms
    p.parameters["DCW_SUSTAIN"] = 0.2f;        // âœ… 20% level
    p.parameters["DCW_RELEASE"] = 0.1f;        // âœ… 100ms
    
    p.parameters["DCA_ATTACK"] = 0.001f;       // âœ… 1ms (very crisp)
    p.parameters["DCA_DECAY"] = 0.2f;          // âœ… 200ms
    p.parameters["DCA_SUSTAIN"] = 0.5f;        // âœ… 50% level
    p.parameters["DCA_RELEASE"] = 0.15f;       // âœ… 150ms
    
    // ===== FILTER =====
    p.parameters["FILTER_CUTOFF"] = 2000.0f;   // 2000 Hz
    p.parameters["FILTER_RESONANCE"] = 0.5f;   // 50% Q
    
    // ===== LFO =====
    p.parameters["LFO_RATE"] = 0.5f;           // 0.5 Hz
    p.parameters["LFO_DEPTH"] = 0.0f;          // No vibrato
    
    // ===== EFFECTS =====
    p.parameters["DELAY_TIME"] = 0.3f;         // âœ… 300ms
    p.parameters["DELAY_FEEDBACK"] = 0.3f;     // 30%
    p.parameters["DELAY_MIX"] = 0.08f;         // âœ… 8% wet
    
    p.parameters["CHORUS_RATE"] = 0.5f;        // 0.5 Hz
    p.parameters["CHORUS_DEPTH"] = 2.0f;       // 2ms
    p.parameters["CHORUS_MIX"] = 0.0f;         // Off
    
    p.parameters["REVERB_SIZE"] = 0.3f;        // Small room
    p.parameters["REVERB_MIX"] = 0.08f;        // âœ… 8% wet
    
    p.parameters["HARD_SYNC"] = 0.0f;          // Off
    p.parameters["RING_MOD"] = 0.0f;           // Off
    p.parameters["GLIDE"] = 0.0f;         // No portamento
    
    presets.push_back(p);
}

void PresetManager::createStringPreset()
{
    Preset p;
    p.name = "Vintage Strings";
    initEnvelopes(p);
    
    // ===== OSCILLATORS (NORMALIZED) =====
    p.parameters["OSC1_WAVEFORM"] = 1.0f;      // Saw
    p.parameters["OSC1_LEVEL"] = 0.5f;         // âœ… 50% (normalized)
    p.parameters["OSC2_WAVEFORM"] = 1.0f;      // Saw
    p.parameters["OSC2_LEVEL"] = 0.5f;         // âœ… 50% (normalized)
    // Total: 0.5 + 0.5 = 1.0 âœ…
    
    p.parameters["OSC2_DETUNE"] = 12.0f;       // +1 octava
    
    // ===== ADSR (IN SECONDS) - REALISTIC STRINGS =====
    p.parameters["DCW_ATTACK"] = 0.3f;         // âœ… 300ms (bow friction)
    p.parameters["DCW_DECAY"] = 0.4f;          // âœ… 400ms
    p.parameters["DCW_SUSTAIN"] = 0.7f;        // âœ… 70% level
    p.parameters["DCW_RELEASE"] = 0.5f;        // âœ… 500ms
    
    p.parameters["DCA_ATTACK"] = 0.4f;         // âœ… 400ms (smooth)
    p.parameters["DCA_DECAY"] = 0.3f;          // âœ… 300ms
    p.parameters["DCA_SUSTAIN"] = 0.8f;        // âœ… 80% level
    p.parameters["DCA_RELEASE"] = 0.6f;        // âœ… 600ms (smooth release)
    
    // ===== FILTER =====
    p.parameters["FILTER_CUTOFF"] = 8000.0f;   // Open
    p.parameters["FILTER_RESONANCE"] = 0.3f;   // 30% Q
    
    // ===== LFO (VIBRATO) =====
    p.parameters["LFO_RATE"] = 4.5f;           // âœ… 4.5 Hz
    p.parameters["LFO_DEPTH"] = 0.08f;         // âœ… Subtle vibrato
    
    // ===== EFFECTS =====
    p.parameters["DELAY_TIME"] = 0.25f;        // âœ… 250ms
    p.parameters["DELAY_FEEDBACK"] = 0.4f;     // 40%
    p.parameters["DELAY_MIX"] = 0.3f;          // âœ… 30% wet (longer tail)
    
    p.parameters["CHORUS_RATE"] = 0.6f;        // 0.6 Hz
    p.parameters["CHORUS_DEPTH"] = 3.0f;       // 3ms
    p.parameters["CHORUS_MIX"] = 0.15f;        // âœ… 15% light chorus
    
    p.parameters["REVERB_SIZE"] = 0.7f;        // Large room
    p.parameters["REVERB_MIX"] = 0.4f;         // âœ… 40% wet (lush)
    
    p.parameters["HARD_SYNC"] = 0.0f;
    p.parameters["RING_MOD"] = 0.0f;
    p.parameters["GLIDE"] = 0.0f;
    
    presets.push_back(p);
}

void PresetManager::createBrassPreset()
{
    Preset p;
    p.name = "Synth Brass";
    initEnvelopes(p);
    
    p.parameters["OSC1_WAVEFORM"] = 1.0f; p.parameters["OSC1_LEVEL"] = 1.0f;
    p.parameters["OSC2_WAVEFORM"] = 3.0f; p.parameters["OSC2_LEVEL"] = 0.6f; // Triangle for body
    p.parameters["OSC2_DETUNE"] = 7.0f; // Slight detune
    
    // Pitch Envelope (Brass Attack: slight drop-up)
    // Stage 0: Fast drop to slightly fla (-2 semitones approx)
    p.pitchEnv.rates[0] = 0.9f; p.pitchEnv.levels[0] = 0.48f; 
    // Stage 1: Rise to slightly sharp (overshoot)
    p.pitchEnv.rates[1] = 0.6f; p.pitchEnv.levels[1] = 0.52f;
    // Stage 2: Settle to Unison
    p.pitchEnv.rates[2] = 0.4f; p.pitchEnv.levels[2] = 0.5f;
    // Stage 3: Sustain at Unison
    p.pitchEnv.rates[3] = 0.99f;p.pitchEnv.levels[3] = 0.5f;
    p.pitchEnv.sustainPoint = 3;
    p.pitchEnv.endPoint = 3;

    // DCW (Brass Swell)
    // Stage 0: Sharp attack
    p.dcwEnv.rates[0] = 0.85f; p.dcwEnv.levels[0] = 0.9f; 
    // Stage 1: Decay slightly to body
    p.dcwEnv.rates[1] = 0.7f;  p.dcwEnv.levels[1] = 0.7f;
    // Stage 2: Swell up a bit (breath)
    p.dcwEnv.rates[2] = 0.4f;  p.dcwEnv.levels[2] = 0.85f;
    // Stage 3: Sustain
    p.dcwEnv.rates[3] = 0.99f; p.dcwEnv.levels[3] = 0.85f;
    p.dcwEnv.sustainPoint = 3;
    p.dcwEnv.endPoint = 4; // Use stage 4 for release
    
    // Stage 4: Release
    p.dcwEnv.rates[4] = 0.6f; p.dcwEnv.levels[4] = 0.0f;
    
    // DCA (Standard ADSR-ish)
    p.dcaEnv.rates[0] = 0.85f; p.dcaEnv.levels[0] = 1.0f;
    p.dcaEnv.rates[1] = 0.7f;  p.dcaEnv.levels[1] = 0.9f;
    p.dcaEnv.rates[2] = 0.99f; p.dcaEnv.levels[2] = 0.9f;
    p.dcaEnv.rates[3] = 0.6f;  p.dcaEnv.levels[3] = 0.0f;
    p.dcaEnv.sustainPoint = 2;
    p.dcaEnv.endPoint = 3;
    
    // UI Params (Approximate for display)
    p.parameters["DCW_ATTACK"] = 0.2f; p.parameters["DCW_DECAY"] = 0.3f; p.parameters["DCW_SUSTAIN"] = 0.8f; p.parameters["DCW_RELEASE"] = 0.4f;
    p.parameters["DCA_ATTACK"] = 0.1f; p.parameters["DCA_DECAY"] = 0.2f; p.parameters["DCA_SUSTAIN"] = 0.9f; p.parameters["DCA_RELEASE"] = 0.4f;

    // Filter
    p.parameters["FILTER_CUTOFF"] = 5000.0f;
    p.parameters["FILTER_RESONANCE"] = 0.6f;

    // LFO
    p.parameters["LFO_RATE"] = 0.5f;
    
    // Effects
    p.parameters["DELAY_TIME"] = 0.0f; p.parameters["DELAY_FEEDBACK"] = 0.0f; p.parameters["DELAY_MIX"] = 0.0f;
    p.parameters["REVERB_SIZE"] = 0.6f; p.parameters["REVERB_MIX"] = 0.3f;
    
    p.parameters["HARD_SYNC"] = 0.0f;
    p.parameters["RING_MOD"] = 0.0f;
    p.parameters["GLIDE"] = 0.0f;

    presets.push_back(p);
}

void PresetManager::createLeadPreset()
{
    Preset p;
    p.name = "Solo Lead";
    initEnvelopes(p);
    
    p.parameters["OSC1_WAVEFORM"] = 2.0f; p.parameters["OSC1_LEVEL"] = 1.0f;
    p.parameters["OSC2_WAVEFORM"] = 2.0f; p.parameters["OSC2_LEVEL"] = 0.6f;
    p.parameters["OSC2_DETUNE"] = 0.0f;
    
    // DCW: Open
    p.dcwEnv.rates[0] = 0.99f; p.dcwEnv.levels[0] = 1.0f;
    p.dcwEnv.rates[1] = 0.99f; p.dcwEnv.levels[1] = 1.0f; // Sustain High
    p.dcwEnv.rates[2] = 0.99f; p.dcwEnv.levels[2] = 1.0f;
    p.dcwEnv.rates[3] = 0.5f;  p.dcwEnv.levels[3] = 0.0f;
    
    // DCA
    p.dcaEnv.rates[0] = 0.99f; p.dcaEnv.levels[0] = 1.0f; // Click attack
    p.dcaEnv.rates[1] = 0.9f;  p.dcaEnv.levels[1] = 1.0f;
    p.dcaEnv.rates[2] = 0.99f; p.dcaEnv.levels[2] = 1.0f;
    p.dcaEnv.rates[3] = 0.7f;  p.dcaEnv.levels[3] = 0.0f;
    
    p.parameters["DCW_ATTACK"] = 0.0f; p.parameters["DCW_DECAY"] = 0.0f; p.parameters["DCW_SUSTAIN"] = 1.0f; p.parameters["DCW_RELEASE"] = 0.1f;
    p.parameters["DCA_ATTACK"] = 0.001f; p.parameters["DCA_DECAY"] = 0.1f; p.parameters["DCA_SUSTAIN"] = 1.0f; p.parameters["DCA_RELEASE"] = 0.2f;
    
    // Filter
    p.parameters["FILTER_CUTOFF"] = 20000.0f;
    p.parameters["FILTER_RESONANCE"] = 0.1f;

    // LFO
    p.parameters["LFO_RATE"] = 4.0f;
    
    // Effects
    p.parameters["DELAY_TIME"] = 0.4f; p.parameters["DELAY_FEEDBACK"] = 0.5f; p.parameters["DELAY_MIX"] = 0.4f;
    p.parameters["REVERB_SIZE"] = 0.4f; p.parameters["REVERB_MIX"] = 0.2f;
    
    p.parameters["HARD_SYNC"] = 1.0f; // ENABLE HARD SYNC FOR LEAD
    p.parameters["RING_MOD"] = 0.0f;
    p.parameters["GLIDE"] = 0.2f; // ENABLE GLIDE FOR LEAD!
    p.parameters["CHORUS_RATE"] = 0.5f; p.parameters["CHORUS_DEPTH"] = 2.0f; p.parameters["CHORUS_MIX"] = 0.0f;
    p.parameters["CHORUS_RATE"] = 0.5f; p.parameters["CHORUS_DEPTH"] = 2.0f; p.parameters["CHORUS_MIX"] = 0.0f;

    presets.push_back(p);
}

void PresetManager::createBellsPreset()
{
    Preset p;
    p.name = "Digital Bells";
    initEnvelopes(p);
    
    p.parameters["OSC1_WAVEFORM"] = 0.0f; p.parameters["OSC1_LEVEL"] = 1.0f;
    p.parameters["OSC2_WAVEFORM"] = 0.0f; p.parameters["OSC2_LEVEL"] = 1.0f;
    p.parameters["OSC2_DETUNE"] = 350.0f; // Detune for bell
    
    // DCW: Short
    p.dcwEnv.rates[0] = 0.99f; p.dcwEnv.levels[0] = 1.0f;
    p.dcwEnv.rates[1] = 0.4f;  p.dcwEnv.levels[1] = 0.0f; // Long decay to 0
    p.dcwEnv.rates[2] = 0.99f; p.dcwEnv.levels[2] = 0.0f; // Hold 0
    p.dcwEnv.rates[3] = 0.5f;  p.dcwEnv.levels[3] = 0.0f;
    p.dcwEnv.sustainPoint = 2; // Sustain silence
    
    // DCA
    p.dcaEnv.rates[0] = 0.99f; p.dcaEnv.levels[0] = 1.0f;
    p.dcaEnv.rates[1] = 0.3f;  p.dcaEnv.levels[1] = 0.0f; // Long decay
    p.dcaEnv.rates[2] = 0.99f; p.dcaEnv.levels[2] = 0.0f;
    p.dcaEnv.rates[3] = 0.5f;  p.dcaEnv.levels[3] = 0.0f;
    
    p.parameters["DCW_ATTACK"] = 0.0f; p.parameters["DCW_DECAY"] = 0.8f; p.parameters["DCW_SUSTAIN"] = 0.0f; p.parameters["DCW_RELEASE"] = 0.5f;
    p.parameters["DCA_ATTACK"] = 0.0f; p.parameters["DCA_DECAY"] = 1.5f; p.parameters["DCA_SUSTAIN"] = 0.0f; p.parameters["DCA_RELEASE"] = 1.0f;

    // Filter
    p.parameters["FILTER_CUTOFF"] = 12000.0f;
    p.parameters["FILTER_RESONANCE"] = 0.2f;

    // LFO
    p.parameters["LFO_RATE"] = 6.0f;
    
    // Effects
    p.parameters["DELAY_TIME"] = 0.0f; p.parameters["DELAY_FEEDBACK"] = 0.0f; p.parameters["DELAY_MIX"] = 0.0f;
    p.parameters["REVERB_SIZE"] = 0.9f; p.parameters["REVERB_MIX"] = 0.4f; // Spacey
    
    p.parameters["HARD_SYNC"] = 0.0f;
    p.parameters["RING_MOD"] = 1.0f; // ENABLE RING MOD FOR BELLS
    p.parameters["GLIDE"] = 0.0f;

    presets.push_back(p);
}

void PresetManager::renamePreset(int index, const std::string& newName)
{
    if (index >= 0 && index < static_cast<int>(presets.size()))
    {
        presets[index].name = newName;
        if (index == 0) // If current (0 is just a guess, we don't track current index here easily without state) -> actually Manager doesn't track current index?
        {
             // If we are editing the ACTIVE preset, we should update currentPreset too.
             // But AudioProcessor tracks currentProgram.
             // Let's assume the caller handles updating the currentPreset struct if it's the active one.
             // OR: we just update it here if names match? No.
             // The Editor calls: `renamePreset(currentProgram, name)`.
             // We should update the vector AND currentPreset if it matches.
             currentPreset.name = newName; 
             // Wait, currentPreset is a COPY. If we rename separate from load, they desync.
             // But usually we rename the 'Active' sound.
             // So: currentPreset.name = newName.
             // And if we want to persist it to the bank slot: presets[index].name = newName.
        }
    }
    // Also update currentPreset name always?
    currentPreset.name = newName;
}

void PresetManager::saveBank(const juce::File& file)
{
    juce::Array<juce::var> bankArray;
    
    for (const auto& preset : presets) {
        juce::DynamicObject::Ptr obj = new juce::DynamicObject();
        
        // Name & params (EXISTENTE)
        obj->setProperty("name", juce::String(preset.name));
        if (!preset.author.empty()) obj->setProperty("author", juce::String(preset.author));

        juce::DynamicObject::Ptr paramsObj = new juce::DynamicObject();
        for (const auto& [id, val] : preset.parameters) {
            paramsObj->setProperty(juce::Identifier(id), val);
        }
        obj->setProperty("params", juce::var(paramsObj.get()));
        
        // Helper to serialize Env (Audit Fix 5.1: Int Serialization x10000)
        auto serializeEnv = [&](const EnvelopeData& env, const juce::String& name) {
            juce::DynamicObject::Ptr envObj = new juce::DynamicObject();
            juce::Array<juce::var> ratesArray, levelsArray;
            for (int i = 0; i < 8; ++i) {
                ratesArray.add(static_cast<int>(env.rates[i] * 10000.0f));
                levelsArray.add(static_cast<int>(env.levels[i] * 10000.0f));
            }
            envObj->setProperty("rates", ratesArray);
            envObj->setProperty("levels", levelsArray);
            envObj->setProperty("sustainPoint", env.sustainPoint);
            envObj->setProperty("endPoint", env.endPoint);
            obj->setProperty(name, juce::var(envObj.get()));
        };

        serializeEnv(preset.dcwEnv, "dcwEnv");
        serializeEnv(preset.dcaEnv, "dcaEnv");
        serializeEnv(preset.pitchEnv, "pitchEnv");
        
        // Serialize Line 2 Envelopes? If structure matches data member
        serializeEnv(preset.dcwEnv2, "dcwEnv2"); // User didn't ask but we should consistency? 
        // Wait, original code didn't save Env2?
        // Checking original saveBank...
        // Original code only saved `dcwEnv`, `dcaEnv`, `pitchEnv`?
        // Ah, original code (Step 4336) lines 641-683 ONLY Saved Line 1 Envelopes!
        // But Line 2 envelopes exist in Preset struct (env2).
        // If I change format, I should add them if they are used.
        // HOWEVER, fixing 5.1 implies *existing* logic. I will stick to existing + the fix.
        // Wait, if I don't save Line 2, dual line patches lose data?
        // This is a bug from before. I should fix it.
        serializeEnv(preset.dcaEnv2, "dcaEnv2");
        serializeEnv(preset.pitchEnv2, "pitchEnv2");
        
        bankArray.add(juce::var(obj.get()));
    }
    
    // Audit Fix 5.2: Wrap in Versioned Object
    juce::DynamicObject::Ptr root = new juce::DynamicObject();
    root->setProperty("version", 1);
    root->setProperty("presets", bankArray);
    
    juce::String jsonString = juce::JSON::toString(juce::var(root), true);
    file.replaceWithText(jsonString);
}

void PresetManager::loadBank(const juce::File& file)
{
    if (!file.existsAsFile()) return;
    
    juce::var data = juce::JSON::parse(file);
    juce::var presetsArray;
    
    // Audit Fix 5.2: Check Version
    if (data.isObject() && data.hasProperty("presets")) {
        int version = data["version"];
        if (version < 1) {
            juce::Logger::writeToLog("Warning: Loading old or unknown bank version");
        }
        presetsArray = data["presets"];
    } else if (data.isArray()) {
        presetsArray = data; // Legacy support
    } else {
        return;
    }

    if (!presetsArray.isArray()) return;
    
    presets.clear(); // Important: Clear definition
    
    // We expect 64 presets
    for (int i = 0; i < presetsArray.size(); ++i) {
        if (i >= 64) break;
        
        const auto& presetVar = presetsArray[i];
        if (presetVar.isObject()) {
            Preset p;
            p.name = presetVar["name"].toString().toStdString();
            if (presetVar.hasProperty("author"))
                p.author = presetVar["author"].toString().toStdString();
            
            // Params
            if (auto* paramsObj = presetVar["params"].getDynamicObject()) {
                auto props = paramsObj->getProperties();
                for (auto& prop : props) {
                    p.parameters[prop.name.toString().toUpperCase().toStdString()] = static_cast<float>(prop.value);
                }
            }
            
            // Helper to load 8-stage
            auto loadEnv = [&](const juce::var& envVar, EnvelopeData& env) {
                if (auto* obj = envVar.getDynamicObject()) {
                    auto rates = obj->getProperty("rates");
                    auto levels = obj->getProperty("levels");
                    
                    if (rates.isArray() && levels.isArray()) {
                        for (int k=0; k<8; ++k) {
                            float r = static_cast<float>(rates[k]);
                            float l = static_cast<float>(levels[k]);
                            
                            // Audit Fix 5.1: Detect Quantized (x10000) values
                            if (r > 100.0f) r /= 10000.0f; 
                            if (l > 10.0f) l /= 10000.0f; // Level max 1.0, so > 10 is safe

                            env.rates[k] = r;
                            env.levels[k] = l;
                        }
                    }
                    env.sustainPoint = static_cast<int>(obj->getProperty("sustainPoint"));
                    env.endPoint = static_cast<int>(obj->getProperty("endPoint"));
                }
            };
            
            loadEnv(presetVar["dcwEnv"], p.dcwEnv);
            loadEnv(presetVar["dcaEnv"], p.dcaEnv);
            loadEnv(presetVar["pitchEnv"], p.pitchEnv);
            
            // Also load line 2 if present
            if (presetVar.hasProperty("dcwEnv2")) loadEnv(presetVar["dcwEnv2"], p.dcwEnv2);
            if (presetVar.hasProperty("dcaEnv2")) loadEnv(presetVar["dcaEnv2"], p.dcaEnv2);
            if (presetVar.hasProperty("pitchEnv2")) loadEnv(presetVar["pitchEnv2"], p.pitchEnv2);
            
            presets.push_back(p);
        }
    }
    
    // Ensure 64 slots
    while (presets.size() < 64) {
        presets.push_back(Preset("Init User " + std::to_string(presets.size() + 1)));
    }
    
    // Audit Fix 3.1: Reset index after bank load to prevent offset mismatch
    currentPresetIndex = 0; 
    loadPreset(currentPresetIndex);
}

void PresetManager::resetToFactory()
{
    // Clear existing presets and recreate factory defaults
    presets.clear();
    createFactoryPresets();

    // Ensure we have at least one preset and set it as active
    if (!presets.empty())
    {
        currentPresetIndex = 0;
        currentPreset = presets[0];
        applyPresetToProcessor();
    }
}

} // namespace State
} // namespace CZ101
================================================================================
FILE: .\Source\State\PresetManager.h
================================================================================
#pragma once

#include <string>
#include <vector>
#include <map>
#include <string>
#include <vector>
#include <map>
#include <juce_core/juce_core.h> // Instead of JuceHeader.h
#include <juce_data_structures/juce_data_structures.h> // For juce::var (if in data_structures) or core
// juce::var is in core usually, let's verify. Yes, juce_core. 
// But let's include both safely.
// Actually juce module headers are guarded.

namespace CZ101 {
namespace State {

// Values for an 8-stage envelope
struct EnvelopeData
{
    float rates[8];
    float levels[8];
    int sustainPoint;
    int endPoint;
    
    EnvelopeData()
    {
        for (int i=0; i<8; ++i) { rates[i] = 0.5f; levels[i] = 0.0f; }
        sustainPoint = 2;
        endPoint = 3;
    }
};

struct Preset
{
    std::string name;
    std::string author; // Added author field
    
    // Parameter map (string ID -> normalized value 0.0-1.0 or specific range)
    std::map<std::string, float> parameters;
    
    // Envelopes Line 1
    EnvelopeData pitchEnv;
    EnvelopeData dcwEnv;
    EnvelopeData dcaEnv;

    // Envelopes Line 2
    EnvelopeData pitchEnv2;
    EnvelopeData dcwEnv2;
    EnvelopeData dcaEnv2;

    Preset() : name("Init"), author("Factory") {} 
    Preset(const std::string& n) : name(n), author("Factory") {}
};

class Parameters; 
} // namespace State
namespace Core { class VoiceManager; } // Forward declaration outside State
namespace State {

class PresetManager
{
public:
    PresetManager(Parameters* parameters, Core::VoiceManager* vm);
    ~PresetManager();
    
    void loadPreset(int index, bool updateVoice = true);
    void savePreset(int index, const std::string& name);
    void loadPresetFromStruct(const Preset& p, bool updateVoice = true); // Load directly (SysEx)
    void copyStateFromProcessor(); // Capture current parameters/envelopes
    
    // Thread safety for preset operations
    juce::CriticalSection& getLock() { return presetLock; }
    
    // Management
    void renamePreset(int index, const std::string& newName);
    void saveBank(const juce::File& file);
    void loadBank(const juce::File& file);
    

    // Reset entire bank to factory defaults
    void resetToFactory();
    void createFactoryPresets(); // Exposed for PluginProcessor fallback
    
    const Preset& getCurrentPreset() const { return currentPreset; }
    const std::vector<Preset>& getPresets() const { return presets; }
    int getCurrentPresetIndex() const { return currentPresetIndex; }
    
    
private:
    std::vector<Preset> presets;
    Preset currentPreset;
    int currentPresetIndex = 0; // Added for tracking
    Parameters* parameters = nullptr;
    Core::VoiceManager* voiceManager = nullptr;
    juce::CriticalSection presetLock;
    
    // void createFactoryPresets(); // Moved to public
    void createBassPreset();
    void createLeadPreset();
    void createBrassPreset();
    void createStringPreset();
    void createBellsPreset();
    
    void applyPresetToProcessor();
    // Helper to push 8-stage data to VoiceManager
    void applyEnvelopeToVoice(const EnvelopeData& env, int type, int line); // 0=Pitch, 1=DCW, 2=DCA, line=1/2
};

} // namespace State
} // namespace CZ101

================================================================================
FILE: .\Source\Tests\SysExTestMain.cpp
================================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <iomanip>

// Mocking dependencies via include path manipulation (handled in CMake or manually here for simplicity if allowed)
// Since we want to test "SysExManager.cpp" logic, we need to satisfy its include of "SysExManager.h" which includes "PresetManager.h"
// We will rely on CMake to PRIORITIZE "Source/Tests/Mocks" in include path.

#include "../MIDI/SysExManager.h"
#include <juce_core/juce_core.h>

// Minimal Mock for PresetManager (definition, since we link against it)
namespace CZ101 {
namespace State {

// Static storage for test verification
static Preset capturedPreset;
static bool presetWasLoaded = false;

PresetManager::PresetManager(Parameters*, Core::VoiceManager*) {}
void PresetManager::loadPreset(int) {}
void PresetManager::savePreset(int, const std::string&) {}
void PresetManager::createFactoryPresets() {}
void PresetManager::createBassPreset() {}
void PresetManager::createLeadPreset() {}
void PresetManager::createBrassPreset() {}
void PresetManager::createStringPreset() {}
void PresetManager::createBellsPreset() {}
void PresetManager::applyPresetToProcessor() {}
void PresetManager::applyEnvelopeToVoice(const EnvelopeData&, int) {}

// The critical method we are testing
void PresetManager::loadPresetFromStruct(const Preset& p) 
{
    capturedPreset = p;
    presetWasLoaded = true;
    std::cout << "[Test] Preset Loaded: " << p.name << std::endl;
}

PresetManager::~PresetManager() {} // Destructor now declared in header

}
}

// Stub for Parameters (if needed by linker, but PresetManager stub doesn't use it)
namespace CZ101 { namespace State { class Parameters {}; } }
namespace CZ101 { namespace Core { class VoiceManager {}; } }


class StdoutLogger : public juce::Logger {
    void logMessage(const juce::String& message) override {
        std::cout << "[LOG] " << message << std::endl;
    }
};

int main(int argc, char* argv[])
{
    StdoutLogger logger;
    juce::Logger::setCurrentLogger(&logger);
    
    std::cout << "========================================" << std::endl;
    std::cout << "      CZ-101 SysEx Logic Test" << std::endl;
    std::cout << "========================================" << std::endl;

    if (argc < 2) {
        std::cerr << "Usage: CZ101SysExTest <path_to_syx_file>" << std::endl;
        return 1;
    }

    std::string filePath = argv[1];
    std::cout << "Loading file: " << filePath << std::endl;

    std::ifstream file(filePath, std::ios::binary | std::ios::ate);
    if (!file) {
        std::cerr << "Error: Could not open file." << std::endl;
        return 1;
    }

    std::streamsize size = file.tellg();
    file.seekg(0, std::ios::beg);

    std::vector<char> buffer(size);
    if (!file.read(buffer.data(), size)) {
        std::cerr << "Error: Could not read file." << std::endl;
        return 1;
    }

    std::cout << "Read " << size << " bytes." << std::endl;

    // Initialize mock dependencies
    CZ101::State::PresetManager mockPM(nullptr, nullptr);
    CZ101::MIDI::SysExManager sysExManager;
    // Bind mock
    sysExManager.onPresetParsed = [&](const CZ101::State::Preset& p) {
        mockPM.loadPresetFromStruct(p);
    };

    // Run Parsing
    sysExManager.handleSysEx(buffer.data(), (int)size, "Test Import");

    if (CZ101::State::presetWasLoaded) {
        std::cout << "SUCCESS: Preset decoded!" << std::endl;
        std::cout << "  Name: " << CZ101::State::capturedPreset.name << std::endl;
        
        // Brief Envelope Dump
        auto dumpEnv = [](const char* name, const CZ101::State::EnvelopeData& env) {
            std::cout << "  " << name << " Env:" << std::endl;
            for(int i=0; i<8; ++i) {
                if (env.levels[i] > 0.0f || env.rates[i] > 0.0f)
                    std::cout << "    Step " << i << ": R=" << env.rates[i] << " L=" << env.levels[i];
                if (i == env.sustainPoint) std::cout << " [SUS]";
                if (i == env.endPoint) std::cout << " [END]";
                if (env.levels[i] > 0.0f || env.rates[i] > 0.0f) std::cout << std::endl;
            }
        };

        dumpEnv("DCA", CZ101::State::capturedPreset.dcaEnv);
        dumpEnv("DCW", CZ101::State::capturedPreset.dcwEnv);
        dumpEnv("DCO", CZ101::State::capturedPreset.pitchEnv);
        
        return 0;
    } else {
        std::cerr << "FAILURE: handleSysEx did not trigger loadPresetFromStruct." << std::endl;
        // Maybe file wasn't recognized?
        return 1;
    }
}

================================================================================
FILE: .\Source\Tests\Mocks\State\PresetManager.h
================================================================================
#pragma once
#include <string>
#include <vector>
#include <map>

// Structs must match original
namespace CZ101 {
namespace State {

struct EnvelopeData
{
    float rates[8];
    float levels[8];
    int sustainPoint;
    int endPoint;
    EnvelopeData() {
        for (int i=0; i<8; ++i) { rates[i] = 0.5f; levels[i] = 0.0f; }
        sustainPoint = 2; endPoint = 3;
    }
};

struct Preset
{
    std::string name;
    std::map<std::string, float> parameters;
    EnvelopeData dcwEnv;
    EnvelopeData dcaEnv;
    EnvelopeData pitchEnv;
    Preset() : name("Init") {}
    Preset(const std::string& n) : name(n) {}
};

class Parameters; 
} 
namespace Core { class VoiceManager; } 
namespace State {

class PresetManager
{
public:
    PresetManager(Parameters* parameters, Core::VoiceManager* vm);
    ~PresetManager(); // Add destr
    
    void loadPreset(int index);
    void savePreset(int index, const std::string& name);
    void loadPresetFromStruct(const Preset& p); // Load directly (SysEx)
    
    // Stub getters
    const Preset& getCurrentPreset() const { return currentPreset; }
    const std::vector<Preset>& getPresets() const { return presets; }
    
private:
    std::vector<Preset> presets;
    Preset currentPreset;
    
    void createFactoryPresets();
    void createBassPreset();
    void createLeadPreset();
    void createBrassPreset();
    void createStringPreset();
    void createBellsPreset();
    
    void applyPresetToProcessor();
    void applyEnvelopeToVoice(const EnvelopeData& env, int type);
};

} 
} 

================================================================================
FILE: .\Source\UI\CZ101LookAndFeel.cpp
================================================================================
#include "CZ101LookAndFeel.h"
#include "DesignTokens.h"

namespace CZ101 {
namespace UI {

CZ101LookAndFeel::CZ101LookAndFeel()
{
    // Initialize common JUCE colours using our design tokens
    setColour(juce::ResizableWindow::backgroundColourId, DesignTokens::Colors::background);
    setColour(juce::DocumentWindow::backgroundColourId,  DesignTokens::Colors::background);
    
    setColour(juce::Label::textColourId,                 DesignTokens::Colors::textPrimary);
    setColour(juce::Label::outlineColourId,              juce::Colours::transparentBlack);
    
    setColour(juce::TextButton::buttonColourId,          DesignTokens::Colors::surface);
    setColour(juce::TextButton::textColourOffId,         DesignTokens::Colors::textPrimary);
    setColour(juce::TextButton::buttonOnColourId,        DesignTokens::Colors::accentCyan.withAlpha(0.6f));
    
    setColour(juce::ComboBox::backgroundColourId,        DesignTokens::Colors::surface);
    setColour(juce::ComboBox::textColourId,              DesignTokens::Colors::textPrimary);
    setColour(juce::ComboBox::outlineColourId,           DesignTokens::Colors::border);
    
    setColour(juce::Slider::thumbColourId,               DesignTokens::Colors::accentCyan);
    setColour(juce::Slider::rotarySliderFillColourId,    DesignTokens::Colors::accentCyan);
    setColour(juce::Slider::rotarySliderOutlineColourId, DesignTokens::Colors::surface);
}

void CZ101LookAndFeel::drawRotarySlider(juce::Graphics& g,
                                       int x, int y, int width, int height,
                                       float sliderPos,
                                       float rotaryStartAngle,
                                       float rotaryEndAngle,
                                       juce::Slider& slider)
{
    auto outline = DesignTokens::Colors::accentCyan;
    auto fill    = DesignTokens::Colors::surface;

    auto bounds = juce::Rectangle<int>(x, y, width, height).toFloat().reduced(6);
    auto diameter = juce::jmin(bounds.getWidth(), bounds.getHeight());
    bounds = bounds.withSizeKeepingCentre(diameter, diameter); // Enforce Square
    auto radius = diameter / 2.0f;
    auto centreX = bounds.getCentreX();
    auto centreY = bounds.getCentreY();
    auto angle = rotaryStartAngle + sliderPos * (rotaryEndAngle - rotaryStartAngle);

    // 1. Shadow
    g.setColour(juce::Colours::black.withAlpha(0.4f));
    g.fillEllipse(bounds.translated(0, 2));

    // 2. Base Plate (Gradient)
    juce::ColourGradient cg(fill.brighter(0.1f), centreX, centreY - radius,
                           fill.darker(0.2f), centreX, centreY + radius, false);
    g.setGradientFill(cg);
    g.fillEllipse(bounds);

    // 3. Ring Outline
    g.setColour(outline.withAlpha(0.3f));
    g.drawEllipse(bounds, 1.5f);

    // 4. Indicator Path
    juce::Path p;
    auto pointerLength = radius * 0.8f;
    auto pointerThickness = 3.0f;
    p.addRoundedRectangle(-pointerThickness * 0.5f, -radius, pointerThickness, pointerLength, 1.0f);
    p.applyTransform(juce::AffineTransform::rotation(angle).translated(centreX, centreY));
    
    // Pointer Glow
    g.setColour(outline.withAlpha(0.2f * sliderPos));
    g.fillPath(p.createPathWithRoundedCorners(2.0f));
    
    g.setColour(outline);
    g.fillPath(p);
    
    // Tick mark for center
    if (slider.getProperties().contains("showCenter")) {
        g.setColour(DesignTokens::Colors::textSecondary);
        g.fillEllipse(centreX-1, bounds.getY()-4, 2, 2);
    }
}

void CZ101LookAndFeel::drawButtonBackground(juce::Graphics& g,
                                        juce::Button& button,
                                        const juce::Colour& backgroundColour,
                                        bool isMouseOver,
                                        bool isButtonDown)
{
    auto cornerSize = DesignTokens::Metrics::cornerRadiusSmall;
    auto bounds = button.getLocalBounds().toFloat().reduced(0.5f);
    
    auto baseColour = backgroundColour;
    if (isButtonDown) baseColour = baseColour.darker(0.1f);
    else if (isMouseOver) baseColour = baseColour.brighter(0.05f);

    // 1. Glassy Fill
    g.setColour(baseColour.withAlpha(isMouseOver ? 0.95f : 0.85f));
    g.fillRoundedRectangle(bounds, cornerSize);

    // 2. Subtle Top Highlight
    g.setColour(juce::Colours::white.withAlpha(0.1f));
    g.drawRoundedRectangle(bounds, cornerSize, 1.0f);
    
    // 3. Accent Bottom Line (if active or just as detail)
    if (button.getToggleState() || isButtonDown) {
        g.setColour(DesignTokens::Colors::accentCyan);
        auto bottomArea = bounds.removeFromBottom(2.0f).reduced(4, 0);
        g.fillRoundedRectangle(bottomArea, 1.0f);
    }
}

void CZ101LookAndFeel::drawGroupComponentOutline(juce::Graphics& g, int width, int height,
                                               const juce::String& text, const juce::Justification& position,
                                               juce::GroupComponent& group)
{
    auto bounds = group.getLocalBounds().toFloat();
    auto textWidth = g.getCurrentFont().getStringWidth(text);
    
    g.setColour(DesignTokens::Colors::border);
    juce::Path p;
    
    float textX = 15.0f;
    float headH = 20.0f;
    
    // Fancy rounded box with gap for text
    p.startNewSubPath(textX + textWidth + 5.0f, 10);
    p.lineTo(width - 10.0f, 10);
    p.lineTo(width - 10.0f, height - 10.0f);
    p.lineTo(10.0f, height - 10.0f);
    p.lineTo(10.0f, 10);
    p.lineTo(textX - 5.0f, 10);
    
    g.strokePath(p, juce::PathStrokeType(1.0f));
    
    g.setColour(DesignTokens::Colors::textSecondary);
    g.setFont(DesignTokens::Typography::subHeaderSize);
    g.drawText(text, 15, 0, textWidth, headH, juce::Justification::centredLeft);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\CZ101LookAndFeel.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>

namespace CZ101 {
namespace UI {

class CZ101LookAndFeel : public juce::LookAndFeel_V4
{
public:
    CZ101LookAndFeel();
    
    void drawRotarySlider(juce::Graphics& g,
                         int x, int y, int width, int height,
                         float sliderPos,
                         float rotaryStartAngle,
                         float rotaryEndAngle,
                         juce::Slider& slider) override;
    
    // Custom button drawing with hover effect
    void drawButtonBackground(juce::Graphics& g,
                              juce::Button& button,
                              const juce::Colour& backgroundColour,
                              bool isMouseOver,
                              bool isButtonDown) override;

    void drawGroupComponentOutline(juce::Graphics& g, int width, int height,
                                   const juce::String& text, const juce::Justification& position,
                                   juce::GroupComponent& group) override;
private:
    juce::Colour primaryColour;
    juce::Colour secondaryColour;
    juce::Colour textColour;
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\DesignTokens.h
================================================================================
#pragma once
#include <juce_gui_basics/juce_gui_basics.h>

namespace CZ101 {
namespace UI {

/**
 * DesignTokens.h - Centralized Design System
 * 
 * PHANTOM SLATE THEME:
 * A premium, dark-mode design system with electric cyan accents.
 */
namespace DesignTokens {

    // --- Colors ---
    namespace Colors {
        static inline const juce::Colour background      = juce::Colour::fromHSL(0.61f, 0.15f, 0.08f, 1.0f); // Depth navy slate
        static inline const juce::Colour surface         = juce::Colour::fromHSL(0.61f, 0.12f, 0.12f, 1.0f); // Slightly lighter slate
        static inline const juce::Colour glass           = juce::Colour(0x1Affffff);                        // Semi-transparent overlay
        
        static inline const juce::Colour accentCyan      = juce::Colour::fromHSL(0.52f, 1.00f, 0.50f, 1.0f); // Electric Cyan
        static inline const juce::Colour accentOrange    = juce::Colour::fromHSL(0.08f, 1.00f, 0.60f, 1.0f); // Timbre Orange
        static inline const juce::Colour accentMagenta   = juce::Colour::fromHSL(0.83f, 1.00f, 0.60f, 1.0f); // Pitch Magenta
        
        static inline const juce::Colour textPrimary     = juce::Colour(0xfff0f0f0);
        static inline const juce::Colour textSecondary   = juce::Colour(0xffa0a0a0);
        static inline const juce::Colour border          = juce::Colour(0x33ffffff);
    }

    // --- Metrics ---
    namespace Metrics {
        static inline const float cornerRadiusLarge      = 12.0f;
        static inline const float cornerRadiusMedium     = 8.0f;
        static inline const float cornerRadiusSmall      = 4.0f;
        static inline const float shadowOffset           = 4.0f;
    }

    // --- Typography ---
    namespace Typography {
        static inline const float headerSize             = 22.0f;
        static inline const float subHeaderSize          = 16.0f;
        static inline const float baseSize               = 13.0f;
        static inline const float tinySize               = 10.0f;
    }

} // namespace DesignTokens

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\LCDDisplay.cpp
================================================================================
#include "LCDDisplay.h"
#include "DesignTokens.h"

namespace CZ101 {
namespace UI {

LCDDisplay::LCDDisplay()
{
    // Authentic LCD Styling mapped to DesignTokens
    
    addAndMakeVisible(topLineLabel);
    topLineLabel.setColour(juce::Label::textColourId, DesignTokens::Colors::accentCyan);
    topLineLabel.setJustificationType(juce::Justification::centredLeft);
    topLineLabel.setFont(juce::Font("Courier New", 18.0f, juce::Font::bold));

    addAndMakeVisible(bottomLineLabel);
    bottomLineLabel.setColour(juce::Label::textColourId, DesignTokens::Colors::accentCyan);
    bottomLineLabel.setJustificationType(juce::Justification::centredLeft);
    bottomLineLabel.setFont(juce::Font("Courier New", 18.0f, juce::Font::bold));
}

LCDDisplay::~LCDDisplay()
{
    if (stateManager)
        stateManager->removeChangeListener(this);
}

void LCDDisplay::setStateManager(LCDStateManager* mgr)
{
    if (stateManager)
        stateManager->removeChangeListener(this);
        
    stateManager = mgr;
    
    if (stateManager)
    {
        stateManager->addChangeListener(this);
        changeListenerCallback(stateManager);
    }
}

void LCDDisplay::changeListenerCallback(juce::ChangeBroadcaster*)
{
    if (stateManager)
    {
        topLineLabel.setText(stateManager->getTopLineText(), juce::dontSendNotification);
        bottomLineLabel.setText(stateManager->getBottomLineText(), juce::dontSendNotification);
    }
}

void LCDDisplay::paint(juce::Graphics& g)
{
    auto bounds = getLocalBounds().toFloat();
    
    // 1. Deep Recessed Background
    g.setColour(DesignTokens::Colors::background.darker(0.5f));
    g.fillRoundedRectangle(bounds, DesignTokens::Metrics::cornerRadiusSmall);
    
    // 2. Subtle Glow Overlay
    juce::ColourGradient glow(DesignTokens::Colors::accentCyan.withAlpha(0.05f), bounds.getCentreX(), bounds.getCentreY(),
                             DesignTokens::Colors::accentCyan.withAlpha(0.0f), bounds.getCentreX(), bounds.getBottom(), true);
    g.setGradientFill(glow);
    g.fillRoundedRectangle(bounds, DesignTokens::Metrics::cornerRadiusSmall);

    // 3. Pixel Grid Effect (finer)
    g.setColour(juce::Colours::black.withAlpha(0.2f));
    for (float x = 0; x < bounds.getWidth(); x += 2.0f)
        g.drawVerticalLine((int)x, 0.0f, bounds.getHeight());
    for (float y = 0; y < bounds.getHeight(); y += 2.0f)
        g.drawHorizontalLine((int)y, 0.0f, bounds.getWidth());
        
    // 4. Border (Glass Inset)
    g.setColour(DesignTokens::Colors::border);
    g.drawRoundedRectangle(bounds, DesignTokens::Metrics::cornerRadiusSmall, 1.5f);
}

void LCDDisplay::resized()
{
    auto bounds = getLocalBounds().reduced(10, 5);
    int rowHeight = bounds.getHeight() / 2;
    
    topLineLabel.setBounds(bounds.removeFromTop(rowHeight));
    bottomLineLabel.setBounds(bounds);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\LCDDisplay.h
================================================================================
/*
  ==============================================================================

    LCDDisplay.h
    Created: 15 Dec 2025
    Author:  Antigravity

  ==============================================================================
*/

#pragma once

#include <juce_gui_basics/juce_gui_basics.h>
#include "LCDStateManager.h"

namespace CZ101 {
namespace UI {

class LCDDisplay : public juce::Component,
                   public juce::ChangeListener
{
public:
    LCDDisplay();
    ~LCDDisplay() override;

    void setStateManager(LCDStateManager* mgr);
    
    // Helper to match existing usage in PluginEditor.cpp
    void updateFromManager(LCDStateManager* mgr) { setStateManager(mgr); }

    void paint(juce::Graphics& g) override;
    void resized() override;
    
    void changeListenerCallback(juce::ChangeBroadcaster* source) override;

private:
    LCDStateManager* stateManager = nullptr;
    juce::Label topLineLabel;
    juce::Label bottomLineLabel;
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(LCDDisplay)
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\LCDStateManager.cpp
================================================================================
#include "LCDStateManager.h"

namespace CZ101 {
namespace UI {

LCDStateManager::LCDStateManager(juce::AudioProcessorValueTreeState& apvtsToUse)
    : apvts(apvtsToUse), currentMode(Mode::EDIT)
{
    buildParameterList();
    updateDisplay();
}

void LCDStateManager::buildParameterList()
{
    parameterIds.clear();
    currentParameterIndex = 0;

    if (currentMode == Mode::EDIT)
    {
        // Standard Authentic Order
        parameterIds.push_back("LINE_SELECT");
        // parameterIds.push_back("OSC2_DETUNE"); // Needs manual mapping for Oct/Note? Use L2 Detune for now.
        parameterIds.push_back("OSC2_DETUNE"); 
        
        parameterIds.push_back("LFO_WAVE");
        parameterIds.push_back("LFO_DELAY");
        parameterIds.push_back("LFO_RATE");
        parameterIds.push_back("LFO_DEPTH");
        
        // DCO
        parameterIds.push_back("OSC1_WAVEFORM");
        parameterIds.push_back("OSC2_WAVEFORM");
        
        // Add Envelopes later
    }
    else if (currentMode == Mode::SYSTEM)
    {
        parameterIds.push_back("SYSTEM_PRG");
        parameterIds.push_back("PROTECT_SWITCH");
    }
}

void LCDStateManager::setMode(Mode newMode)
{
    currentMode = newMode;
    buildParameterList(); // Rebuild list for new mode
    updateDisplay();
    sendChangeMessage();
}

void LCDStateManager::onCursorLeft()
{
    if (parameterIds.empty()) return;
    currentParameterIndex = (currentParameterIndex - 1 + (int)parameterIds.size()) % (int)parameterIds.size();
    updateDisplay();
    sendChangeMessage();
}

void LCDStateManager::onCursorRight()
{
    if (parameterIds.empty()) return;
    currentParameterIndex = (currentParameterIndex + 1) % (int)parameterIds.size();
    updateDisplay();
    sendChangeMessage();
}

void LCDStateManager::onValueUp()
{
    modifyValue(true);
}

void LCDStateManager::onValueDown()
{
    modifyValue(false);
}

void LCDStateManager::onCompareButton() {}
void LCDStateManager::onWriteButton() {}

void LCDStateManager::modifyValue(bool isUp)
{
    if (currentParameterIndex < 0 || currentParameterIndex >= parameterIds.size()) return;
    
    juce::String paramID = parameterIds[currentParameterIndex];
    auto* param = apvts.getParameter(paramID);
    
    if (param)
    {
        float step = 0.01f; // Default small step
        
        // Try to get a better step from the parameter range if possible
        if (auto* floatParam = dynamic_cast<juce::AudioParameterFloat*>(param))
            step = 1.0f / floatParam->range.getRange().getLength(); // Normalize 1 integer step
        else if (auto* choiceParam = dynamic_cast<juce::AudioParameterChoice*>(param))
             step = 1.0f / (float)juce::jmax(1, choiceParam->choices.size() - 1);
        else if (auto* boolParam = dynamic_cast<juce::AudioParameterBool*>(param))
             step = 1.0f;

        float currentValue = param->getValue();
        float newValue = isUp ? (currentValue + step) : (currentValue - step);
        
        param->setValueNotifyingHost(juce::jlimit(0.0f, 1.0f, newValue));
        
        updateDisplay();
        sendChangeMessage();
    }
}

void LCDStateManager::updateDisplay()
{
    if (currentMode == Mode::NORMAL)
    {
        topLine = "NORMAL MODE";
        bottomLine = "SELECT PROGRAM";
    }
    else if (currentMode == Mode::EDIT || currentMode == Mode::SYSTEM)
    {
        if (parameterIds.empty()) {
            topLine = (currentMode == Mode::SYSTEM) ? "SYSTEM MODE" : "EDIT MODE";
            bottomLine = "NO PARAMETERS";
            return;
        }
        
        if (currentParameterIndex >= 0 && currentParameterIndex < parameterIds.size())
        {
            juce::String paramID = parameterIds[currentParameterIndex];
            auto* param = apvts.getParameter(paramID);
            
            if (param)
            {
                juce::String name = param->getName(16);
                juce::String valueStr = param->getCurrentValueAsText();
                
                // Custom overrides for authenticity
                if (paramID == "SYSTEM_PRG") {
                    name = "MIDI PRG";
                    valueStr = (param->getValue() > 0.5f) ? "ENA" : "DIS";
                }
                else if (paramID == "PROTECT_SWITCH") {
                    name = "PROTECT";
                    valueStr = (param->getValue() > 0.5f) ? "ON" : "OFF";
                }
                
                topLine = ((currentMode == Mode::SYSTEM) ? "SYS: " : "EDT: ") + name;
                bottomLine = valueStr;
            }
            else
            {
                topLine = "PARAM ERROR";
                bottomLine = paramID;
            }
        }
    }
}

juce::String LCDStateManager::getTopLineText() const { return topLine; }
juce::String LCDStateManager::getBottomLineText() const { return bottomLine; }

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\LCDStateManager.h
================================================================================
#pragma once

#include <juce_core/juce_core.h>
#include <juce_audio_processors/juce_audio_processors.h>

namespace CZ101 {
namespace UI {

    class LCDStateManager : public juce::ChangeBroadcaster
    {
    public:
        enum class Mode {
            NORMAL,   // Program Select / Tone Mix
            EDIT,     // Parameter Editing
            SYSTEM    // System Settings (MIDI, Protect)
        };

        LCDStateManager(juce::AudioProcessorValueTreeState& apvts);
        ~LCDStateManager() = default;

        // Navigation Inputs
        void onCursorLeft();
        void onCursorRight();
        void onValueUp();
        void onValueDown();
        void onCompareButton(); // Toggles Compare
        void onWriteButton();   // Triggers Write Mode

        // Display Data Access
        juce::String getTopLineText() const;
        juce::String getBottomLineText() const;
        
        // Mode Switching
        void setMode(Mode newMode);
        Mode getMode() const { return currentMode; }

    private:
        juce::AudioProcessorValueTreeState& apvts;
        Mode currentMode = Mode::NORMAL;
        
        // Navigation State
        int currentParameterIndex = 0;
        int currentProgramIndex = 0; // 0-31 (Internal)
        
        // Parameter List for Edit Mode
        std::vector<juce::String> parameterIds;
        void buildParameterList();
        
        // Helpers
        void updateDisplay();
        void modifyValue(bool isUp);
        
        // Internal data
        juce::String topLine;
        juce::String bottomLine;

        JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(LCDStateManager)
    };

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\EnvelopeEditor.cpp
================================================================================
#include "EnvelopeEditor.h"
#include "../DesignTokens.h"

namespace CZ101 {
namespace UI {

EnvelopeEditor::EnvelopeEditor(CZ101AudioProcessor& processor, EnvelopeType type)
    : audioProcessor(processor), envType(type)
{
    // Initialize with dummy default data
    for (int i = 0; i < 8; ++i)
    {
        rates[i] = 0.5f;
        levels[i] = (i % 2 == 0) ? 1.0f : 0.0f;
    }
    
    setMouseCursor(juce::MouseCursor::CrosshairCursor);
    updateData();
}

EnvelopeEditor::~EnvelopeEditor()
{
}

void EnvelopeEditor::updateData()
{
    auto& vm = audioProcessor.getVoiceManager();
    
    for (int i = 0; i < 8; ++i)
    {
        float r = 0.5f;
        float l = 0.0f;
        
        // Use currentLine for multi-line support
        if (envType == EnvelopeType::DCA)
            vm.getDCAStage(currentLine, i, r, l);
        else if (envType == EnvelopeType::DCW)
            vm.getDCWStage(currentLine, i, r, l);
        else if (envType == EnvelopeType::PITCH)
            vm.getPitchStage(currentLine, i, r, l);
            
        rates[i] = r;
        levels[i] = l;
    }
    
    if (envType == EnvelopeType::DCA)
    {
        sustainPoint = vm.getDCASustainPoint(currentLine);
        endPoint = vm.getDCAEndPoint(currentLine);
    }
    else if (envType == EnvelopeType::DCW)
    {
        sustainPoint = vm.getDCWSustainPoint(currentLine);
        endPoint = vm.getDCWEndPoint(currentLine);
    }
    else if (envType == EnvelopeType::PITCH)
    {
        sustainPoint = vm.getPitchSustainPoint(currentLine);
        endPoint = vm.getPitchEndPoint(currentLine);
    }
    
    repaint();
}

void EnvelopeEditor::setLine(int line)
{
    currentLine = line;
    updateData();
}

void EnvelopeEditor::paint(juce::Graphics& g)
{
    auto bounds = getLocalBounds().toFloat();
    float w = bounds.getWidth();
    float h = bounds.getHeight();

    // 1. Background Grid (Premium Slate)
    g.fillAll(DesignTokens::Colors::background.darker(0.2f));
    
    g.setColour(DesignTokens::Colors::border.withAlpha(0.1f));
    float stepWidth = w / 8.0f;
    for (int i = 1; i < 8; ++i)
    {
        g.drawVerticalLine(static_cast<int>(i * stepWidth), 0.0f, h);
    }
    for (int i = 1; i < 4; ++i)
    {
        g.drawHorizontalLine(static_cast<int>(i * h / 4.0f), 0.0f, w);
    }

    // 2. Select Colour based on type
    juce::Colour accent;
    if (envType == EnvelopeType::DCA) accent = DesignTokens::Colors::accentCyan;
    else if (envType == EnvelopeType::DCW) accent = DesignTokens::Colors::accentOrange;
    else accent = DesignTokens::Colors::accentMagenta;

    // 3. Build Path
    juce::Path p;
    p.startNewSubPath(0.0f, h); // Start at zero

    for (int i = 0; i < 8; ++i)
    {
        float nextX = (i + 1) * stepWidth;
        float nextY = h - (levels[i] * h);
        p.lineTo(nextX, nextY);
    }

    // 4. Glow / Outer Path
    g.setColour(accent.withAlpha(0.15f));
    g.strokePath(p, juce::PathStrokeType(6.0f, juce::PathStrokeType::curved, juce::PathStrokeType::rounded));
    
    // 5. Main Path
    g.setColour(accent);
    g.strokePath(p, juce::PathStrokeType(2.5f, juce::PathStrokeType::curved, juce::PathStrokeType::rounded));

    // 6. Fill area under path (Gradient)
    juce::Path fillPath = p;
    fillPath.lineTo(w, h);
    fillPath.lineTo(0.0f, h);
    fillPath.closeSubPath();
    
    juce::ColourGradient cg(accent.withAlpha(0.2f), 0, 0,
                           accent.withAlpha(0.0f), 0, h, false);
    g.setGradientFill(cg);
    g.fillPath(fillPath);

    // 7. Handles & Indicators
    for (int i = 0; i < 8; ++i)
    {
        float x = (i + 1) * stepWidth;
        float y = h - (levels[i] * h);
        
        // Indicator for Sustain/End
        if (i == sustainPoint) {
            g.setColour(juce::Colours::yellow.withAlpha(0.3f));
            g.drawVerticalLine(static_cast<int>(x), 0, h);
            g.setFont(DesignTokens::Typography::tinySize);
            g.drawText("SUS", x - 15, 2, 30, 10, juce::Justification::centred);
        }
        if (i == endPoint) {
            g.setColour(juce::Colours::red.withAlpha(0.3f));
            g.drawVerticalLine(static_cast<int>(x), 0, h);
            g.drawText("END", x - 15, h - 12, 30, 10, juce::Justification::centred);
        }

        // Handle
        bool isSelected = (i == selectedStage);
        g.setColour(isSelected ? juce::Colours::white : accent.brighter(0.2f));
        
        // Outer glow for handle
        if (isSelected) {
            g.setColour(accent.withAlpha(0.4f));
            g.fillEllipse(x - 6, y - 6, 12, 12);
            g.setColour(juce::Colours::white);
        }
        
        g.fillEllipse(x - 3.5f, y - 3.5f, 7, 7);
        g.setColour(DesignTokens::Colors::background);
        g.drawEllipse(x - 3.5f, y - 3.5f, 7, 7, 1.0f);
    }
}

void EnvelopeEditor::resized()
{
}

void EnvelopeEditor::mouseDown(const juce::MouseEvent& e)
{
    float w = static_cast<float>(getWidth());
    float stepWidth = w / 8.0f;
    
    // Find closest stage
    int stage = static_cast<int>((e.position.x + stepWidth * 0.5f) / stepWidth) - 1;
    if (stage >= 0 && stage < 8)
    {
        selectedStage = stage;
        repaint();
    }
}

void EnvelopeEditor::mouseDrag(const juce::MouseEvent& e)
{
    if (selectedStage >= 0 && selectedStage < 8)
    {
        if (e.mods.isShiftDown())
        {
            float w = static_cast<float>(getWidth());
            float stepWidth = w / 8.0f;
            float stageStartX = selectedStage * stepWidth;
            
            float xWithinStage = e.position.x - stageStartX;
            float newRate = std::clamp(xWithinStage / stepWidth, 0.01f, 0.99f);
            rates[selectedStage] = newRate;
        }
        else
        {
            float y = std::clamp(e.position.y / static_cast<float>(getHeight()), 0.0f, 1.0f);
            levels[selectedStage] = 1.0f - y;
        }
        
        sendUpdateToProcessor(selectedStage);
        repaint();
    }
}

void EnvelopeEditor::mouseUp(const juce::MouseEvent& e)
{
    selectedStage = -1;
    repaint();
}

void EnvelopeEditor::sendUpdateToProcessor(int stageIndex)
{
    EnvelopeUpdateCommand cmd;
    cmd.type = (envType == EnvelopeType::DCA) ? EnvelopeUpdateCommand::DCA_STAGE :
               (envType == EnvelopeType::DCW) ? EnvelopeUpdateCommand::DCW_STAGE :
               EnvelopeUpdateCommand::PITCH_STAGE;
    
    cmd.line = currentLine;
    cmd.index = stageIndex;
    cmd.rate = rates[stageIndex];
    cmd.level = levels[stageIndex];

    audioProcessor.scheduleEnvelopeUpdate(cmd);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\EnvelopeEditor.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>
#include "../../PluginProcessor.h"

namespace CZ101 {
namespace UI {

class EnvelopeEditor : public juce::Component
{
public:
    enum class EnvelopeType { DCW, DCA, PITCH };
    
    EnvelopeEditor(CZ101AudioProcessor& processor, EnvelopeType type);
    ~EnvelopeEditor() override;
    
    void paint(juce::Graphics& g) override;
    void resized() override;
    
    // Updates local data from processor/preset
    void updateData(); 
    void setLine(int line); 
    
    // Drag handlers
    void mouseDown(const juce::MouseEvent& e) override;
    void mouseDrag(const juce::MouseEvent& e) override;
    void mouseUp(const juce::MouseEvent& e) override;

private:
    CZ101AudioProcessor& audioProcessor;
    EnvelopeType envType;
    
    // Local copy of stage data for drawing/editing
    // 8 stages, rate (0-1), level (0-1)
    struct Point { float x; float y; };
    std::array<float, 8> rates;
    std::array<float, 8> levels;
    int sustainPoint = 2;
    int endPoint = 3;
    
    int currentLine = 1;
    int selectedStage = -1;
    
    // Helper to map Rate(0-1)/Level(0-1) to screen coordinates
    juce::Point<float> getScreenPoint(int stageIndex, float w, float h);
    
    void sendUpdateToProcessor(int stageIndex);
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\Knob.cpp
================================================================================
#include "Knob.h"

namespace CZ101 {
namespace UI {

Knob::Knob(const juce::String& name)
    : juce::Slider(name)
{
    setSliderStyle(juce::Slider::RotaryHorizontalVerticalDrag);
    setTextBoxStyle(juce::Slider::TextBoxBelow, false, 50, 14);
    
    label.setText(name, juce::dontSendNotification);
    label.setJustificationType(juce::Justification::centred);
    label.setColour(juce::Label::textColourId, juce::Colours::white);
    label.setFont(juce::Font(12.0f));
    addAndMakeVisible(label);
}

void Knob::paint(juce::Graphics& g)
{
    juce::Slider::paint(g);
}

void Knob::resized()
{
    auto bounds = getLocalBounds();
    // Label at Top
    auto labelArea = bounds.removeFromTop(14);
    label.setBounds(labelArea);
    
    // Slider takes the rest (and puts TextBox at bottom)
    juce::Slider::resized();
}

void Knob::setLabel(const juce::String& text)
{
    labelText = text;
    label.setText(text, juce::dontSendNotification);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\Knob.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>

namespace CZ101 {
namespace UI {

class Knob : public juce::Slider
{
public:
    Knob(const juce::String& name);
    
    void paint(juce::Graphics& g) override;
    void resized() override;
    
    void setLabel(const juce::String& text);
    
private:
    juce::String labelText;
    juce::Label label;
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\MIDIActivityIndicator.cpp
================================================================================
#include "MIDIActivityIndicator.h"

namespace CZ101 {
namespace UI {

MIDIActivityIndicator::MIDIActivityIndicator()
{
    startTimer(30);
}

void MIDIActivityIndicator::paint(juce::Graphics& g)
{
    auto bounds = getLocalBounds().toFloat();
    
    g.setColour(juce::Colour(0xff2a2a2a));
    g.fillEllipse(bounds);
    
    if (brightness > 0.0f)
    {
        auto colour = juce::Colour(0xff4a9eff).withAlpha(brightness);
        g.setColour(colour);
        g.fillEllipse(bounds.reduced(2.0f));
    }
}

void MIDIActivityIndicator::timerCallback()
{
    if (isActive)
    {
        brightness = 1.0f;
        isActive = false;
    }
    else
    {
        brightness -= FADE_SPEED;
        if (brightness < 0.0f)
            brightness = 0.0f;
    }
    
    repaint();
}

void MIDIActivityIndicator::triggerActivity()
{
    isActive = true;
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\MIDIActivityIndicator.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>

namespace CZ101 {
namespace UI {

class MIDIActivityIndicator : public juce::Component, public juce::Timer
{
public:
    MIDIActivityIndicator();
    
    void paint(juce::Graphics& g) override;
    void timerCallback() override;
    
    void triggerActivity();
    
private:
    bool isActive = false;
    float brightness = 0.0f;
    
    static constexpr float FADE_SPEED = 0.1f;
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\PresetBrowser.cpp
================================================================================
#include "PresetBrowser.h"
#include "../../State/PresetManager.h"
#include "../DesignTokens.h"

namespace CZ101 {
namespace UI {

PresetBrowser::PresetBrowser()
{
    addAndMakeVisible(presetCombo);
    addAndMakeVisible(prevButton);
    addAndMakeVisible(nextButton);
    addAndMakeVisible(menuButton);
    
    prevButton.setButtonText("<");
    nextButton.setButtonText(">");
    menuButton.setButtonText("MENU");
    
    // Wire changes
    presetCombo.onChange = [this]() { selectPreset(presetCombo.getSelectedItemIndex()); };
    
    prevButton.onClick = [this]() {
        int current = presetCombo.getSelectedItemIndex();
        if (current > 0) presetCombo.setSelectedItemIndex(current - 1);
    };
    
    nextButton.onClick = [this]() {
        int current = presetCombo.getSelectedItemIndex();
        if (current < presetCombo.getNumItems() - 1) presetCombo.setSelectedItemIndex(current + 1);
    };
    
    menuButton.onClick = [this] { showMenu(); };
}

void PresetBrowser::setPresetManager(State::PresetManager* pm)
{
    presetManager = pm;
    if (presetManager) updatePresetList();
}

void PresetBrowser::paint(juce::Graphics& g)
{
    auto bounds = getLocalBounds().toFloat();
    
    // Premium Glassy Surface
    g.setColour(DesignTokens::Colors::surface.withAlpha(0.6f));
    g.fillRoundedRectangle(bounds, DesignTokens::Metrics::cornerRadiusMedium);
    
    g.setColour(DesignTokens::Colors::border.withAlpha(0.4f));
    g.drawRoundedRectangle(bounds, DesignTokens::Metrics::cornerRadiusMedium, 1.0f);
    
    // Top highlight line
    g.setColour(juce::Colours::white.withAlpha(0.1f));
    g.drawRoundedRectangle(bounds.reduced(0.5f), DesignTokens::Metrics::cornerRadiusMedium, 1.0f);
}

void PresetBrowser::resized()
{
    auto bounds = getLocalBounds().reduced(4);
    
    // Layout: MENU | PREV [ COMBO ] NEXT
    menuButton.setBounds(bounds.removeFromLeft(80).reduced(2));
    prevButton.setBounds(bounds.removeFromLeft(40).reduced(2));
    nextButton.setBounds(bounds.removeFromRight(40).reduced(2));
    
    bounds.reduce(4, 0);
    presetCombo.setBounds(bounds);
}

void PresetBrowser::showMenu()
{
    juce::PopupMenu m;
    m.addSectionHeader("Bank Management");
    m.addItem(1, "Init Bank (Factory Reset)");
    m.addSeparator();
    m.addItem(2, "Load Bank (.json)...");
    m.addItem(3, "Save Bank (.json)...");
    m.addSeparator();
    m.addItem(4, "System Settings (MIDI/Protect)...");
    m.addSeparator();
    
    juce::PopupMenu initMenu;
    initMenu.addItem(101, "Initialize DCO");
    initMenu.addItem(102, "Initialize DCW");
    initMenu.addItem(103, "Initialize DCA");
    initMenu.addItem(104, "Initialize Vibrato");
    initMenu.addSeparator();
    initMenu.addItem(105, "Initialize ALL (1+1')");
    
    m.addSubMenu("Initialize Module...", initMenu);
    
    m.showMenuAsync(juce::PopupMenu::Options().withTargetComponent(&menuButton),
        [this](int result)
        {
            if (result == 1) initBank();
            else if (result == 2) loadBank();
            else if (result == 3) saveBank();
            else if (result == 4 && onSystemModeRequested) onSystemModeRequested();
            else if (result >= 101 && result <= 105 && onInitRequested) onInitRequested(result);
        });
}

void PresetBrowser::initBank()
{
    if (!presetManager) return;
    juce::AlertWindow::showOkCancelBox(juce::AlertWindow::WarningIcon, "Reset Bank", "Are you sure? This will replace all presets with factory defaults.", "Reset", "Cancel", nullptr,
        juce::ModalCallbackFunction::create([this](int result) {
            if (result == 1) {
                presetManager->resetToFactory();
                updatePresetList();
                selectPreset(0);
            }
        }));
}

void PresetBrowser::loadBank()
{
    if (!presetManager) return;
    fileChooser = std::make_unique<juce::FileChooser>("Load Bank", juce::File::getSpecialLocation(juce::File::userDocumentsDirectory), "*.json");
    fileChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles, [this](const juce::FileChooser& fc) {
        auto file = fc.getResult();
        if (file.existsAsFile()) {
            presetManager->loadBank(file);
            updatePresetList();
            selectPreset(0);
        }
    });
}

void PresetBrowser::saveBank()
{
    if (!presetManager) return;
    fileChooser = std::make_unique<juce::FileChooser>("Save Bank", juce::File::getSpecialLocation(juce::File::userDocumentsDirectory), "*.json");
    fileChooser->launchAsync(juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::warnAboutOverwriting, [this](const juce::FileChooser& fc) {
        auto file = fc.getResult();
        if (file != juce::File()) presetManager->saveBank(file);
    });
}

void PresetBrowser::updatePresetList()
{
    presetCombo.clear();
    if (!presetManager) return;
    const auto& presets = presetManager->getPresets();
    for (size_t i = 0; i < presets.size(); ++i)
        presetCombo.addItem(presets[i].name, static_cast<int>(i) + 1);
    
    int currentIdx = presetManager->getCurrentPresetIndex();
    presetCombo.setSelectedItemIndex(currentIdx >= 0 ? currentIdx : 0, juce::dontSendNotification);
}

void PresetBrowser::selectPreset(int index)
{
    if (presetManager) presetManager->loadPreset(index);
    if (onPresetSelected) onPresetSelected(index);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\PresetBrowser.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>
#include "../../State/PresetManager.h"

namespace CZ101 {
namespace UI {

class PresetBrowser : public juce::Component
{
public:
    PresetBrowser();
    void setPresetManager(State::PresetManager* pm);
    
    void paint(juce::Graphics& g) override;
    void resized() override;
    
    std::function<void(int)> onPresetSelected;
    std::function<void()> onSaveRequested;
    std::function<void()> onSystemModeRequested; // New Callback
    std::function<void(int)> onInitRequested; // int -> InitSection enum mapped
    
    // Exposed for Editor
    void updatePresetList();
    int getSelectedItemIndex() const;
    void setSelectedItemIndex(int index);
    
private:
    State::PresetManager* presetManager = nullptr;
    juce::ComboBox presetCombo;
    juce::TextButton prevButton;
    juce::TextButton nextButton;
    juce::TextButton saveButton;
    
    // Bank Management
    juce::TextButton menuButton;
    std::unique_ptr<juce::FileChooser> fileChooser;
    
    void showMenu();
    void initBank();
    void loadBank();
    void saveBank();
    
    // void updatePresetList(); // Moved to public
    void selectPreset(int index);
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\WaveformDisplay.cpp
================================================================================
#include "WaveformDisplay.h"
#include <cmath>

namespace CZ101 {
namespace UI {

WaveformDisplay::WaveformDisplay()
{
    waveformData.resize(256);
    generateWaveform();
    startTimer(50);
}

void WaveformDisplay::paint(juce::Graphics& g)
{
    auto bounds = getLocalBounds().toFloat();
    
    g.fillAll(juce::Colour(0xff1a1a1a));
    
    g.setColour(juce::Colour(0xff2a2a2a));
    g.drawRect(bounds, 2.0f);
    
    juce::Path path;
    auto width = bounds.getWidth();
    auto height = bounds.getHeight();
    auto centerY = bounds.getCentreY();
    
    path.startNewSubPath(bounds.getX(), centerY);
    
    for (size_t i = 0; i < waveformData.size(); ++i)
    {
        float x = bounds.getX() + (i / static_cast<float>(waveformData.size())) * width;
        float y = centerY - waveformData[i] * (height * 0.4f);
        path.lineTo(x, y);
    }
    
    g.setColour(juce::Colour(0xff4a9eff));
    g.strokePath(path, juce::PathStrokeType(2.0f));
}

void WaveformDisplay::timerCallback()
{
    repaint();
}

void WaveformDisplay::setWaveform(int waveformType)
{
    currentWaveform = waveformType;
    generateWaveform();
}

void WaveformDisplay::pushBuffer(const juce::AudioBuffer<float>& buffer)
{
    // Audit Fix 2.9: Ensure buffer access is safe
    auto* channelData = buffer.getReadPointer(0);
    int numSamples = buffer.getNumSamples();
    int dataSize = static_cast<int>(waveformData.size());
    
    if (dataSize == 0) return;

    // Grab only as much as fits to avoid issues if block size is huge
    int samplesToCopy = std::min(numSamples, dataSize);
    
    for (int i = 0; i < samplesToCopy; ++i)
    {
        waveformData[writePos] = channelData[i];
        writePos = (writePos + 1) % dataSize;
    }
}

void WaveformDisplay::generateWaveform() 
{
    // No-op or clear, as we use live data now
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\WaveformDisplay.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_audio_basics/juce_audio_basics.h> // For AudioBuffer
#include <vector>

namespace CZ101 {
namespace UI {

class WaveformDisplay : public juce::Component, public juce::Timer
{
public:
    WaveformDisplay();
    
    void paint(juce::Graphics& g) override;
    void timerCallback() override;
    
    void setWaveform(int waveformType);
    void pushBuffer(const juce::AudioBuffer<float>& buffer);
    
private:
    std::vector<float> waveformData;
    int currentWaveform = 0;
    int writePos = 0;
    
    void generateWaveform();
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Overlays\NameEditorOverlay.cpp
================================================================================
#include "NameEditorOverlay.h"

namespace CZ101 {
namespace UI {

NameEditorOverlay::NameEditorOverlay()
{
    addAndMakeVisible(titleLabel);
    titleLabel.setText("RENAME PRESET", juce::dontSendNotification);
    titleLabel.setJustificationType(juce::Justification::centred);
    titleLabel.setColour(juce::Label::textColourId, juce::Colours::cyan);
    
    addAndMakeVisible(nameEditor);
    nameEditor.setJustification(juce::Justification::centred);
    
    addAndMakeVisible(saveButton);
    addAndMakeVisible(cancelButton);
    
    saveButton.addListener(this);
    cancelButton.addListener(this);
    
    // Enter key support
    nameEditor.onReturnKey = [this] { buttonClicked(&saveButton); };
    nameEditor.onEscapeKey = [this] { buttonClicked(&cancelButton); };
}

NameEditorOverlay::~NameEditorOverlay()
{
    saveButton.removeListener(this);
    cancelButton.removeListener(this);
}

void NameEditorOverlay::paint(juce::Graphics& g)
{
    // Semi-transparent background for the whole component
    g.fillAll(juce::Colours::black.withAlpha(0.6f));
    
    // Dialog box
    auto bounds = getLocalBounds().toFloat();
    // Create a 300x150 rectangle centered in bounds
    auto dialogRect = juce::Rectangle<float>(300, 150).withCentre(bounds.getCentre());
    
    g.setColour(juce::Colour(0xff2a2a2a));
    g.fillRoundedRectangle(dialogRect, 10.0f);
    
    g.setColour(juce::Colours::cyan);
    g.drawRoundedRectangle(dialogRect, 10.0f, 2.0f);
}

void NameEditorOverlay::resized()
{
    auto bounds = getLocalBounds();
    auto center = bounds.getCentre();
    
    int w = 300;
    int h = 150;
    int x = center.x - w/2;
    int y = center.y - h/2;
    
    titleLabel.setBounds(x + 10, y + 10, w - 20, 30);
    nameEditor.setBounds(x + 20, y + 50, w - 40, 30);
    
    cancelButton.setBounds(x + 20, y + 100, 120, 30);
    saveButton.setBounds(x + 160, y + 100, 120, 30);
}

void NameEditorOverlay::startRename(const juce::String& currentName, std::function<void(const juce::String&)> onSaveCallback)
{
    nameEditor.setText(currentName);
    onSave = onSaveCallback;
    setVisible(true);
    toFront(true);
    nameEditor.grabKeyboardFocus();
}

void NameEditorOverlay::buttonClicked(juce::Button* b)
{
    if (b == &saveButton)
    {
        if (onSave) onSave(nameEditor.getText());
        setVisible(false);
    }
    else if (b == &cancelButton)
    {
        setVisible(false);
    }
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Overlays\NameEditorOverlay.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>

namespace CZ101 {
namespace UI {

class NameEditorOverlay : public juce::Component,
                          private juce::Button::Listener
{
public:
    NameEditorOverlay();
    ~NameEditorOverlay() override;

    void paint(juce::Graphics& g) override;
    void resized() override;
    
    // Setup
    void startRename(const juce::String& currentName, std::function<void(const juce::String&)> onSaveCallback);
    
    // Listener
    void buttonClicked(juce::Button* b) override;

private:
    juce::Label titleLabel;
    juce::TextEditor nameEditor;
    juce::TextButton saveButton { "SAVE" };
    juce::TextButton cancelButton { "CANCEL" };
    
    std::function<void(const juce::String&)> onSave;
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(NameEditorOverlay)
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Sections\EffectsSection.cpp
================================================================================
#include "EffectsSection.h"

namespace CZ101 {
namespace UI {

EffectsSection::EffectsSection(CZ101AudioProcessor& p)
    : audioProcessor(p),
      chorusRateKnob("Rate"), chorusDepthKnob("Depth"), chorusMixKnob("Mix"),
      delayTimeKnob("Time"), delayFeedbackKnob("F/B"), delayMixKnob("Mix"),
      reverbSizeKnob("Size"), reverbMixKnob("Mix")
{
    setText("EFFECTS");
    setTextLabelPosition(juce::Justification::centredTop);

    auto& params = audioProcessor.getParameters();

    // --- Chorus ---
    addAndMakeVisible(chorusLabel); chorusLabel.setText("Chorus", juce::dontSendNotification); chorusLabel.setJustificationType(juce::Justification::centred);
    addAndMakeVisible(chorusRateKnob); addAndMakeVisible(chorusDepthKnob); addAndMakeVisible(chorusMixKnob);
    if (params.chorusRate) attachments.emplace_back(std::make_unique<SliderAttachment>(*params.chorusRate, chorusRateKnob));
    if (params.chorusDepth) attachments.emplace_back(std::make_unique<SliderAttachment>(*params.chorusDepth, chorusDepthKnob));
    if (params.chorusMix) attachments.emplace_back(std::make_unique<SliderAttachment>(*params.chorusMix, chorusMixKnob));

    // --- Delay ---
    addAndMakeVisible(delayLabel); delayLabel.setText("Delay", juce::dontSendNotification); delayLabel.setJustificationType(juce::Justification::centred);
    addAndMakeVisible(delayTimeKnob); addAndMakeVisible(delayFeedbackKnob); addAndMakeVisible(delayMixKnob);
    if (params.delayTime) attachments.emplace_back(std::make_unique<SliderAttachment>(*params.delayTime, delayTimeKnob));
    if (params.delayFeedback) attachments.emplace_back(std::make_unique<SliderAttachment>(*params.delayFeedback, delayFeedbackKnob));
    if (params.delayMix) attachments.emplace_back(std::make_unique<SliderAttachment>(*params.delayMix, delayMixKnob));

    // --- Reverb ---
    addAndMakeVisible(reverbLabel); reverbLabel.setText("Reverb", juce::dontSendNotification); reverbLabel.setJustificationType(juce::Justification::centred);
    addAndMakeVisible(reverbSizeKnob); addAndMakeVisible(reverbMixKnob);
    if (params.reverbSize) attachments.emplace_back(std::make_unique<SliderAttachment>(*params.reverbSize, reverbSizeKnob));
    if (params.reverbMix) attachments.emplace_back(std::make_unique<SliderAttachment>(*params.reverbMix, reverbMixKnob));
}

EffectsSection::~EffectsSection() {}

void EffectsSection::paint(juce::Graphics& g) {}

void EffectsSection::resized()
{
    auto bounds = getLocalBounds().reduced(15);
    bounds.removeFromTop(20);

    juce::FlexBox flexBox;
    flexBox.flexDirection = juce::FlexBox::Direction::row;

    juce::FlexBox chorusBox, delayBox, reverbBox;
    chorusBox.flexDirection = juce::FlexBox::Direction::column;
    delayBox.flexDirection = juce::FlexBox::Direction::column;
    reverbBox.flexDirection = juce::FlexBox::Direction::column;

    chorusBox.items.add(juce::FlexItem(chorusLabel).withFlex(0.5f));
    chorusBox.items.add(juce::FlexItem(chorusRateKnob).withFlex(1.5f));
    chorusBox.items.add(juce::FlexItem(chorusDepthKnob).withFlex(1.5f));
    chorusBox.items.add(juce::FlexItem(chorusMixKnob).withFlex(1.5f));

    delayBox.items.add(juce::FlexItem(delayLabel).withFlex(0.5f));
    delayBox.items.add(juce::FlexItem(delayTimeKnob).withFlex(1.5f));
    delayBox.items.add(juce::FlexItem(delayFeedbackKnob).withFlex(1.5f));
    delayBox.items.add(juce::FlexItem(delayMixKnob).withFlex(1.5f));

    reverbBox.items.add(juce::FlexItem(reverbLabel).withFlex(0.5f));
    reverbBox.items.add(juce::FlexItem(reverbSizeKnob).withFlex(1.5f));
    reverbBox.items.add(juce::FlexItem(reverbMixKnob).withFlex(1.5f));

    flexBox.items.add(juce::FlexItem(chorusBox).withFlex(1.0f));
    flexBox.items.add(juce::FlexItem(delayBox).withFlex(1.0f));
    flexBox.items.add(juce::FlexItem(reverbBox).withFlex(1.0f));

    flexBox.performLayout(bounds);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Sections\EffectsSection.h
================================================================================
#pragma once

#include <JuceHeader.h>
#include "../Components/Knob.h"
#include "../../PluginProcessor.h"

namespace CZ101 {
namespace UI {

class EffectsSection : public juce::GroupComponent
{
public:
    EffectsSection(CZ101AudioProcessor& p);
    ~EffectsSection() override;

    void paint(juce::Graphics& g) override;
    void resized() override;

private:
    CZ101AudioProcessor& audioProcessor;

    // Knobs para Chorus
    Knob chorusRateKnob, chorusDepthKnob, chorusMixKnob;
    juce::Label chorusLabel;

    // Knobs para Delay
    Knob delayTimeKnob, delayFeedbackKnob, delayMixKnob;
    juce::Label delayLabel;

    // Knobs para Reverb
    Knob reverbSizeKnob, reverbMixKnob;
    juce::Label reverbLabel;

    // Attachments
    using SliderAttachment = juce::SliderParameterAttachment;
    std::vector<std::unique_ptr<SliderAttachment>> attachments;
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Sections\FilterLfoSection.cpp
================================================================================
#include "FilterLfoSection.h"

namespace CZ101 {
namespace UI {

FilterLfoSection::FilterLfoSection(CZ101AudioProcessor& p)
    : audioProcessor(p),
      lfoRateKnob("Rate"),
      lfoDepthKnob("Depth"),
      lfoDelayKnob("Delay")
{
    setText("LFO/VIBRATO");
    setTextLabelPosition(juce::Justification::centredTop);

    auto& params = audioProcessor.getParameters();



    // LFO/Vibrato Controls
    addAndMakeVisible(lfoLabel);
    lfoLabel.setText("Vibrato (LFO)", juce::dontSendNotification);
    lfoLabel.setJustificationType(juce::Justification::centred);
    addAndMakeVisible(lfoWaveSelector);
    lfoWaveSelector.addItemList( { "Triangle", "Saw Up", "Saw Down", "Square" }, 1 );
    addAndMakeVisible(lfoRateKnob);
    addAndMakeVisible(lfoDepthKnob);
    addAndMakeVisible(lfoDelayKnob);
    if (params.lfoWaveform) comboAttachments.emplace_back(std::make_unique<ComboBoxAttachment>(*params.lfoWaveform, lfoWaveSelector));
    if (params.lfoRate) sliderAttachments.emplace_back(std::make_unique<SliderAttachment>(*params.lfoRate, lfoRateKnob));
    if (params.lfoDepth) sliderAttachments.emplace_back(std::make_unique<SliderAttachment>(*params.lfoDepth, lfoDepthKnob));
    if (params.lfoDelay) sliderAttachments.emplace_back(std::make_unique<SliderAttachment>(*params.lfoDelay, lfoDelayKnob));
}

FilterLfoSection::~FilterLfoSection() {}

void FilterLfoSection::paint(juce::Graphics& g) {}

void FilterLfoSection::resized()
{
    auto bounds = getLocalBounds().reduced(15);
    bounds.removeFromTop(20);

    juce::FlexBox flexBox;
    flexBox.flexDirection = juce::FlexBox::Direction::row;

    // Filter Box Removed


    // LFO Box
    juce::FlexBox lfoBox;
    lfoBox.flexDirection = juce::FlexBox::Direction::column;
    lfoBox.items.add(juce::FlexItem(lfoLabel).withFlex(0.5f));
    lfoBox.items.add(juce::FlexItem(lfoWaveSelector).withFlex(1));
    juce::FlexBox lfoKnobs;
    lfoKnobs.items.add(juce::FlexItem(lfoRateKnob).withFlex(1));
    lfoKnobs.items.add(juce::FlexItem(lfoDepthKnob).withFlex(1));
    lfoKnobs.items.add(juce::FlexItem(lfoDelayKnob).withFlex(1));
    lfoBox.items.add(juce::FlexItem(lfoKnobs).withFlex(2));


    flexBox.items.add(juce::FlexItem(lfoBox).withFlex(3.0f));

    flexBox.performLayout(bounds);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Sections\FilterLfoSection.h
================================================================================
#pragma once

#include <JuceHeader.h>
#include "../Components/Knob.h"
#include "../../PluginProcessor.h"

namespace CZ101 {
namespace UI {

class FilterLfoSection : public juce::GroupComponent
{
public:
    FilterLfoSection(CZ101AudioProcessor& p);
    ~FilterLfoSection() override;

    void paint(juce::Graphics& g) override;
    void resized() override;

private:
    CZ101AudioProcessor& audioProcessor;

    // Filter Controls Removed


    // LFO Controls
    juce::ComboBox lfoWaveSelector;
    Knob lfoRateKnob, lfoDepthKnob, lfoDelayKnob;
    juce::Label lfoLabel;

    // Attachments
    using SliderAttachment = juce::SliderParameterAttachment;
    using ComboBoxAttachment = juce::ComboBoxParameterAttachment;
    std::vector<std::unique_ptr<SliderAttachment>> sliderAttachments;
    std::vector<std::unique_ptr<ComboBoxAttachment>> comboAttachments;
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Sections\OscillatorSection.cpp
================================================================================
#include "OscillatorSection.h"

namespace CZ101 {
namespace UI {

OscillatorSection::OscillatorSection(CZ101AudioProcessor& p)
    : audioProcessor(p),
      osc1LevelKnob("Lvl 1"),
      osc2LevelKnob("Lvl 2"),
      osc2DetuneKnob("Detune"),
      glideKnob("Glide")
{
    setText("DCO - Digital Controlled Oscillators");
    setTextLabelPosition(juce::Justification::centredTop);

    auto& params = audioProcessor.getParameters();

    // === DCO 1 ===
    addAndMakeVisible(osc1WaveSelector);
    osc1WaveSelector.addItemList( { "Sawtooth", "Square", "Pulse", "Double Sine", "Saw-Pulse", "Resonance 1", "Resonance 2", "Resonance 3" }, 1 );
    if (params.osc1Waveform)
        osc1WaveAttachment = std::make_unique<ComboBoxAttachment>(*params.osc1Waveform, osc1WaveSelector);
    
    addAndMakeVisible(osc1LevelKnob);
    if (params.osc1Level)
        osc1LevelAttachment = std::make_unique<SliderAttachment>(*params.osc1Level, osc1LevelKnob);

    // === DCO 2 ===
    addAndMakeVisible(osc2WaveSelector);
    osc2WaveSelector.addItemList( { "Sawtooth", "Square", "Pulse", "Double Sine", "Saw-Pulse", "Resonance 1", "Resonance 2", "Resonance 3" }, 1 );
    if (params.osc2Waveform)
        osc2WaveAttachment = std::make_unique<ComboBoxAttachment>(*params.osc2Waveform, osc2WaveSelector);

    addAndMakeVisible(osc2LevelKnob);
    if (params.osc2Level)
        osc2LevelAttachment = std::make_unique<SliderAttachment>(*params.osc2Level, osc2LevelKnob);

    addAndMakeVisible(osc2DetuneKnob);
    if (params.osc2Detune)
        osc2DetuneAttachment = std::make_unique<SliderAttachment>(*params.osc2Detune, osc2DetuneKnob);

    // === Shared Controls ===
    addAndMakeVisible(hardSyncButton);
    hardSyncButton.setButtonText("Hard Sync");
    hardSyncButton.setClickingTogglesState(true);
    hardSyncButton.setColour(juce::TextButton::buttonOnColourId, juce::Colours::red);
    if (params.hardSync)
        hardSyncAttachment = std::make_unique<ButtonAttachment>(*params.hardSync, hardSyncButton);

    addAndMakeVisible(ringModButton);
    ringModButton.setButtonText("Ring Mod");
    ringModButton.setClickingTogglesState(true);
    ringModButton.setColour(juce::TextButton::buttonOnColourId, juce::Colours::red);
    if (params.ringMod)
        ringModAttachment = std::make_unique<ButtonAttachment>(*params.ringMod, ringModButton);

    addAndMakeVisible(glideKnob);
    if (params.glideTime)
        glideAttachment = std::make_unique<SliderAttachment>(*params.glideTime, glideKnob);
}

OscillatorSection::~OscillatorSection() {}

void OscillatorSection::paint(juce::Graphics& g) {
    // El GroupComponent se encarga del borde y el tÃ­tulo.
}

void OscillatorSection::resized()
{
    auto bounds = getLocalBounds().reduced(15);
    bounds.removeFromTop(20);

    auto dcoArea = bounds.removeFromTop(bounds.getHeight() * 0.7f);
    auto sharedArea = bounds;

    auto dco1Area = dcoArea.removeFromLeft(dcoArea.getWidth() / 2).reduced(5);
    auto dco2Area = dcoArea.reduced(5);

    // --- Layout DCO 1 con FlexBox ---
    juce::FlexBox flexDCO1;
    flexDCO1.flexDirection = juce::FlexBox::Direction::column;
    flexDCO1.items.add(juce::FlexItem(osc1WaveSelector).withFlex(0.5f));
    flexDCO1.items.add(juce::FlexItem(osc1LevelKnob).withFlex(1.5f));
    flexDCO1.performLayout(dco1Area);

    // --- Layout DCO 2 con FlexBox ---
    juce::FlexBox flexDCO2;
    flexDCO2.flexDirection = juce::FlexBox::Direction::column;
    flexDCO2.items.add(juce::FlexItem(osc2WaveSelector).withFlex(0.5f));
    
    juce::FlexBox dco2Knobs;
    dco2Knobs.items.add(juce::FlexItem(osc2LevelKnob).withFlex(1));
    dco2Knobs.items.add(juce::FlexItem(osc2DetuneKnob).withFlex(1));
    flexDCO2.items.add(juce::FlexItem(dco2Knobs).withFlex(1.5f));
    flexDCO2.performLayout(dco2Area);

    // --- Layout Controles Compartidos ---
    juce::FlexBox sharedFlex;
    sharedFlex.items.add(juce::FlexItem(glideKnob).withFlex(1));
    sharedFlex.items.add(juce::FlexItem(hardSyncButton).withFlex(1));
    sharedFlex.items.add(juce::FlexItem(ringModButton).withFlex(1));
    sharedFlex.performLayout(sharedArea);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Sections\OscillatorSection.h
================================================================================
#pragma once

#include <JuceHeader.h>
#include "../Components/Knob.h"
#include "../../PluginProcessor.h"

namespace CZ101 {
namespace UI {

class OscillatorSection : public juce::GroupComponent
{
public:
    OscillatorSection(CZ101AudioProcessor& p);
    ~OscillatorSection() override;

    void paint(juce::Graphics& g) override;
    void resized() override;

private:
    CZ101AudioProcessor& audioProcessor;
    
    // Controles de DCO1
    juce::ComboBox osc1WaveSelector;
    juce::Label osc1WaveLabel;
    Knob osc1LevelKnob;
    juce::Label osc1LevelLabel;

    // Controles de DCO2
    juce::ComboBox osc2WaveSelector;
    juce::Label osc2WaveLabel;
    Knob osc2LevelKnob;
    juce::Label osc2LevelLabel;
    Knob osc2DetuneKnob;
    juce::Label osc2DetuneLabel;

    // Controles compartidos
    juce::TextButton hardSyncButton;
    juce::TextButton ringModButton;
    Knob glideKnob;
    juce::Label glideLabel;

    // Attachments
    using ComboBoxAttachment = juce::ComboBoxParameterAttachment;
    using SliderAttachment = juce::SliderParameterAttachment;
    using ButtonAttachment = juce::ButtonParameterAttachment;

    std::unique_ptr<ComboBoxAttachment> osc1WaveAttachment;
    std::unique_ptr<SliderAttachment> osc1LevelAttachment;
    std::unique_ptr<ComboBoxAttachment> osc2WaveAttachment;
    std::unique_ptr<SliderAttachment> osc2LevelAttachment;
    std::unique_ptr<SliderAttachment> osc2DetuneAttachment;
    std::unique_ptr<ButtonAttachment> hardSyncAttachment;
    std::unique_ptr<ButtonAttachment> ringModAttachment;
    std::unique_ptr<SliderAttachment> glideAttachment;
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\CircularBuffer.h
================================================================================
#pragma once

#include <vector>
#include <cmath>
#include <algorithm>
#include <juce_core/juce_core.h>

namespace CZ101 {
namespace Utils {

template <typename T>
class CircularBuffer {
public:
    CircularBuffer() = default;
    
    void setSize(int newSize) {
        buffer.resize(newSize, 0);
        writeIndex = 0;
        size = newSize;
    }
    
    void clear() {
        std::fill(buffer.begin(), buffer.end(), T(0));
        writeIndex = 0;
    }
    
    void push(T sample) {
        buffer[writeIndex] = sample;
        writeIndex++;
        if (writeIndex >= size) writeIndex = 0;
    }
    
    T get(int delaySamples) const {
        int readIndex = writeIndex - 1 - delaySamples;
        while (readIndex < 0) readIndex += size;
        while (readIndex >= size) readIndex -= size;
        return buffer[readIndex];
    }
    
    // Linear Interpolation
    T getInterpolated(float delaySamples) const {
        int i = (int)delaySamples;
        float f = delaySamples - i;
        
        T s1 = get(i);
        T s2 = get(i + 1);
        
        return s1 + (s2 - s1) * f;
    }
    
private:
    std::vector<T> buffer;
    int writeIndex = 0;
    int size = 0;
};

} // namespace Utils
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\DSPHelpers.h
================================================================================
#pragma once

#include <cmath>
#include <algorithm>

namespace CZ101 {
namespace Utils {

class DSPHelpers
{
public:
    static float dbToGain(float db)
    {
        return std::pow(10.0f, db / 20.0f);
    }
    
    static float gainToDb(float gain)
    {
        return 20.0f * std::log10(std::max(gain, 0.00001f));
    }
    
    static float midiNoteToFrequency(int midiNote)
    {
        return 440.0f * std::pow(2.0f, (midiNote - 69) / 12.0f);
    }
    
    static int frequencyToMidiNote(float frequency)
    {
        return static_cast<int>(69 + 12 * std::log2(frequency / 440.0f));
    }
    
    static float lerp(float a, float b, float t)
    {
        return a + t * (b - a);
    }
    
    static float clamp(float value, float min, float max)
    {
        return std::clamp(value, min, max);
    }
    
    static float mapRange(float value, float inMin, float inMax, float outMin, float outMax)
    {
        return outMin + (value - inMin) * (outMax - outMin) / (inMax - inMin);
    }
};

} // namespace Utils
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\PerformanceMonitor.cpp
================================================================================
#include "PerformanceMonitor.h"
#include <algorithm>

namespace CZ101 {
namespace Utils {

PerformanceMonitor::PerformanceMonitor()
{
}

void PerformanceMonitor::startMeasurement()
{
    startTime = std::chrono::high_resolution_clock::now();
}

void PerformanceMonitor::stopMeasurement()
{
    endTime = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(endTime - startTime);
    double timeMs = duration.count() / 1000.0;
    
    totalTime += timeMs;
    peakTime = std::max(peakTime, timeMs);
    measurementCount++;
}

double PerformanceMonitor::getAverageCpuUsage() const
{
    if (measurementCount == 0)
        return 0.0;
    
    return totalTime / measurementCount;
}

double PerformanceMonitor::getPeakCpuUsage() const
{
    return peakTime;
}

int PerformanceMonitor::getVoiceCount() const
{
    return currentVoiceCount;
}

void PerformanceMonitor::setVoiceCount(int count)
{
    currentVoiceCount = count;
}

void PerformanceMonitor::reset()
{
    totalTime = 0.0;
    peakTime = 0.0;
    measurementCount = 0;
}

} // namespace Utils
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\PerformanceMonitor.h
================================================================================
#pragma once

#include <chrono>
#include <string>

namespace CZ101 {
namespace Utils {

class PerformanceMonitor
{
public:
    PerformanceMonitor();
    
    void startMeasurement();
    void stopMeasurement();
    
    double getAverageCpuUsage() const;
    double getPeakCpuUsage() const;
    int getVoiceCount() const;
    
    void setVoiceCount(int count);
    void reset();
    
private:
    std::chrono::high_resolution_clock::time_point startTime;
    std::chrono::high_resolution_clock::time_point endTime;
    
    double totalTime = 0.0;
    double peakTime = 0.0;
    int measurementCount = 0;
    int currentVoiceCount = 0;
};

} // namespace Utils
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\SmoothedValue.h
================================================================================
#pragma once

#include <cmath>

namespace CZ101 {
namespace Utils {

template<typename FloatType>
class SmoothedValue
{
public:
    SmoothedValue() = default;
    
    void reset(FloatType initialValue) noexcept
    {
        currentValue = initialValue;
        target = initialValue;
    }
    
    void setTargetValue(FloatType newTarget) noexcept
    {
        target = newTarget;
    }
    
    void setSmoothingTime(FloatType timeInSeconds, double sampleRate) noexcept
    {
        auto numSamples = static_cast<int>(timeInSeconds * sampleRate);
        setNumSteps(numSamples);
    }
    
    void setNumSteps(int numSteps) noexcept
    {
        stepsToTarget = numSteps;
        countdown = stepsToTarget;
        
        if (countdown > 0)
            step = (target - currentValue) / static_cast<FloatType>(countdown);
        else
            step = 0;
    }
    
    FloatType getNextValue() noexcept
    {
        if (countdown <= 0)
        {
            currentValue = target;
            return currentValue;
        }
        
        --countdown;
        currentValue += step;
        return currentValue;
    }
    
    FloatType getCurrentValue() const noexcept
    {
        return currentValue;
    }
    
    FloatType getTargetValue() const noexcept
    {
        return target;
    }
    
    bool isSmoothing() const noexcept
    {
        return countdown > 0;
    }

private:
    FloatType currentValue = 0;
    FloatType target = 0;
    FloatType step = 0;
    int countdown = 0;
    int stepsToTarget = 0;
};

} // namespace Utils
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\StringHelpers.h
================================================================================
#pragma once

#include <string>
#include <sstream>
#include <iomanip>

namespace CZ101 {
namespace Utils {

class StringHelpers
{
public:
    static std::string formatFrequency(float hz)
    {
        std::ostringstream oss;
        if (hz >= 1000.0f)
            oss << std::fixed << std::setprecision(2) << (hz / 1000.0f) << " kHz";
        else
            oss << std::fixed << std::setprecision(1) << hz << " Hz";
        return oss.str();
    }
    
    static std::string formatTime(float seconds)
    {
        std::ostringstream oss;
        if (seconds >= 1.0f)
            oss << std::fixed << std::setprecision(2) << seconds << " s";
        else
            oss << std::fixed << std::setprecision(1) << (seconds * 1000.0f) << " ms";
        return oss.str();
    }
    
    static std::string formatPercentage(float value)
    {
        std::ostringstream oss;
        oss << std::fixed << std::setprecision(1) << (value * 100.0f) << "%";
        return oss.str();
    }
    
    static std::string formatDecibels(float db)
    {
        std::ostringstream oss;
        oss << std::fixed << std::setprecision(1) << db << " dB";
        return oss.str();
    }
};

} // namespace Utils
} // namespace CZ101
