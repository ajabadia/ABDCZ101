
================================================================================
FILE: .\Source\PluginEditor.cpp
================================================================================
/*
  ==============================================================================
    PluginEditor.cpp - REDESIGNED for 800x600
    Layout: 2-column dashboard with tabs
  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "State/Parameters.h" 

CZ101AudioProcessorEditor::CZ101AudioProcessorEditor(CZ101AudioProcessor& p)
    : AudioProcessorEditor(&p), audioProcessor(p),
      // Oscillators
      osc1LevelKnob("OSC1"), osc2LevelKnob("OSC2"), osc2DetuneKnob("DET"),
      hardSyncButton("HSync"), ringModButton("RMod"), glideKnob("GLIDE"),
      // Filter
      filterCutoffKnob("CUTOFF"), filterResonanceKnob("RES"),
      // Envelopes
      pitchEditor(p, CZ101::UI::EnvelopeEditor::EnvelopeType::PITCH),
      dcwEditor(p, CZ101::UI::EnvelopeEditor::EnvelopeType::DCW),
      dcaEditor(p, CZ101::UI::EnvelopeEditor::EnvelopeType::DCA),
      dcwAttackKnob("A"), dcwDecayKnob("D"), dcwSustainKnob("S"), dcwReleaseKnob("R"),
      dcaAttackKnob("A"), dcaDecayKnob("D"), dcaSustainKnob("S"), dcaReleaseKnob("R"),
      // Effects
      delayTimeKnob("TIME"), delayFeedbackKnob("FB"), delayMixKnob("MIX"),
      chorusRateKnob("RATE"), chorusDepthKnob("DEPTH"), chorusMixKnob("MIX"),
      reverbSizeKnob("SIZE"), reverbMixKnob("MIX"),
      lfoRateKnob("RATE"),
      // Keyboard
      keyboardComponent(keyboardState, juce::MidiKeyboardComponent::horizontalKeyboard)
{
    juce::LookAndFeel::setDefaultLookAndFeel(&customLookAndFeel);
    
    // Enable GPU Architecture (Safe for RPi)
    openGLContext.attachTo(*this);
    
    // ========== HEADER ==========
    addAndMakeVisible(lcdDisplay);
    lcdDisplay.setText("CZ-101 EMULATOR", "PRESET: INIT");
    
    addAndMakeVisible(presetBrowser);
    presetBrowser.setPresetManager(&audioProcessor.getPresetManager());
    presetBrowser.onPresetSelected = [this](int index) {
        juce::ignoreUnused(index);
        auto name = audioProcessor.getPresetManager().getCurrentPreset().name;
        lcdDisplay.setText("CZ-101 EMULATOR", "PRESET: " + juce::String(name));
    };

    presetBrowser.onSaveRequested = [this]()
    {
        auto currentName = audioProcessor.getPresetManager().getCurrentPreset().name;
        nameOverlay.startRename(currentName, [this](const juce::String& newName)
        {
            auto& pm = audioProcessor.getPresetManager();
            // 1. Capture current implementation state (knobs etc) back to preset structure
            pm.copyStateFromProcessor();

            // 2. Save to internal memory (active slot)
            // Ideally we get the index from the Processor or Browser.
            // For now, we update the current one based on processor state, then persist bank.
            // Note: simple save to current slot logic:
            // We assume the user wants to overwrite the currently selected preset.
            // We need to find which index is active. 
            // Let's assume the preset manager or processor knows.
            // The browser triggers loadPreset(index).
            // But we don't store "currentPresetIndex" in manager? 
            // We'll iterate to find name match OR just save to a default User slot if unclear.
            // **Correction**: PresetBrowser has getSelectedItemIndex! But we are in Editor.
            // We can ask the browser:
            int idx = presetBrowser.getSelectedItemIndex(); // 1-based usually in ComboBox
            int presetIndex = idx - 1; 

            if (presetIndex >= 0)
            {
                pm.savePreset(presetIndex, newName.toStdString());
                
                // 3. Persist to Disk
                juce::File defaultsDir = juce::File::getSpecialLocation(juce::File::userDocumentsDirectory)
                                            .getChildFile("CZ101Emulator");
                if (!defaultsDir.exists()) defaultsDir.createDirectory();
                pm.saveBank(defaultsDir.getChildFile("user_bank.json"));
                
                // 4. Update UI
                audioProcessor.changeProgramName(presetIndex, newName);
                presetBrowser.updatePresetList();
                presetBrowser.setSelectedItemIndex(idx); // restore selection
                lcdDisplay.setText("CZ-101   SAVED", "PRESET: " + newName);
            }
        });
        
        nameOverlay.setVisible(true);
        nameOverlay.toFront(true);
    };
    
    addAndMakeVisible(midiIndicator);
    addAndMakeVisible(midiOutputSelector);
    midiOutputSelector.setTextWhenNoChoicesAvailable("No MIDI");
    midiOutputSelector.onChange = [this] { 
        int idx = midiOutputSelector.getSelectedItemIndex();
        int devIdx = idx - 1;
        auto devices = juce::MidiOutput::getAvailableDevices();
        if (devIdx >= 0 && devIdx < devices.size())
            activeMidiOutput = juce::MidiOutput::openDevice(devices[devIdx].identifier);
        else
            activeMidiOutput.reset();
    };
    refreshMidiOutputs();
    
    addAndMakeVisible(loadSysExButton);
    loadSysExButton.onClick = [this] { loadSysExFile(); };
    
    addAndMakeVisible(saveSysExButton);
    saveSysExButton.onClick = [this] { saveSysExFile(); };
    
    // ========== LEFT PANEL: OSCILLATORS + FILTER + LFO ==========
    addAndMakeVisible(osc1WaveSelector);
    osc1WaveSelector.addItemList({"Sine", "Saw", "Square", "Triangle"}, 1);
    addAndMakeVisible(osc1LevelKnob);
    
    addAndMakeVisible(osc2WaveSelector);
    osc2WaveSelector.addItemList({"Sine", "Saw", "Square", "Triangle"}, 1);
    addAndMakeVisible(osc2LevelKnob);
    addAndMakeVisible(osc2DetuneKnob);
    addAndMakeVisible(hardSyncButton);
    addAndMakeVisible(ringModButton);
    addAndMakeVisible(glideKnob);
    
    addAndMakeVisible(filterCutoffKnob);
    addAndMakeVisible(filterResonanceKnob);
    addAndMakeVisible(lfoRateKnob);
    
    addAndMakeVisible(waveformDisplay);
    
    // ========== RIGHT PANEL: ENVELOPES + EFFECTS ==========
    addAndMakeVisible(envelopeTabs);
    
    // Envelope panels (content for tabs)
    // Envelope panels (content for tabs)
    auto pitchPanel = std::make_unique<juce::Component>();
    pitchPanel->addAndMakeVisible(pitchEditor);
    envelopeTabs.addTab("PITCH", juce::Colours::magenta, pitchPanel.release(), true);
    
    auto dcwPanel = std::make_unique<juce::Component>();
    dcwPanel->addAndMakeVisible(dcwEditor);
    dcwPanel->addAndMakeVisible(dcwAttackKnob);
    dcwPanel->addAndMakeVisible(dcwDecayKnob);
    dcwPanel->addAndMakeVisible(dcwSustainKnob);
    dcwPanel->addAndMakeVisible(dcwReleaseKnob);
    envelopeTabs.addTab("DCW", juce::Colours::orange, dcwPanel.release(), true);
    
    auto dcaPanel = std::make_unique<juce::Component>();
    dcaPanel->addAndMakeVisible(dcaEditor);
    dcaPanel->addAndMakeVisible(dcaAttackKnob);
    dcaPanel->addAndMakeVisible(dcaDecayKnob);
    dcaPanel->addAndMakeVisible(dcaSustainKnob);
    dcaPanel->addAndMakeVisible(dcaReleaseKnob);
    envelopeTabs.addTab("DCA", juce::Colours::cyan, dcaPanel.release(), true);
    
    // Effects (2x3 grid)
    addAndMakeVisible(delayTimeKnob);
    addAndMakeVisible(delayFeedbackKnob);
    addAndMakeVisible(delayMixKnob);
    addAndMakeVisible(chorusRateKnob);
    addAndMakeVisible(chorusDepthKnob);
    addAndMakeVisible(chorusMixKnob);
    addAndMakeVisible(reverbSizeKnob);
    addAndMakeVisible(reverbMixKnob);
    
    delayLabel.setText("DELAY", juce::dontSendNotification);
    chorusLabel.setText("CHORUS", juce::dontSendNotification);
    reverbLabel.setText("REVERB", juce::dontSendNotification);
    delayLabel.setJustificationType(juce::Justification::centred);
    chorusLabel.setJustificationType(juce::Justification::centred);
    reverbLabel.setJustificationType(juce::Justification::centred);
    addAndMakeVisible(delayLabel);
    addAndMakeVisible(chorusLabel);
    addAndMakeVisible(reverbLabel);
    
    // ========== BOTTOM: KEYBOARD ==========
    addAndMakeVisible(keyboardComponent);
    keyboardState.addListener(this);
    
    // ========== ATTACHMENTS ==========
    auto& params = audioProcessor.getParameters();
    
    auto attachSlider = [&](juce::AudioParameterFloat* param, juce::Slider& slider) {
        if (param) sliderAttachments.emplace_back(std::make_unique<SliderAttachment>(*param, slider));
    };
    
    auto attachCombo = [&](juce::AudioParameterChoice* param, juce::ComboBox& box) {
        if (param) comboBoxAttachments.emplace_back(std::make_unique<ComboBoxAttachment>(*param, box));
    };

    attachSlider(params.osc1Level, osc1LevelKnob);
    attachCombo(params.osc1Waveform, osc1WaveSelector);
    attachSlider(params.osc2Level, osc2LevelKnob);
    attachSlider(params.osc2Detune, osc2DetuneKnob);
    attachCombo(params.osc2Waveform, osc2WaveSelector);
    
    if (params.hardSync)
        hardSyncAttachment = std::make_unique<ButtonAttachment>(*params.hardSync, hardSyncButton);
    if (params.ringMod)
        ringModAttachment = std::make_unique<ButtonAttachment>(*params.ringMod, ringModButton);
    if (params.glideTime)
        attachSlider(params.glideTime, glideKnob);
    
    attachSlider(params.filterCutoff, filterCutoffKnob);
    attachSlider(params.filterResonance, filterResonanceKnob);
    
    attachSlider(params.dcwAttack, dcwAttackKnob);
    attachSlider(params.dcwDecay, dcwDecayKnob);
    attachSlider(params.dcwSustain, dcwSustainKnob);
    attachSlider(params.dcwRelease, dcwReleaseKnob);
    
    attachSlider(params.dcaAttack, dcaAttackKnob);
    attachSlider(params.dcaDecay, dcaDecayKnob);
    attachSlider(params.dcaSustain, dcaSustainKnob);
    attachSlider(params.dcaRelease, dcaReleaseKnob);
    
    attachSlider(params.delayTime, delayTimeKnob);
    attachSlider(params.delayFeedback, delayFeedbackKnob);
    attachSlider(params.delayMix, delayMixKnob);
    attachSlider(params.chorusRate, chorusRateKnob);
    attachSlider(params.chorusDepth, chorusDepthKnob);
    attachSlider(params.chorusMix, chorusMixKnob);
    attachSlider(params.reverbSize, reverbSizeKnob);
    attachSlider(params.reverbMix, reverbMixKnob);
    attachSlider(params.lfoRate, lfoRateKnob);

    // LCD Click to Rename
    lcdDisplay.onClick = [this]() 
    {
        // Get current name from PresetManager?
        auto currentName = audioProcessor.getPresetManager().getCurrentPreset().name;
        
        nameOverlay.startRename(currentName, [this](const juce::String& newName) {
            audioProcessor.getPresetManager().renamePreset(audioProcessor.getCurrentProgram(), newName.toStdString());
            // Refresh LCD immediately
            audioProcessor.changeProgramName(audioProcessor.getCurrentProgram(), newName);
            // Also need to refresh Browser if visible?
            // Sending a change message might be cleaner but direct update works for now.
        });
    };
    
    addAndMakeVisible(nameOverlay);
    nameOverlay.setVisible(false);
    
    setSize(800, 600);
    setResizable(true, true); 
    setResizeLimits(600, 450, 1920, 1080); 
    startTimerHz(60); 
}

CZ101AudioProcessorEditor::~CZ101AudioProcessorEditor()
{
    stopTimer();
    openGLContext.detach();
    keyboardState.removeListener(this);
    juce::LookAndFeel::setDefaultLookAndFeel(nullptr);
    // Overlay covers entire specific area or full window
    nameOverlay.setBounds(getLocalBounds());
}

void CZ101AudioProcessorEditor::paint(juce::Graphics& g)
{
    // Dark background
    g.fillAll(juce::Colour(0xff0a0e14));
    
    // Subtle grid lines
    g.setColour(juce::Colour(0xff1a2a3a).withAlpha(0.3f));
    for (int x = 0; x < getWidth(); x += 50)
        g.drawVerticalLine(x, 0, getHeight());
}

void CZ101AudioProcessorEditor::resized() 
{
    auto area = getLocalBounds();
    
    // ========== HEADER (40px) ==========
    auto headerArea = area.removeFromTop(40);
    
    // LEFT: Preset selector
    auto leftHeader = headerArea.removeFromLeft(160);
    presetBrowser.setBounds(leftHeader.removeFromLeft(150).reduced(2));
    
    headerArea.removeFromLeft(6);
    
    // CENTER-LEFT: Buttons
    auto buttonArea = headerArea.removeFromLeft(180);
    loadSysExButton.setBounds(buttonArea.removeFromLeft(55).reduced(2));
    // loadSysExButton.setButtonText("LOAD"); // Keeping existing text init
    
    saveSysExButton.setBounds(buttonArea.removeFromLeft(55).reduced(2));
    // saveSysExButton.setButtonText("SAVE"); 
    
    headerArea.removeFromLeft(6);
    
    // CENTER: LCD Display
    auto centerHeader = headerArea.removeFromLeft(250);
    lcdDisplay.setBounds(centerHeader.reduced(2));
    
    headerArea.removeFromLeft(6);
    
    // RIGHT: MIDI + CPU
    auto rightHeader = headerArea;
    midiOutputSelector.setBounds(rightHeader.removeFromRight(90).reduced(2));
    rightHeader.removeFromRight(4);
    midiIndicator.setBounds(rightHeader.removeFromRight(30).reduced(2));
    
    area.removeFromTop(6);
    
    // ========== MAIN: 3 COLUMNS ==========
    int col1Width = area.getWidth() * 0.22f;
    int col2Width = area.getWidth() * 0.32f;
    // int col3Width = area.getWidth() - col1Width - col2Width;
    
    // --- COLUMN 1: OSCILLATORS ---
    auto col1 = area.removeFromLeft(col1Width).reduced(3);
    
    auto oscArea = col1.removeFromTop(100);
    juce::FlexBox oscFlex;
    oscFlex.flexWrap = juce::FlexBox::Wrap::wrap;
    oscFlex.justifyContent = juce::FlexBox::JustifyContent::center;
    
    oscFlex.items.add(juce::FlexItem(osc1WaveSelector).withWidth(70).withHeight(22).withMargin(2));
    oscFlex.items.add(juce::FlexItem(osc1LevelKnob).withWidth(50).withHeight(50).withMargin(2));
    oscFlex.items.add(juce::FlexItem(osc2WaveSelector).withWidth(70).withHeight(22).withMargin(2));
    oscFlex.items.add(juce::FlexItem(osc2LevelKnob).withWidth(50).withHeight(50).withMargin(2));
    oscFlex.items.add(juce::FlexItem(osc2DetuneKnob).withWidth(50).withHeight(50).withMargin(2));
    oscFlex.items.add(juce::FlexItem(hardSyncButton).withWidth(60).withHeight(22).withMargin(2));
    oscFlex.items.add(juce::FlexItem(ringModButton).withWidth(60).withHeight(22).withMargin(2));
    
    oscFlex.performLayout(oscArea);
    
    col1.removeFromTop(3);
    
    auto filterArea = col1.removeFromTop(60);
    juce::FlexBox filterFlex;
    filterFlex.flexWrap = juce::FlexBox::Wrap::wrap;
    filterFlex.justifyContent = juce::FlexBox::JustifyContent::center;
    
    filterFlex.items.add(juce::FlexItem(filterCutoffKnob).withWidth(50).withHeight(50).withMargin(2));
    filterFlex.items.add(juce::FlexItem(filterResonanceKnob).withWidth(50).withHeight(50).withMargin(2));
    
    filterFlex.performLayout(filterArea);
    
    col1.removeFromTop(3);
    
    auto waveArea = col1;
    waveformDisplay.setBounds(waveArea.reduced(2));
    
    // --- COLUMN 2: ENVELOPES ---
    auto col2 = area.removeFromLeft(col2Width).reduced(3);
    
    envelopeTabs.setBounds(col2.reduced(2));
    
    for (int i = 0; i < envelopeTabs.getNumTabs(); i++) {
        if (auto panel = dynamic_cast<juce::Component*>(envelopeTabs.getTabContentComponent(i))) {
            auto tabBounds = panel->getLocalBounds();
            
            if (i == 0) { // PITCH - No ADSR Knobs, full editor
                pitchEditor.setBounds(tabBounds.reduced(5));
            }
            else if (i == 1) { // DCW
                auto editorArea = tabBounds.removeFromTop(100).reduced(5);
                dcwEditor.setBounds(editorArea);
                tabBounds.removeFromTop(3);
                
                auto adsrArea = tabBounds.reduced(5);
                juce::FlexBox adsr;
                adsr.flexWrap = juce::FlexBox::Wrap::wrap;
                adsr.justifyContent = juce::FlexBox::JustifyContent::spaceBetween;
                
                adsr.items.add(juce::FlexItem(dcwAttackKnob).withWidth(35).withHeight(45).withMargin(2));
                adsr.items.add(juce::FlexItem(dcwDecayKnob).withWidth(35).withHeight(45).withMargin(2));
                adsr.items.add(juce::FlexItem(dcwSustainKnob).withWidth(35).withHeight(45).withMargin(2));
                adsr.items.add(juce::FlexItem(dcwReleaseKnob).withWidth(35).withHeight(45).withMargin(2));
                
                adsr.performLayout(adsrArea);
            }
            else if (i == 2) { // DCA
                auto editorArea = tabBounds.removeFromTop(100).reduced(5);
                dcaEditor.setBounds(editorArea);
                tabBounds.removeFromTop(3);
                
                auto adsrArea = tabBounds.reduced(5);
                juce::FlexBox adsr;
                adsr.flexWrap = juce::FlexBox::Wrap::wrap;
                adsr.justifyContent = juce::FlexBox::JustifyContent::spaceBetween;
                
                adsr.items.add(juce::FlexItem(dcaAttackKnob).withWidth(35).withHeight(45).withMargin(2));
                adsr.items.add(juce::FlexItem(dcaDecayKnob).withWidth(35).withHeight(45).withMargin(2));
                adsr.items.add(juce::FlexItem(dcaSustainKnob).withWidth(35).withHeight(45).withMargin(2));
                adsr.items.add(juce::FlexItem(dcaReleaseKnob).withWidth(35).withHeight(45).withMargin(2));
                
                adsr.performLayout(adsrArea);
            }
        }
    }
    
    // --- COLUMN 3: EFFECTS + LFO ---
    auto col3 = area.reduced(3);
    
    auto effectsArea = col3.removeFromTop(col3.getHeight() * 0.78f);
    col3.removeFromTop(6);
    auto lfoArea = col3;
    
    // EFFECTS GRID (2x3)
    int fxColWidth = effectsArea.getWidth() / 2;
    int fxRowHeight = effectsArea.getHeight() / 3;
    
    auto row1 = effectsArea.removeFromTop(fxRowHeight);
    
    // DELAY
    auto delayCol = row1.removeFromLeft(fxColWidth);
    delayLabel.setBounds(delayCol.removeFromTop(15).reduced(2));
    
    auto delayGrid = delayCol.reduced(5);
    auto delayRow1 = delayGrid.removeFromTop(delayGrid.getHeight() / 2);
    
    delayTimeKnob.setBounds(delayRow1.removeFromLeft(fxColWidth / 2).reduced(2));
    delayFeedbackKnob.setBounds(delayRow1.reduced(2));
    delayMixKnob.setBounds(delayGrid.reduced(2));
    
    // CHORUS
    auto chorusCol = row1;
    chorusLabel.setBounds(chorusCol.removeFromTop(15).reduced(2));
    
    auto chorusGrid = chorusCol.reduced(5);
    auto chorusRow1 = chorusGrid.removeFromTop(chorusGrid.getHeight() / 2);
    
    chorusRateKnob.setBounds(chorusRow1.removeFromLeft(fxColWidth / 2).reduced(2));
    chorusDepthKnob.setBounds(chorusRow1.reduced(2));
    chorusMixKnob.setBounds(chorusGrid.reduced(2));
    
    // REVERB
    auto row2 = effectsArea;
    reverbLabel.setBounds(row2.removeFromTop(15).reduced(2));
    
    auto reverbGrid = row2.reduced(5);
    reverbSizeKnob.setBounds(reverbGrid.removeFromLeft(reverbGrid.getWidth() / 2).reduced(2));
    reverbMixKnob.setBounds(reverbGrid.reduced(2));
    
    // LFO
    auto lfoRateArea = lfoArea.removeFromLeft(lfoArea.getWidth() / 2);
    lfoRateKnob.setBounds(lfoRateArea.reduced(2));
    
    auto glideArea = lfoArea;
    glideKnob.setBounds(glideArea.reduced(2));
    
    // ========== KEYBOARD (80px) ==========
    auto keyboardArea = getLocalBounds().removeFromBottom(80);
    keyboardComponent.setBounds(keyboardArea.reduced(3));
}

void CZ101AudioProcessorEditor::refreshMidiOutputs()
{
    auto devices = juce::MidiOutput::getAvailableDevices();
    midiOutputSelector.clear();
    midiOutputSelector.addItem("No MIDI", 1);
    
    int i = 2;
    for (const auto& dev : devices)
        midiOutputSelector.addItem(dev.name, i++);
    
    midiOutputSelector.setSelectedId(1);
}

void CZ101AudioProcessorEditor::handleNoteOn(juce::MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity)
{
    juce::MidiMessage noteOn = juce::MidiMessage::noteOn(midiChannel, midiNoteNumber, velocity);
    audioProcessor.getMidiProcessor().processMessage(noteOn);
    midiIndicator.triggerActivity();
    if (activeMidiOutput) activeMidiOutput->sendMessageNow(noteOn);
}

void CZ101AudioProcessorEditor::handleNoteOff(juce::MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity)
{
    juce::MidiMessage noteOff = juce::MidiMessage::noteOff(midiChannel, midiNoteNumber, velocity);
    audioProcessor.getMidiProcessor().processMessage(noteOff);
    if (activeMidiOutput) activeMidiOutput->sendMessageNow(noteOff);
}

void CZ101AudioProcessorEditor::timerCallback()
{
    auto cpu = audioProcessor.getPerformanceMonitor().getAverageCpuUsage() * 100.0;
    auto preset = audioProcessor.getPresetManager().getCurrentPreset().name;
    
    juce::String cpuStr = juce::String(cpu, 1) + "%";
    while (cpuStr.length() < 5) cpuStr = " " + cpuStr;
    
    lcdDisplay.setText("CPU: " + cpuStr, "PRESET: " + juce::String(preset));
    // Pass real sample rate
    lcdDisplay.setSampleRate(audioProcessor.getSampleRate());
    lcdDisplay.setLastNote(audioProcessor.getVoiceManager().getCurrentNote()); // Assuming we expose this in VM or similar
    
    // Transfer Audio Data for Oscilloscope
    auto& fifo = audioProcessor.getVisFifo();
    auto& buffer = audioProcessor.getVisBuffer();
    
    if (fifo.getNumReady() > 0)
    {
        int start1, size1, start2, size2;
        fifo.prepareToRead(buffer.getNumSamples(), start1, size1, start2, size2);
        
        // Construct temp buffer to push to display
        // Actually WaveformDisplay might want a vector or just samples?
        // It accepts AudioBuffer. Let's create a temp wrapper or just copy.
        // For simplicity, let's just push the block we read.
        
        if (size1 > 0)
        {
            // Just wrap the raw pointers in a temporary buffer to avoid copying if possible, 
            // BUT WaveformDisplay inputs const AudioBuffer&.
            // We can't easily wrap ring buffer parts.
            // Let's copy to a temp buffer.
            juce::AudioBuffer<float> temp(1, size1 + size2);
            
            // Part 1
            if (size1 > 0) {
                temp.copyFrom(0, 0, buffer.getReadPointer(0, start1), size1);
            }
            // Part 2
            if (size2 > 0) {
               temp.copyFrom(0, size1, buffer.getReadPointer(0, start2), size2);
            }
            
            waveformDisplay.pushBuffer(temp);
            fifo.finishedRead(size1 + size2);
        }
    }
    
    waveformDisplay.repaint();
    pitchEditor.updateData();
    dcwEditor.updateData();
    dcaEditor.updateData();
}

bool CZ101AudioProcessorEditor::isInterestedInFileDrag(const juce::StringArray& files)
{
    for (auto file : files)
        if (file.endsWithIgnoreCase(".syx"))
            return true;
    return false;
}

void CZ101AudioProcessorEditor::filesDropped(const juce::StringArray& files, int x, int y)
{
    juce::ignoreUnused(x, y);
    
    for (auto path : files) {
        if (path.endsWithIgnoreCase(".syx")) {
            juce::File file(path);
            juce::MemoryBlock sysexData;
            
            // Security check: Limit SysEx import size to 64KB
            if (file.getSize() > 65536)
            {
                juce::NativeMessageBox::showAsync(juce::MessageBoxOptions()
                    .withIconType(juce::MessageBoxIconType::WarningIcon)
                    .withTitle("File too large")
                    .withMessage("SysEx files must be under 64KB. This file will not be loaded.")
                    .withButton("OK"),
                    nullptr);
                continue;
            }

            if (file.loadFileAsData(sysexData)) {
                audioProcessor.getSysExManager().handleSysEx(sysexData.getData(), (int)sysexData.getSize(), file.getFileNameWithoutExtension());
                timerCallback();
            }
        }
    }
}

void CZ101AudioProcessorEditor::loadSysExFile()
{
    fileChooser = std::make_unique<juce::FileChooser>("Load SysEx Patch",
        juce::File::getSpecialLocation(juce::File::userHomeDirectory),
        "*.syx");

    auto flags = juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles;

    fileChooser->launchAsync(flags, [this](const juce::FileChooser& fc) {
        auto file = fc.getResult();
        if (file.existsAsFile()) 
        {
            // Security check: Limit SysEx import size to 64KB
            if (file.getSize() > 65536)
            {
                 juce::NativeMessageBox::showAsync(juce::MessageBoxOptions()
                    .withIconType(juce::MessageBoxIconType::WarningIcon)
                    .withTitle("File too large")
                    .withMessage("SysEx files must be under 64KB.")
                    .withButton("OK"),
                    nullptr);
                 return;
            }

            juce::MemoryBlock sysexData;
            if (file.loadFileAsData(sysexData)) 
            {
                // Ensure audioProcessor and SysExManager are accessible and handle the call
                audioProcessor.getSysExManager().handleSysEx(sysexData.getData(), (int)sysexData.getSize(), file.getFileNameWithoutExtension());
                timerCallback();
            }
        }
    });
}

void CZ101AudioProcessorEditor::saveSysExFile()
{
    // Patch 1: Deep Persistence (User Fix)
    // 1. Capture current state from UI to preset
    audioProcessor.getPresetManager().copyStateFromProcessor();
    
    // 2. Get current preset index
    int idx = presetBrowser.getSelectedItemIndex();
    if (idx < 0) idx = 0;
    
    auto currentName = audioProcessor.getPresetManager().getCurrentPreset().name;
    
    // 3. Save to memory slot
    audioProcessor.getPresetManager().savePreset(idx, currentName);
    
    // 4. CRITICAL: Persist to Disk
    juce::File presetsDir = juce::File::getSpecialLocation(juce::File::userDocumentsDirectory)
                            .getChildFile("CZ101Emulator");
    
    if (!presetsDir.exists()) {
        presetsDir.createDirectory();
    }
    
    juce::File bankFile = presetsDir.getChildFile("userbank.json");
    
    audioProcessor.getPresetManager().saveBank(bankFile);
    
    // Assume success if no exception/crash
    lcdDisplay.setPresetName("SAVED OK");
    // juce::Logger::writeToLog("Preset saved to: " + bankFile.getFullPathName());
    
    presetBrowser.updatePresetList();
}

================================================================================
FILE: .\Source\PluginEditor.h
================================================================================
#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include <juce_opengl/juce_opengl.h>
#include "PluginProcessor.h"
#include "UI/CZ101LookAndFeel.h"
#include "UI/Components/Knob.h"
#include "UI/Components/WaveformDisplay.h"
#include "UI/Components/PresetBrowser.h"
#include "UI/Components/MIDIActivityIndicator.h"
#include "UI/Components/EnvelopeEditor.h"
#include "UI/LCDDisplay.h"
#include "UI/Overlays/NameEditorOverlay.h"

/**
 * CZ-101 Emulator Editor - REDESIGNED
 * 
 * Nuevo layout 800x600 (responsive):
 * - Header compacto (45px)
 * - Left Panel: Osciladores, Filter, LFO
 * - Right Panel: Envelopes (tabs), Effects (2x3 grid)
 * - Bottom: Keyboard MIDI
 * 
 * Optimizado para Raspberry Pi y pantallas pequeÃ±as
 */
class CZ101AudioProcessorEditor : public juce::AudioProcessorEditor,
                                   private juce::MidiKeyboardState::Listener,
                                   private juce::Timer,
                                   public juce::FileDragAndDropTarget
{
public:
    CZ101AudioProcessorEditor(CZ101AudioProcessor&);
    ~CZ101AudioProcessorEditor() override;

    void paint(juce::Graphics&) override;
    void resized() override;
    
    juce::MidiKeyboardState& getKeyboardState() { return keyboardState; }
    void refreshMidiOutputs();
    void timerCallback() override;

    bool isInterestedInFileDrag(const juce::StringArray& files) override;
    void filesDropped(const juce::StringArray& files, int x, int y) override;

private:
    void handleNoteOn(juce::MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity) override;
    void handleNoteOff(juce::MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity) override;
    
    CZ101AudioProcessor& audioProcessor;
    CZ101::UI::CZ101LookAndFeel customLookAndFeel;
    juce::OpenGLContext openGLContext;
    
    // MIDI Infrastructure
    juce::MidiKeyboardState keyboardState;
    juce::MidiKeyboardComponent keyboardComponent;
    juce::ComboBox midiOutputSelector;
    std::unique_ptr<juce::MidiOutput> activeMidiOutput;
    
    // Header Components
    CZ101::UI::LCDDisplay lcdDisplay;
    CZ101::UI::PresetBrowser presetBrowser;
    CZ101::UI::MIDIActivityIndicator midiIndicator;
    juce::TextButton loadSysExButton { "LOAD SYX" };
    juce::TextButton saveSysExButton { "SAVE" };
    std::unique_ptr<juce::FileChooser> fileChooser;
    void loadSysExFile();
    void saveSysExFile();
    
    // --- LEFT PANEL: OSCILLATORS + FILTER + LFO ---
    
    // Oscillators
    juce::ComboBox osc1WaveSelector;
    CZ101::UI::Knob osc1LevelKnob;
    juce::ComboBox osc2WaveSelector;
    CZ101::UI::Knob osc2LevelKnob;
    CZ101::UI::Knob osc2DetuneKnob;
    juce::ToggleButton hardSyncButton;
    juce::ToggleButton ringModButton;
    CZ101::UI::Knob glideKnob;
    CZ101::UI::WaveformDisplay waveformDisplay;
    
    // Filter
    CZ101::UI::Knob filterCutoffKnob;
    CZ101::UI::Knob filterResonanceKnob;
    
    // LFO
    CZ101::UI::Knob lfoRateKnob;
    
    // --- RIGHT PANEL: ENVELOPES (TABS) + EFFECTS GRID ---
    
    // Envelope Tabs
    juce::TabbedComponent envelopeTabs { juce::TabbedButtonBar::TabsAtTop };
    
    // Envelopes
    CZ101::UI::EnvelopeEditor pitchEditor;
    CZ101::UI::EnvelopeEditor dcwEditor;
    CZ101::UI::EnvelopeEditor dcaEditor;
    
    // Envelope ADSR Knobs (DCW)
    CZ101::UI::Knob dcwAttackKnob;
    CZ101::UI::Knob dcwDecayKnob;
    CZ101::UI::Knob dcwSustainKnob;
    CZ101::UI::Knob dcwReleaseKnob;
    
    // Envelope ADSR Knobs (DCA)
    CZ101::UI::Knob dcaAttackKnob;
    CZ101::UI::Knob dcaDecayKnob;
    CZ101::UI::Knob dcaSustainKnob;
    CZ101::UI::Knob dcaReleaseKnob;
    
    // Effects Grid (2x3)
    CZ101::UI::Knob delayTimeKnob;
    CZ101::UI::Knob delayFeedbackKnob;
    CZ101::UI::Knob delayMixKnob;
    CZ101::UI::Knob chorusRateKnob;
    CZ101::UI::Knob chorusDepthKnob;
    CZ101::UI::Knob chorusMixKnob;
    CZ101::UI::Knob reverbSizeKnob;
    CZ101::UI::Knob reverbMixKnob;
    
    // Effect Labels (no GroupComponents, solo etiquetas)
    juce::Label delayLabel;
    juce::Label chorusLabel;
    juce::Label reverbLabel;
    
    // --- ATTACHMENTS ---
    using SliderAttachment = juce::SliderParameterAttachment;
    using ComboBoxAttachment = juce::ComboBoxParameterAttachment;
    using ButtonAttachment = juce::ButtonParameterAttachment;
    
    std::vector<std::unique_ptr<SliderAttachment>> sliderAttachments;
    std::vector<std::unique_ptr<ComboBoxAttachment>> comboBoxAttachments;
    std::unique_ptr<ButtonAttachment> hardSyncAttachment;
    std::unique_ptr<ButtonAttachment> ringModAttachment;
    
    // Overlays
    CZ101::UI::NameEditorOverlay nameOverlay;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(CZ101AudioProcessorEditor)
};

================================================================================
FILE: .\Source\PluginProcessor.cpp
================================================================================
#include "PluginProcessor.h"
#include "PluginEditor.h"

CZ101AudioProcessor::CZ101AudioProcessor()
    : AudioProcessor(BusesProperties()
                     .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      voiceManager(),
      parameters(*this),
      presetManager(&parameters, &voiceManager),
      midiProcessor(voiceManager, presetManager),
      sysExManager()
{
    parameters.createParameters();
    
    // Bind SysEx Callback
    sysExManager.onPresetParsed = [this](const CZ101::State::Preset& p) {
        applyPresetToVoiceEngine(p);
    };
    
    midiProcessor.setSysExManager(&sysExManager);
    
    // Load default preset once parameters are ready
    if (!presetManager.getPresets().empty())
        presetManager.loadPreset(0);
}

void CZ101AudioProcessor::applyPresetToVoiceEngine(const CZ101::State::Preset& preset)
{
    // Apply Pitch Envelope
    for (int i = 0; i < 8; i++) {
        voiceManager.setPitchStage(i, preset.pitchEnv.rates[i], 
                                  preset.pitchEnv.levels[i]);
    }
    voiceManager.setPitchSustainPoint(preset.pitchEnv.sustainPoint);
    voiceManager.setPitchEndPoint(preset.pitchEnv.endPoint);
    
    // Apply DCW Envelope
    for (int i = 0; i < 8; i++) {
        voiceManager.setDCWStage(i, preset.dcwEnv.rates[i], 
                                preset.dcwEnv.levels[i]);
    }
    voiceManager.setDCWSustainPoint(preset.dcwEnv.sustainPoint);
    voiceManager.setDCWEndPoint(preset.dcwEnv.endPoint);
    
    // Apply DCA Envelope
    for (int i = 0; i < 8; i++) {
        voiceManager.setDCAStage(i, preset.dcaEnv.rates[i], 
                                preset.dcaEnv.levels[i]);
    }
    voiceManager.setDCASustainPoint(preset.dcaEnv.sustainPoint);
    voiceManager.setDCAEndPoint(preset.dcaEnv.endPoint);
}

CZ101AudioProcessor::~CZ101AudioProcessor()
{
}

// ... (Top of file usually)

void CZ101AudioProcessor::saveCurrentPreset(const juce::String& name)
{
    // 1. Capture current state from params/voices into CurrentPreset
    presetManager.copyStateFromProcessor();
    
    // 2. Save it to the current slot (in memory)
    // Note: To persist to disk, we rely on getStateInformation/setStateInformation or a dedicated file save.
    // For now, this updates the runtime preset so switching presets doesn't lose edits, if we stay in session.
    // Wait, switching AWAY saves? No, usually "Save" button confirms the save.
    // Switching away usually reloads the destination preset.
    
    int idx = getCurrentProgram();
    presetManager.savePreset(idx, name.toStdString());
    
    // Also update host notification?
    updateHostDisplay();
}

const juce::String CZ101AudioProcessor::getName() const
{
    return JucePlugin_Name;
}

bool CZ101AudioProcessor::acceptsMidi() const
{
    return true;
}

bool CZ101AudioProcessor::producesMidi() const
{
    return false;
}

bool CZ101AudioProcessor::isMidiEffect() const
{
    return false;
}

double CZ101AudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int CZ101AudioProcessor::getNumPrograms()
{
    return 1;
}

int CZ101AudioProcessor::getCurrentProgram()
{
    return 0;
}

void CZ101AudioProcessor::setCurrentProgram(int index)
{
    juce::ignoreUnused(index);
}

const juce::String CZ101AudioProcessor::getProgramName(int index)
{
    juce::ignoreUnused(index);
    return {};
}

void CZ101AudioProcessor::changeProgramName(int index, const juce::String& newName)
{
    juce::ignoreUnused(index, newName);
}

void CZ101AudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    voiceManager.setSampleRate(sampleRate);
    filterL.setSampleRate(sampleRate);
    filterR.setSampleRate(sampleRate);
    delayL.setSampleRate(sampleRate);
    delayR.setSampleRate(sampleRate);
    reverb.setSampleRate(sampleRate);
    chorus.prepare(sampleRate);
    lfo.setSampleRate(sampleRate);
    lfo.setFrequency(1.0f);
    
    // Patch 1: Deep Persistence (User Fix)
    juce::File presetsDir = juce::File::getSpecialLocation(juce::File::userDocumentsDirectory)
                            .getChildFile("CZ101Emulator");
    
    if (!presetsDir.exists()) {
        presetsDir.createDirectory();
        // Simple logging if we had a logger, or just proceed
    }
    
    juce::File bankFile = presetsDir.getChildFile("userbank.json");
    
    if (bankFile.existsAsFile()) {
        presetManager.loadBank(bankFile);
        if (presetManager.getPresets().empty()) {
            presetManager.createFactoryPresets();
            presetManager.saveBank(bankFile);
        }
        presetManager.loadPreset(0);
    } else {
        presetManager.createFactoryPresets();
        presetManager.saveBank(bankFile);
        presetManager.loadPreset(0);
    } // Default rate
}

void CZ101AudioProcessor::releaseResources()
{
}

bool CZ101AudioProcessor::isBusesLayoutSupported(const BusesLayout& layouts) const
{
    if (layouts.getMainOutputChannelSet() != juce::AudioChannelSet::stereo())
        return false;
    return true;
}

void CZ101AudioProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    juce::ScopedNoDenormals noDenormals;
    
    performanceMonitor.startMeasurement();
    
    auto totalNumInputChannels = getTotalNumInputChannels();
    auto totalNumOutputChannels = getTotalNumOutputChannels();
    
    for (auto i = totalNumInputChannels; i < totalNumOutputChannels; ++i)
        buffer.clear(i, 0, buffer.getNumSamples());
    
    updateParameters();
    
    midiProcessor.processMidiBuffer(midiMessages);
    
    auto* channelDataL = buffer.getWritePointer(0);
    auto* channelDataR = buffer.getWritePointer(1);
    
    // float lfoVal = lfo.getNextValue(); // Removed block-level update
    // voiceManager.updateLFO(lfoVal);
    
    // Pass LFO to renderNextBlock for sample-accurate modulation
    voiceManager.renderNextBlock(channelDataL, channelDataR, buffer.getNumSamples(), &lfo);
    
    for (int i = 0; i < buffer.getNumSamples(); ++i)
    {
        channelDataL[i] = filterL.processSample(channelDataL[i]);
        channelDataR[i] = filterR.processSample(channelDataR[i]);
        
        channelDataL[i] = delayL.processSample(channelDataL[i]);
        channelDataR[i] = delayR.processSample(channelDataR[i]);
    }
    
    // Process Reverb (Block-based)
    // Process Reverb (Block-based)
    float* left = buffer.getWritePointer(0);
    float* right = buffer.getWritePointer(1);
    
    // Process Chorus (Block-based)
    chorus.process(left, right, buffer.getNumSamples());
    
    // Re-get pointers (Chorus might have modified buffer/ptrs if it were internal buffer swap, though getWritePointer is persistent for block)
    // However, good practice if using distinct buffers. Here we use the same buffer. 
    // The user explicitly requested: "Fix: Obtener punteros despuÃ©s de chorus.process()" because "reverb.processStereo() requiere punteros".
    // Actually getWritePointer is valid for the whole block. But let's follow the instruction.
    left = buffer.getWritePointer(0);
    right = buffer.getWritePointer(1);
    
    reverb.processStereo(left, right, buffer.getNumSamples());
    
    // --- VISUALIZATION COPY ---
    // Push mono mix to circular buffer for the UI
    if (visFifo.getFreeSpace() >= buffer.getNumSamples())
    {
         int start1, size1, start2, size2;
         visFifo.prepareToWrite(buffer.getNumSamples(), start1, size1, start2, size2);
         
         // Helper to copy and mix down (Mono for display simpler for now)
         auto* l = buffer.getReadPointer(0);
         auto* r = buffer.getReadPointer(1);
         
         for (int i=0; i<size1; ++i) 
             visBuffer.setSample(0, start1 + i, (l[i] + r[i]) * 0.5f);
             
         for (int i=0; i<size2; ++i) 
             visBuffer.setSample(0, start2 + i, (l[size1 + i] + r[size1 + i]) * 0.5f);
             
         visFifo.finishedWrite(size1 + size2);
    }
    
    performanceMonitor.stopMeasurement();
}

void CZ101AudioProcessor::updateParameters()
{
    // --- VOICES (Oscillators & Envelopes) ---
    // Direct update without checks (Assumes parameters are created safely in ctor)
    voiceManager.setOsc1Level(parameters.osc1Level->get());
    voiceManager.setOsc1Waveform(parameters.osc1Waveform->getIndex());

    voiceManager.setOsc2Level(parameters.osc2Level->get());
    voiceManager.setOsc2Waveform(parameters.osc2Waveform->getIndex());
    voiceManager.setOsc2Detune(parameters.osc2Detune->get());
    
    // Hard Sync
    if (parameters.hardSync)
        voiceManager.setHardSync(parameters.hardSync->get());
    
    if (parameters.ringMod)
        voiceManager.setRingMod(parameters.ringMod->get());

    if (parameters.glideTime)
        voiceManager.setGlideTime(parameters.glideTime->get());

    // DCW
    voiceManager.setDCWAttack(parameters.dcwAttack->get());
    voiceManager.setDCWDecay(parameters.dcwDecay->get());
    voiceManager.setDCWSustain(parameters.dcwSustain->get());
    voiceManager.setDCWRelease(parameters.dcwRelease->get());

    // DCA
    voiceManager.setDCAAttack(parameters.dcaAttack->get());
    voiceManager.setDCADecay(parameters.dcaDecay->get());
    voiceManager.setDCASustain(parameters.dcaSustain->get());
    voiceManager.setDCARelease(parameters.dcaRelease->get());

    // --- EFFECTS ---
    if (parameters.filterCutoff)
    {
        float cutoff = parameters.filterCutoff->get();
        filterL.setCutoff(cutoff);
        filterR.setCutoff(cutoff);
    }
    
    if (parameters.filterResonance)
    {
        float res = parameters.filterResonance->get();
        filterL.setResonance(res);
        filterR.setResonance(res);
    }
    
    if (parameters.delayTime)
    {
        delayL.setDelayTime(parameters.delayTime->get());
        delayR.setDelayTime(parameters.delayTime->get());
    }
    
    if (parameters.delayFeedback)
    {
        delayL.setFeedback(parameters.delayFeedback->get());
        delayR.setFeedback(parameters.delayFeedback->get());
    }
    
    if (parameters.delayMix)
    {
        delayL.setMix(parameters.delayMix->get());
        delayR.setMix(parameters.delayMix->get());
    }
    
    // Chorus Parameters
    // This part of the original request was for `updateParameters`
    // The audio processing part of the request was moved to `processBlock`
    // as it's an audio processing function.
    if (parameters.chorusRate)
        chorus.setRate(parameters.chorusRate->get());
    if (parameters.chorusDepth)
        chorus.setDepth(parameters.chorusDepth->get());
    if (parameters.chorusMix)
        chorus.setMix(parameters.chorusMix->get());
    
    if (parameters.reverbSize && parameters.reverbMix)
    {
        // Reverb Params: room, damping, wet, dry, width
        float size = parameters.reverbSize->get();
        float mix = parameters.reverbMix->get();
        
        // Map Mix to Wet/Dry (simple)
        // Dry = 1.0, Wet=Mix? Or Dry=1-Mix?
        // Let's keep dry 1.0 (typical send style or parallel) or balanced.
        // For effect box: Dry reduces as Wet increases? 
        // juce::Reverb typical: WetLevel 0..1, DryLevel 0..1
        // Let's do: Dry = 1.0, Wet = Mix * 0.8
        
        // juce::Reverb::Parameters struct setter
        reverbParams.roomSize = size;
        reverbParams.damping = 0.5f;
        reverbParams.wetLevel = mix;
        reverbParams.dryLevel = 1.0f - (mix * 0.5f);
        reverbParams.width = 1.0f;
        reverbParams.freezeMode = 0.0f;
        
        reverb.setParameters(reverbParams);
    }
    
    // LFO / Vibrato
    if (parameters.lfoRate)
    {
        lfo.setFrequency(parameters.lfoRate->get());
    }
    
    if (parameters.lfoWaveform)
    {
        // Cast int/index to Waveform enum
        lfo.setWaveform(static_cast<CZ101::DSP::LFO::Waveform>(parameters.lfoWaveform->getIndex()));
    }
    
    if (parameters.lfoDepth)
    {
        // Map 0.0-1.0 to semitones (e.g. 0 to 2 semitones depth)
        float depth = parameters.lfoDepth->get() * 2.0f; 
        voiceManager.setVibratoDepth(depth);
    }
}

bool CZ101AudioProcessor::hasEditor() const
{
    return true;
}

juce::AudioProcessorEditor* CZ101AudioProcessor::createEditor()
{
    return new CZ101AudioProcessorEditor(*this);
}

void CZ101AudioProcessor::getStateInformation(juce::MemoryBlock& destData)
{
    juce::ignoreUnused(destData);
}

void CZ101AudioProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    juce::ignoreUnused(data, sizeInBytes);
}

juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new CZ101AudioProcessor();
}

================================================================================
FILE: .\Source\PluginProcessor.h
================================================================================
#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include "Utils/PerformanceMonitor.h"
#include "Core/VoiceManager.h"
#include "MIDI/MIDIProcessor.h"
#include "MIDI/SysExManager.h"
#include "State/Parameters.h"
#include "State/PresetManager.h"
#include "DSP/Filters/ResonantFilter.h"
#include "DSP/Effects/Delay.h"
#include "DSP/Effects/Chorus.h"
#include "DSP/Effects/Reverb.h"
#include "DSP/Modulation/LFO.h"

class CZ101AudioProcessor : public juce::AudioProcessor
{
public:
    CZ101AudioProcessor();
    ~CZ101AudioProcessor() override;

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;

    bool isBusesLayoutSupported(const BusesLayout& layouts) const override;

    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override;

    const juce::String getName() const override;

    bool acceptsMidi() const override;
    bool producesMidi() const override;
    bool isMidiEffect() const override;
    double getTailLengthSeconds() const override;
    int getNumPrograms() override;
    int getCurrentProgram() override;
    void setCurrentProgram(int index) override;
    const juce::String getProgramName(int index) override;
    void changeProgramName(int index, const juce::String& newName) override;
    
    void saveCurrentPreset(const juce::String& name); // New Save Method
    void applyPresetToVoiceEngine(const CZ101::State::Preset& preset); // SysEx Helper

    void getStateInformation(juce::MemoryBlock& destData) override;
    void setStateInformation(const void* data, int sizeInBytes) override;
    
    CZ101::State::PresetManager& getPresetManager() { return presetManager; }
    CZ101::MIDI::SysExManager& getSysExManager() { return sysExManager; }
    CZ101::MIDI::MIDIProcessor& getMidiProcessor() { return midiProcessor; }
    CZ101::State::Parameters& getParameters() { return parameters; }
    CZ101::Core::VoiceManager& getVoiceManager() { return voiceManager; }
    CZ101::Utils::PerformanceMonitor& getPerformanceMonitor() { return performanceMonitor; }
    
    // For Editor Visualization
    // juce::AudioVisualiserComponent& getVisualiser() { return visualiser; } 
    
    // For Editor Visualization
    // juce::AudioVisualiserComponent& getVisualiser() { return visualiser; } 
    
    juce::AudioBuffer<float>& getVisBuffer() { return visBuffer; }
    juce::AbstractFifo& getVisFifo() { return visFifo; }

private:
    // ...
    // Visualisation
    juce::AudioBuffer<float> visBuffer { 1, 1024 }; // Mono, 1024 samples ring buffer
    juce::AbstractFifo visFifo { 1024 };
    CZ101::Core::VoiceManager voiceManager;
    CZ101::MIDI::MIDIProcessor midiProcessor;
    CZ101::State::Parameters parameters;
    CZ101::State::PresetManager presetManager;
    CZ101::MIDI::SysExManager sysExManager{presetManager};
    
    CZ101::DSP::ResonantFilter filterL;
    CZ101::DSP::ResonantFilter filterR;
    CZ101::DSP::Effects::Delay delayL;
    CZ101::DSP::Effects::Delay delayR;
    
    juce::Reverb reverb;
    juce::Reverb::Parameters reverbParams;
    CZ101::DSP::Effects::Chorus chorus;
    
    // UI Update Tracking
    CZ101::DSP::LFO lfo;
    CZ101::Utils::PerformanceMonitor performanceMonitor;
    
    void updateParameters();

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(CZ101AudioProcessor)
};

================================================================================
FILE: .\Source\Core\Voice.cpp
================================================================================
#include <JuceHeader.h>
#include "Voice.h"
#include <cmath>
#include "../DSP/Envelopes/ADSRtoStage.h"

namespace CZ101 {
namespace Core {

Voice::Voice()
{
}

void Voice::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
    osc1.setSampleRate(sr);
    osc2.setSampleRate(sr);
    dcwEnvelope.setSampleRate(sr);
    dcaEnvelope.setSampleRate(sr);
    pitchEnvelope.setSampleRate(sr);

    // Re-calculate envelopes with new sample rate
    updateDCWEnvelopeFromADSR();
    updateDCAEnvelopeFromADSR();
    updatePitchEnvelopeFromADSR();
}

void Voice::noteOn(int midiNote, float velocity) noexcept
{
    // Frequency
    currentNote = midiNote;
    currentVelocity = velocity;
    
    // Convert note
    baseFrequency = midiNoteToFrequency(midiNote);
    targetFrequency = baseFrequency;
    currentFrequency = baseFrequency; // Start at note (glide handles transition)
    
    // Reset phase if hard sync or just standard gate behavior
    // CZ-101 resets on note on usually
    osc1.reset();
    osc2.reset();
    
    // Envelopes
    dcwEnvelope.noteOn();
    dcaEnvelope.noteOn();
    pitchEnvelope.noteOn();
}

void Voice::noteOff() noexcept
{
    dcwEnvelope.noteOff();
    dcaEnvelope.noteOff();
    pitchEnvelope.noteOff();
}

void Voice::reset() noexcept
{
    dcwEnvelope.reset();
    dcaEnvelope.reset();
    pitchEnvelope.reset();
}

// ... Oscillators ...

void Voice::setOsc1Waveform(DSP::PhaseDistOscillator::Waveform w) noexcept { osc1.setWaveform(w); }
void Voice::setOsc1Level(float level) noexcept { osc1Level = level; }

void Voice::setOsc2Waveform(DSP::PhaseDistOscillator::Waveform w) noexcept { osc2.setWaveform(w); }
void Voice::setOsc2Level(float level) noexcept { osc2Level = level; }
void Voice::setOsc2Detune(float cents) noexcept 
{ 
    osc2Detune = cents; 
    currentDetuneFactor =std::pow(2.0f, cents / 1200.0f);
}

void Voice::setHardSync(bool enabled) noexcept { isHardSyncEnabled = enabled; }
void Voice::setRingMod(bool enabled) noexcept { isRingModEnabled = enabled; }
void Voice::setGlideTime(float seconds) noexcept { glideTime = seconds; }

// ... DCW Envelope ...
void Voice::setVibratoDepth(float semitones) noexcept { vibratoDepth = semitones; }
void Voice::setLFOValue(float val) noexcept { lfoValue = val; }
void Voice::setPitchBend(float semitones) noexcept { pitchBendFactor = std::pow(2.0f, semitones / 12.0f); }
void Voice::setMasterTune(float semitones) noexcept { masterTuneFactor = std::pow(2.0f, semitones / 12.0f); }

// ============================================================================
// DCW ENVELOPE - IMPLEMENTACIÃ“N MEJORADA
// ============================================================================

void Voice::setDCWAttack(float seconds) noexcept
{
    double ms = static_cast<double>(seconds) * 1000.0;
    dcwADSR.attackMs = static_cast<float>(std::clamp(ms, 0.5, 8000.0));
    updateDCWEnvelopeFromADSR();
}

void Voice::setDCWDecay(float seconds) noexcept
{
    double ms = static_cast<double>(seconds) * 1000.0;
    dcwADSR.decayMs = static_cast<float>(std::clamp(ms, 0.5, 8000.0));
    updateDCWEnvelopeFromADSR();
}

void Voice::setDCWSustain(float level) noexcept
{
    dcwADSR.sustainLevel = std::clamp(level, 0.0f, 1.0f);
    updateDCWEnvelopeFromADSR();
}

void Voice::setDCWRelease(float seconds) noexcept
{
    double ms = static_cast<double>(seconds) * 1000.0;
    dcwADSR.releaseMs = static_cast<float>(std::clamp(ms, 0.5, 8000.0));
    updateDCWEnvelopeFromADSR();
}

void Voice::setDCWStage(int i, float r, float l) noexcept { dcwEnvelope.setStage(i, r, l); }
void Voice::setDCWSustainPoint(int i) noexcept { dcwEnvelope.setSustainPoint(i); }
void Voice::setDCWEndPoint(int i) noexcept { dcwEnvelope.setEndPoint(i); }

void Voice::getDCWStage(int i, float& r, float& l) const noexcept { r = dcwEnvelope.getStageRate(i); l = dcwEnvelope.getStageLevel(i); }
int Voice::getDCWSustainPoint() const noexcept { return dcwEnvelope.getSustainPoint(); }
int Voice::getDCWEndPoint() const noexcept { return dcwEnvelope.getEndPoint(); }

// ============================================================================
// DCA ENVELOPE - IMPLEMENTACIÃ“N MEJORADA
// ============================================================================

void Voice::setDCAAttack(float seconds) noexcept
{
    double ms = static_cast<double>(seconds) * 1000.0;
    dcaADSR.attackMs = static_cast<float>(std::clamp(ms, 0.5, 8000.0));
    updateDCAEnvelopeFromADSR();
}

void Voice::setDCADecay(float seconds) noexcept
{
    double ms = static_cast<double>(seconds) * 1000.0;
    dcaADSR.decayMs = static_cast<float>(std::clamp(ms, 0.5, 8000.0));
    updateDCAEnvelopeFromADSR();
}

void Voice::setDCASustain(float level) noexcept
{
    dcaADSR.sustainLevel = std::clamp(level, 0.0f, 1.0f);
    updateDCAEnvelopeFromADSR();
}

void Voice::setDCARelease(float seconds) noexcept
{
    double ms = static_cast<double>(seconds) * 1000.0;
    dcaADSR.releaseMs = static_cast<float>(std::clamp(ms, 0.5, 8000.0));
    updateDCAEnvelopeFromADSR();
}

void Voice::setDCAStage(int i, float r, float l) noexcept { dcaEnvelope.setStage(i, r, l); }
void Voice::setDCASustainPoint(int i) noexcept { dcaEnvelope.setSustainPoint(i); }
void Voice::setDCAEndPoint(int i) noexcept { dcaEnvelope.setEndPoint(i); }

void Voice::getDCAStage(int i, float& r, float& l) const noexcept { r = dcaEnvelope.getStageRate(i); l = dcaEnvelope.getStageLevel(i); }
int Voice::getDCASustainPoint() const noexcept { return dcaEnvelope.getSustainPoint(); }
int Voice::getDCAEndPoint() const noexcept { return dcaEnvelope.getEndPoint(); }

// ... Pitch Envelope ...

void Voice::setPitchStage(int i, float r, float l) noexcept { pitchEnvelope.setStage(i, r, l); }
void Voice::setPitchSustainPoint(int i) noexcept { pitchEnvelope.setSustainPoint(i); }
void Voice::setPitchEndPoint(int i) noexcept { pitchEnvelope.setEndPoint(i); }

void Voice::getPitchStage(int i, float& r, float& l) const noexcept { r = pitchEnvelope.getStageRate(i); l = pitchEnvelope.getStageLevel(i); }
int Voice::getPitchSustainPoint() const noexcept { return pitchEnvelope.getSustainPoint(); }
int Voice::getPitchEndPoint() const noexcept { return pitchEnvelope.getEndPoint(); }

// ===== HELPER METHODS FOR ADSR CONSISTENCY =====

void Voice::updateDCWEnvelopeFromADSR() noexcept
{
    std::array<float, 8> rates, levels;
    int sus, end;
    
    DSP::ADSRtoStageConverter::convertADSR(
        dcwADSR.attackMs,
        dcwADSR.decayMs,
        dcwADSR.sustainLevel,
        dcwADSR.releaseMs,
        rates, levels, sus, end,
        sampleRate
    );
    
    // Aplicar todos los stages a la vez
    for (int i = 0; i < 4; ++i) {
        dcwEnvelope.setStage(i, rates[i], levels[i]);
    }
    dcwEnvelope.setSustainPoint(sus);
    dcwEnvelope.setEndPoint(end);
}

void Voice::updateDCAEnvelopeFromADSR() noexcept
{
    std::array<float, 8> rates, levels;
    int sus, end;
    
    DSP::ADSRtoStageConverter::convertADSR(
        dcaADSR.attackMs,
        dcaADSR.decayMs,
        dcaADSR.sustainLevel,
        dcaADSR.releaseMs,
        rates, levels, sus, end,
        sampleRate
    );
    
    for (int i = 0; i < 4; ++i) {
        dcaEnvelope.setStage(i, rates[i], levels[i]);
    }
    dcaEnvelope.setSustainPoint(sus);
    dcaEnvelope.setEndPoint(end);
}

void Voice::updatePitchEnvelopeFromADSR() noexcept
{
    std::array<float, 8> rates, levels;
    int sus, end;
    
    DSP::ADSRtoStageConverter::convertADSR(
        pitchADSR.attackMs,
        pitchADSR.decayMs,
        pitchADSR.sustainLevel,
        pitchADSR.releaseMs,
        rates, levels, sus, end,
        sampleRate
    );
    
    for (int i = 0; i < 4; ++i) {
        pitchEnvelope.setStage(i, rates[i], levels[i]);
    }
    pitchEnvelope.setSustainPoint(sus);
    pitchEnvelope.setEndPoint(end);
}

float Voice::renderNextSample() noexcept
{
    if (!dcaEnvelope.isActive()) return 0.0f;
    
    // === ENVELOPE VALUES ===
    float dcwValue = dcwEnvelope.getNextValue();         // Timbre (0-1)
    float dcaValue = dcaEnvelope.getNextValue();         // Amplitud (0-1)
    float pitchEnvVal = pitchEnvelope.getNextValue();    // Pitch mod (0-1)
    
    // === PITCH MODULATION ===
    // Pitch envelope: 0.0 = -1 octava, 0.5 = unison, 1.0 = +1 octava
    float semitones = (pitchEnvVal - 0.5f) * 100.0f;     // Â±50 semitones
    float pitchMod = std::pow(2.0f, semitones / 12.0f);
    
    // === GLIDE (PORTAMENTO) ===
    if (glideTime > 0.001f && currentFrequency != targetFrequency) {
        float alpha = 1.0f / (float)(sampleRate * (glideTime + 0.001f));
        float diff = targetFrequency - currentFrequency;
        currentFrequency += diff * alpha * 4.0f;
        
        if (std::abs(diff) < 0.1f) currentFrequency = targetFrequency;
    } else {
        currentFrequency = targetFrequency;
    }
    
    // === LFO VIBRATO ===
    float vibratoMod = 1.0f;
    if (vibratoDepth > 0.001f) {
        float lfoSemitones = lfoValue * vibratoDepth;
        vibratoMod = std::pow(2.0f, lfoSemitones / 12.0f);
    }
    
    // === FINAL FREQUENCY ===
    // Combina: Pitch Env + Vibrato + Pitch Bend + Master Tune
    float finalFreq = currentFrequency * pitchMod * vibratoMod 
                    * pitchBendFactor * masterTuneFactor;
    
    osc1.setFrequency(finalFreq);
    osc2.setFrequency(finalFreq * currentDetuneFactor);
    
    // === OSCILLATOR RENDERING ===
    bool osc1Wrapped = false;
    float osc1Sample = osc1.renderNextSample(dcwValue, &osc1Wrapped);
    
    // Hard Sync: reset osc2 cuando osc1 wraps
    if (isHardSyncEnabled && osc1Wrapped) {
        osc2.reset();
    }
    
    float osc2Sample = osc2.renderNextSample(dcwValue);
    
    // Ring Modulation: osc2_out = osc1 * osc2
    if (isRingModEnabled) {
        osc2Sample = osc1Sample * osc2Sample;
    }
    
    // === OSCILLATOR MIX WITH NORMALIZATION âœ… ===
    // Importante: Evitar overshooting si osc1Level + osc2Level > 1.0
    float totalLevel = osc1Level + osc2Level;
    float normalizer = (totalLevel > 1.0f) ? (1.0f / totalLevel) : 1.0f;
    
    float mix = (osc1Sample * osc1Level + osc2Sample * osc2Level) * normalizer;
    
    // === FINAL OUTPUT WITH SAFETY ===
    // 0.9f headroom para prevenir clipping de efectos posteriores
    float output = mix * dcaValue * currentVelocity * 0.9f;
    
    // Clamp final para ultra-seguridad
    return std::clamp(output, -1.0f, 1.0f);
}

float Voice::midiNoteToFrequency(int midiNote) const noexcept
{
    return 440.0f * std::pow(2.0f, (midiNote - 69) / 12.0f);
}

} // namespace Core
} // namespace CZ101

================================================================================
FILE: .\Source\Core\Voice.h
================================================================================
#pragma once

#include "../DSP/Oscillators/PhaseDistOsc.h"
#include "../DSP/Envelopes/MultiStageEnv.h"
#include <array>

namespace CZ101 {
namespace Core {

/**
 * @brief Voice - Complete synthesizer voice
 * 
 * Integrates oscillators and envelopes to create the CZ-101 sound.
 * Architecture: DCO (oscillators) â†’ DCW (timbre envelope) â†’ DCA (amplitude envelope)
 */
class Voice
{
public:
    Voice();
    
    void setSampleRate(double sampleRate) noexcept;
    
    // Note control
    void noteOn(int midiNote, float velocity) noexcept;
    void noteOff() noexcept;
    void reset() noexcept;
    
    // Oscillator 1 parameters
    void setOsc1Waveform(DSP::PhaseDistOscillator::Waveform waveform) noexcept;
    void setOsc1Level(float level) noexcept;
    
    // Oscillator 2 parameters
    void setOsc2Waveform(DSP::PhaseDistOscillator::Waveform waveform) noexcept;
    void setOsc2Level(float level) noexcept;
    void setOsc2Detune(float cents) noexcept;  // -100 to +100 cents
    
    /**
     * @brief Enable/Disable Hard Sync (Osc2 resets when Osc1 wraps)
     */
    void setHardSync(bool enabled) noexcept;

    /**
     * @brief Enable/Disable Ring Modulation (Osc2 output = Osc1 * Osc2)
     */
    /**
     * @brief Enable/Disable Ring Modulation (Osc2 output = Osc1 * Osc2)
     */
    void setRingMod(bool enabled) noexcept;

    /**
     * @brief Set Glide (Portamento) Time in seconds
     * @param seconds Slide time (0.0 to ~2.0)
     */
    /**
     * @brief Set Glide (Portamento) Time in seconds
     * @param seconds Slide time (0.0 to ~2.0)
     */
    void setGlideTime(float seconds) noexcept;

    // --- Modulation (LFO) ---
    void setVibratoDepth(float semitones) noexcept;
    void setLFOValue(float value) noexcept; // -1.0 to 1.0
    
    // --- Global Pitch ---
    void setPitchBend(float semitones) noexcept;
    void setMasterTune(float semitones) noexcept;

    // --- Pitch Envelope Controls ---
    
    // DCW Envelope (Legacy ADSR Wrappers)
    void setDCWAttack(float seconds) noexcept;
    void setDCWDecay(float seconds) noexcept;
    void setDCWSustain(float level) noexcept;
    void setDCWRelease(float seconds) noexcept;
    
    // DCW 8-Stage Control
    void setDCWStage(int index, float rate, float level) noexcept;
    void setDCWSustainPoint(int index) noexcept;
    void setDCWEndPoint(int index) noexcept;
    
    void getDCWStage(int index, float& rate, float& level) const noexcept;
    int getDCWSustainPoint() const noexcept;
    int getDCWEndPoint() const noexcept;
    
    // DCA Envelope (Legacy ADSR Wrappers)
    void setDCAAttack(float seconds) noexcept;
    void setDCADecay(float seconds) noexcept;
    void setDCASustain(float level) noexcept;
    void setDCARelease(float seconds) noexcept;

    // DCA 8-Stage Control
    void setDCAStage(int index, float rate, float level) noexcept;
    void setDCASustainPoint(int index) noexcept;
    void setDCAEndPoint(int index) noexcept;

    void getDCAStage(int index, float& rate, float& level) const noexcept;
    int getDCASustainPoint() const noexcept;
    int getDCAEndPoint() const noexcept;

    // Pitch Envelope (DCO) 8-Stage Control
    void setPitchStage(int index, float rate, float level) noexcept;
    void setPitchSustainPoint(int index) noexcept;
    void setPitchEndPoint(int index) noexcept;
    
    void getPitchStage(int index, float& rate, float& level) const noexcept;
    int getPitchSustainPoint() const noexcept;
    int getPitchEndPoint() const noexcept;
    
    // Rendering
    float renderNextSample() noexcept;
    
    bool isActive() const noexcept { return dcaEnvelope.isActive(); }
    int getCurrentNote() const noexcept { return currentNote; }
    
private:
    // Oscillators
    DSP::PhaseDistOscillator osc1;
    DSP::PhaseDistOscillator osc2;
    
    // Envelopes
    DSP::MultiStageEnvelope dcwEnvelope;  // Digital Controlled Wave (timbre)
    DSP::MultiStageEnvelope dcaEnvelope;  // Digital Controlled Amplifier (volume)
    DSP::MultiStageEnvelope pitchEnvelope; // DCO Pitch Envelope (new)
    
    // State
    int currentNote = -1;
    float currentVelocity = 1.0f;
    
    // Mix levels
    float osc1Level = 0.5f;
    float osc2Level = 0.5f;
    float osc2Detune = 0.0f;
    
    // Pitch Modulation State (Optimization)
    float baseFrequency = 440.0f;
    float currentDetuneFactor = 1.0f;
    
    bool isHardSyncEnabled = false;
    bool isRingModEnabled = false;
    
    float glideTime = 0.0f;
    float currentFrequency = 440.0f;
    float targetFrequency = 440.0f;
    
    // LFO State
    float vibratoDepth = 0.0f;
    float lfoValue = 0.0f;
    
    // Pitch Bend
    float pitchBendFactor = 1.0f;
    float masterTuneFactor = 1.0f;
    
    // Helper
    float midiNoteToFrequency(int midiNote) const noexcept;

private:
    // ===== ADSR STATE (NEW) =====
    struct ADSRParams {
        float attackMs = 10.0f;
        float decayMs = 200.0f;
        float sustainLevel = 0.5f;
        float releaseMs = 100.0f;
    };
    
    ADSRParams dcwADSR;  // DCW envelope state
    ADSRParams dcaADSR;  // DCA envelope state
    ADSRParams pitchADSR;  // Pitch envelope state
    
    // Helper to update envelopes from ADSR using stored sampleRate
    void updateDCWEnvelopeFromADSR() noexcept;
    void updateDCAEnvelopeFromADSR() noexcept;
    void updatePitchEnvelopeFromADSR() noexcept;

    double sampleRate = 44100.0;

};
} // namespace Core
} // namespace CZ101

================================================================================
FILE: .\Source\Core\VoiceManager.cpp
================================================================================
#include "VoiceManager.h"
#include "../DSP/Modulation/LFO.h"
#include <algorithm>

namespace CZ101 {
namespace Core {

VoiceManager::VoiceManager()
{
    voices.resize(MAX_VOICES);
}

void VoiceManager::setSampleRate(double sampleRate) noexcept
{
    for (auto& voice : voices)
        voice.setSampleRate(sampleRate);
}

// Optimization: Use a macro or template if this gets too repetitive, 
// but for clarity we'll implement explicit loopers.

void VoiceManager::setOsc1Waveform(int waveformIndex) noexcept
{
    auto w = static_cast<DSP::PhaseDistOscillator::Waveform>(waveformIndex);
    for (auto& voice : voices) voice.setOsc1Waveform(w);
}

void VoiceManager::setOsc1Level(float level) noexcept
{
    for (auto& voice : voices) voice.setOsc1Level(level);
}

void VoiceManager::setOsc2Waveform(int waveformIndex) noexcept
{
    auto w = static_cast<DSP::PhaseDistOscillator::Waveform>(waveformIndex);
    for (auto& voice : voices) voice.setOsc2Waveform(w);
}

void VoiceManager::setOsc2Level(float level) noexcept
{
    for (auto& voice : voices) voice.setOsc2Level(level);
}

void VoiceManager::setOsc2Detune(float cents) noexcept
{
    for (auto& voice : voices) voice.setOsc2Detune(cents);
}

void VoiceManager::setDCWAttack(float seconds) noexcept { for (auto& v : voices) v.setDCWAttack(seconds); }
void VoiceManager::setDCWDecay(float seconds) noexcept { for (auto& v : voices) v.setDCWDecay(seconds); }
void VoiceManager::setDCWSustain(float level) noexcept { for (auto& v : voices) v.setDCWSustain(level); }
void VoiceManager::setDCWRelease(float seconds) noexcept { for (auto& v : voices) v.setDCWRelease(seconds); }

void VoiceManager::setDCAAttack(float seconds) noexcept { for (auto& v : voices) v.setDCAAttack(seconds); }
void VoiceManager::setDCADecay(float seconds) noexcept { for (auto& v : voices) v.setDCADecay(seconds); }
void VoiceManager::setDCASustain(float level) noexcept { for (auto& v : voices) v.setDCASustain(level); }
void VoiceManager::setDCARelease(float seconds) noexcept { for (auto& v : voices) v.setDCARelease(seconds); }

// 8-Stage Control
void VoiceManager::setDCWStage(int index, float rate, float level) noexcept { for (auto& v : voices) v.setDCWStage(index, rate, level); }
void VoiceManager::setDCWSustainPoint(int index) noexcept { for (auto& v : voices) v.setDCWSustainPoint(index); }
void VoiceManager::setDCWEndPoint(int index) noexcept { for (auto& v : voices) v.setDCWEndPoint(index); }

void VoiceManager::setDCAStage(int index, float rate, float level) noexcept { for (auto& v : voices) v.setDCAStage(index, rate, level); }
void VoiceManager::setDCASustainPoint(int index) noexcept { for (auto& v : voices) v.setDCASustainPoint(index); }
void VoiceManager::setDCAEndPoint(int index) noexcept { for (auto& v : voices) v.setDCAEndPoint(index); }

// Pitch Envelope
void VoiceManager::setPitchStage(int index, float rate, float level) noexcept { for (auto& v : voices) v.setPitchStage(index, rate, level); }
void VoiceManager::setPitchSustainPoint(int index) noexcept { for (auto& v : voices) v.setPitchSustainPoint(index); }
void VoiceManager::setPitchEndPoint(int index) noexcept { for (auto& v : voices) v.setPitchEndPoint(index); }

void VoiceManager::getDCWStage(int index, float& rate, float& level) const noexcept { voices[0].getDCWStage(index, rate, level); }
int VoiceManager::getDCWSustainPoint() const noexcept { return voices[0].getDCWSustainPoint(); }
int VoiceManager::getDCWEndPoint() const noexcept { return voices[0].getDCWEndPoint(); }

void VoiceManager::getDCAStage(int index, float& rate, float& level) const noexcept { voices[0].getDCAStage(index, rate, level); }
int VoiceManager::getDCASustainPoint() const noexcept { return voices[0].getDCASustainPoint(); }
int VoiceManager::getDCAEndPoint() const noexcept { return voices[0].getDCAEndPoint(); }

void VoiceManager::getPitchStage(int index, float& rate, float& level) const noexcept { voices[0].getPitchStage(index, rate, level); }
int VoiceManager::getPitchSustainPoint() const noexcept { return voices[0].getPitchSustainPoint(); }
int VoiceManager::getPitchEndPoint() const noexcept { return voices[0].getPitchEndPoint(); }

void VoiceManager::setHardSync(bool enabled) noexcept { for (auto& v : voices) v.setHardSync(enabled); }
void VoiceManager::setRingMod(bool enabled) noexcept { for (auto& v : voices) v.setRingMod(enabled); }
void VoiceManager::setGlideTime(float seconds) noexcept { for (auto& v : voices) v.setGlideTime(seconds); }
void VoiceManager::setMasterTune(float semitones) noexcept { for (auto& v : voices) v.setMasterTune(semitones); }
void VoiceManager::setPitchBend(float semitones) noexcept { for (auto& v : voices) v.setPitchBend(semitones); }
void VoiceManager::setVibratoDepth(float semitones) noexcept { for (auto& v : voices) v.setVibratoDepth(semitones); }
void VoiceManager::updateLFO(float val) noexcept { for (auto& v : voices) v.setLFOValue(val); }

void VoiceManager::noteOn(int midiNote, float velocity) noexcept
{
    lastMidiNote = midiNote;

    // Check if any voice is already playing this note (e.g. still in release phase)
    // If so, steal it (monophonic retrigger per key) to prevent duplicate voices for same note
    int voiceIndex = findVoicePlayingNote(midiNote);
    
    if (voiceIndex < 0)
        voiceIndex = findFreeVoice();
    
    if (voiceIndex < 0)
        voiceIndex = findVoiceToSteal();
    
    if (voiceIndex >= 0)
        voices[voiceIndex].noteOn(midiNote, velocity);
}

void VoiceManager::noteOff(int midiNote) noexcept
{
    // Safely turn off ALL voices playing this note (just in case multiple exist)
    for (auto& voice : voices)
    {
        if (voice.isActive() && voice.getCurrentNote() == midiNote)
        {
            voice.noteOff();
        }
    }
}

void VoiceManager::allNotesOff() noexcept
{
    for (auto& voice : voices)
        voice.noteOff();
}


void VoiceManager::renderNextBlock(float* outputL, float* outputR, int numSamples, DSP::LFO* lfo) noexcept
{
    // Local LFO caching variables if we didn't want to call getNextValue per sample for optimization, 
    // but the request is specific: LFO IS broken because it's block rate.
    
    for (int i = 0; i < numSamples; ++i)
    {
        // Update LFO if provided
        if (lfo)
        {
            float lfoVal = lfo->getNextValue();
            for (auto& voice : voices)
                voice.setLFOValue(lfoVal); // Direct setter to avoid vtable overhead if possible, but here virtual
                // Actually updateLFO was iterating voices. Here we do it per sample.
                // Optim: This is O(N_Voices * N_Samples). 64 voices * 44100 = 2.8M iterations/sec. 
                // Acceptable for modern CPU.
        }
        
        float sample = 0.0f;
        for (auto& voice : voices)
        {
            if (voice.isActive()) // Optimization: Only render active voices
                sample += voice.renderNextSample();
        }
        
        outputL[i] = sample;
        outputR[i] = sample;
    }
}

int VoiceManager::getActiveVoiceCount() const noexcept
{
    int count = 0;
    for (const auto& voice : voices)
        if (voice.isActive())
            ++count;
    return count;
}

int VoiceManager::findFreeVoice() const noexcept
{
    for (size_t i = 0; i < voices.size(); ++i)
        if (!voices[i].isActive())
            return static_cast<int>(i);
    return -1;
}

int VoiceManager::findVoiceToSteal() const noexcept
{
    // Simple: steal first active voice (oldest)
    for (size_t i = 0; i < voices.size(); ++i)
        if (voices[i].isActive())
            return static_cast<int>(i);
    return 0;
}

int VoiceManager::findVoicePlayingNote(int midiNote) const noexcept
{
    for (size_t i = 0; i < voices.size(); ++i)
        if (voices[i].getCurrentNote() == midiNote)
            return static_cast<int>(i);
    return -1;
}

} // namespace Core
} // namespace CZ101
================================================================================
FILE: .\Source\Core\VoiceManager.h
================================================================================
#pragma once

#include "Voice.h"
#include <vector>

namespace CZ101 {

namespace DSP { class LFO; } // Forward declaration of LFO

namespace Core {

class VoiceManager
{
public:
    static constexpr int MAX_VOICES = 8;
    
    enum VoiceStealingMode
    {
        NONE,
        OLDEST,
        QUIETEST,
        RELEASE_PHASE
    };
    
    VoiceManager();
    
    void setSampleRate(double sampleRate) noexcept;
    void setVoiceStealingMode(VoiceStealingMode mode) noexcept { stealingMode = mode; }
    
    // Parameter Control (Proxy to all voices)
    // Oscillator 1
    void setOsc1Waveform(int waveformIndex) noexcept;
    void setOsc1Level(float level) noexcept;
    
    // Oscillator 2
    void setOsc2Waveform(int waveformIndex) noexcept;
    void setOsc2Level(float level) noexcept;
    void setOsc2Detune(float cents) noexcept;
    
    // DCW Envelope
    void setDCWAttack(float seconds) noexcept;
    void setDCWDecay(float seconds) noexcept;
    void setDCWSustain(float level) noexcept;
    void setDCWRelease(float seconds) noexcept;
    
    // DCA Envelope
    void setDCAAttack(float seconds) noexcept;
    void setDCADecay(float seconds) noexcept;
    void setDCASustain(float level) noexcept;
    void setDCARelease(float seconds) noexcept;
    
    // 8-Stage Envelope Control
    void setDCWStage(int index, float rate, float level) noexcept;
    void setDCWSustainPoint(int index) noexcept;
    void setDCWEndPoint(int index) noexcept;

    // Getters for UI
    void getDCWStage(int index, float& rate, float& level) const noexcept;
    int getDCWSustainPoint() const noexcept;
    int getDCWEndPoint() const noexcept;

    void getDCAStage(int index, float& rate, float& level) const noexcept;
    int getDCASustainPoint() const noexcept;
    int getDCAEndPoint() const noexcept;
    
    void getPitchStage(int index, float& rate, float& level) const noexcept;
    int getPitchSustainPoint() const noexcept;
    int getPitchEndPoint() const noexcept;
    
    void setDCAStage(int index, float rate, float level) noexcept;
    void setDCASustainPoint(int index) noexcept;
    void setDCAEndPoint(int index) noexcept;

    // Pitch Envelope (DCO)
    void setPitchStage(int index, float rate, float level) noexcept;
    void setPitchSustainPoint(int index) noexcept;
    void setPitchEndPoint(int index) noexcept;

    // Hard Sync
    void setHardSync(bool enabled) noexcept;

    // Ring Mod
    void setRingMod(bool enabled) noexcept;

    // Glide
    void setGlideTime(float seconds) noexcept;
    void setMasterTune(float semitones) noexcept;
    void setPitchBend(float semitones) noexcept;
    
    // LFO Control
    void setVibratoDepth(float semitones) noexcept;
    void updateLFO(float currentLFOValue) noexcept;

    void noteOn(int midiNote, float velocity) noexcept;
    void noteOff(int midiNote) noexcept;
    void allNotesOff() noexcept;
    // Audio Processing
    // Added LFO* to enable per-sample update
    void renderNextBlock(float* outputL, float* outputR, int numSamples, DSP::LFO* lfo = nullptr) noexcept;
    
    int getActiveVoiceCount() const noexcept;
    int getCurrentNote() const noexcept { return lastMidiNote; }

private:
    std::vector<Voice> voices; // Dynamic vector for voice pool
    VoiceStealingMode stealingMode = RELEASE_PHASE;
    int lastMidiNote = -1;
    
    int findFreeVoice() const noexcept;
    int findVoiceToSteal() const noexcept;
    int findVoicePlayingNote(int midiNote) const noexcept;
};

} // namespace Core
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Chorus.cpp
================================================================================
#include "Chorus.h"
#include <cmath>

namespace CZ101 {
namespace DSP {
namespace Effects {

Chorus::Chorus()
{
    // Max delay depth 20ms usually enough (Allocating 50ms for safety)
    // 50ms at 192kHz ~= 9600 samples
    bufferSize = 16384; 
    delayBufferL.resize(bufferSize, 0.0f);
    delayBufferR.resize(bufferSize, 0.0f);
}

void Chorus::prepare(double sr)
{
    sampleRate = sr;
    setRate(rate); // Recalc increment
    reset();
}

void Chorus::reset()
{
    std::fill(delayBufferL.begin(), delayBufferL.end(), 0.0f);
    std::fill(delayBufferR.begin(), delayBufferR.end(), 0.0f);
    writeIndex = 0;
    lfoPhase = 0.0f;
}

void Chorus::setRate(float rateHz)
{
    rate = rateHz;
    // Inc per sample = Rate / SR
    // 2PI for sin? Or 0-1 phasor? Using 0-1
    lfoIncrement = rate / static_cast<float>(sampleRate);
}

void Chorus::setDepth(float depthMs)
{
    depth = depthMs;
}

void Chorus::setMix(float mix0to1)
{
    mix = std::clamp(mix0to1, 0.0f, 1.0f);
}

float Chorus::getInterpolatedSample(const std::vector<float>& buffer, float readIndex) const
{
    // Linear Interpolation
    int index1 = static_cast<int>(readIndex);
    int index2 = (index1 + 1) % bufferSize;
    float fraction = readIndex - index1;
    
    float s1 = buffer[index1];
    float s2 = buffer[index2];
    
    return s1 + fraction * (s2 - s1);
}

void Chorus::process(float* leftChannel, float* rightChannel, int numSamples)
{
    if (mix < 0.01f) return; // Bypass efficiency
    
    const float depthSamples = (depth / 1000.0f) * static_cast<float>(sampleRate);
    // Base delay for Chorus usually slightly more than depth excursion
    const float baseDelay = depthSamples * 1.5f + 100.0f; // Offset to avoid crossing write pointer
    
    for (int i = 0; i < numSamples; ++i)
    {
        // Update LFO
        lfoPhase += lfoIncrement;
        if (lfoPhase >= 1.0f) lfoPhase -= 1.0f;
        
        // Calculate LFO values
        // Left: Sin(phase)
        // Right: Cos(phase) or Sin(phase + 90) -> Separation
        float lfoValL = std::sin(lfoPhase * 2.0f * juce::MathConstants<float>::pi);
        float lfoValR = std::cos(lfoPhase * 2.0f * juce::MathConstants<float>::pi);
        
        // Calculate read positions
        // Delay = Base + Depth * LFO
        float delayL = baseDelay + (depthSamples * lfoValL);
        float delayR = baseDelay + (depthSamples * lfoValR);
        
        // Circular buffer read pointers
        float readPosL = static_cast<float>(writeIndex) - delayL;
        if (readPosL < 0.0f) readPosL += bufferSize;
        
        float readPosR = static_cast<float>(writeIndex) - delayR;
        if (readPosR < 0.0f) readPosR += bufferSize;
        
        // Read wet samples
        float wetL = getInterpolatedSample(delayBufferL, readPosL);
        float wetR = getInterpolatedSample(delayBufferR, readPosR);
        
        // Write inputs to buffer
        delayBufferL[writeIndex] = leftChannel[i];
        delayBufferR[writeIndex] = rightChannel[i];
        
        // Mix
        leftChannel[i] = (leftChannel[i] * (1.0f - mix * 0.5f)) + (wetL * mix);
        rightChannel[i] = (rightChannel[i] * (1.0f - mix * 0.5f)) + (wetR * mix);
        
        // Advance write pointer
        writeIndex++;
        if (writeIndex >= bufferSize) writeIndex = 0;
    }
}

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Chorus.h
================================================================================
#pragma once

#include <vector>
#include <cmath>
#include <JuceHeader.h>

namespace CZ101 {
namespace DSP {
namespace Effects {

class Chorus {
public:
    Chorus();
    
    void prepare(double sampleRate);
    void reset();
    
    void setRate(float rateHz);
    void setDepth(float depthMs);
    void setMix(float mix0to1);
    
    void process(float* leftChannel, float* rightChannel, int numSamples);
    
private:
    double sampleRate = 44100.0;
    
    // Parameters
    float rate = 0.5f;
    float depth = 2.0f; // ms
    float mix = 0.0f;
    
    // Delay lines
    std::vector<float> delayBufferL;
    std::vector<float> delayBufferR;
    int writeIndex = 0;
    int bufferSize = 0;
    
    // LFO state
    float lfoPhase = 0.0f;
    float lfoIncrement = 0.0f;
    
    // Helpers
    float getInterpolatedSample(const std::vector<float>& buffer, float readIndex) const;
};

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Delay.cpp
================================================================================
#include "Delay.h"

namespace CZ101 {
namespace DSP {
namespace Effects {

Delay::Delay()
{
    buffer.fill(0.0f);
}

void Delay::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
}

void Delay::setDelayTime(float seconds) noexcept
{
    seconds = std::clamp(seconds, 0.001f, 2.0f);
    delayInSamples = static_cast<int>(seconds * sampleRate);
    delayInSamples = std::min(delayInSamples, MAX_DELAY_SAMPLES - 1);
}

void Delay::setFeedback(float amount) noexcept
{
    feedback = std::clamp(amount, 0.0f, 0.95f);
}

void Delay::setMix(float amount) noexcept
{
    mix = std::clamp(amount, 0.0f, 1.0f);
}

void Delay::reset() noexcept
{
    buffer.fill(0.0f);
    writePos = 0;
}

float Delay::processSample(float input) noexcept
{
    int readPos = writePos - delayInSamples;
    if (readPos < 0)
        readPos += MAX_DELAY_SAMPLES;
    
    float delayed = buffer[readPos];
    buffer[writePos] = input + delayed * feedback;
    
    writePos = (writePos + 1) % MAX_DELAY_SAMPLES;
    
    return input * (1.0f - mix) + delayed * mix;
}

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Delay.h
================================================================================
#pragma once

#include <array>
#include <algorithm>

namespace CZ101 {
namespace DSP {
namespace Effects {
    
class Delay
{
public:
    Delay();
    
    void setSampleRate(double sampleRate) noexcept;
    void setDelayTime(float seconds) noexcept;
    void setFeedback(float amount) noexcept;
    void setMix(float amount) noexcept;
    void reset() noexcept;
    
    float processSample(float input) noexcept;
    
private:
    static constexpr int MAX_DELAY_SAMPLES = 88200;  // 2 seconds @ 44.1kHz
    
    std::array<float, MAX_DELAY_SAMPLES> buffer;
    double sampleRate = 44100.0;
    int delayInSamples = 22050;
    int writePos = 0;
    float feedback = 0.5f;
    float mix = 0.3f;
};

} // namespace Effects
} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Reverb.cpp
================================================================================
#include "Reverb.h"

namespace CZ101 {
namespace DSP {

Reverb::Reverb()
{
    // Set default parameters
    params.roomSize = 0.5f;
    params.damping = 0.5f;
    params.wetLevel = 0.33f;
    params.dryLevel = 1.0f; // Normally we control mix differently, but juce::Reverb has explicit wet/dry
    params.width = 1.0f;
    params.freezeMode = 0.0f;
    
    reverb.setParameters(params);
}

void Reverb::prepare(double sampleRate, int samplesPerBlock)
{
    currentSampleRate = sampleRate;
    reverb.setSampleRate(sampleRate);
    reverb.reset();
    (void)samplesPerBlock;
}

void Reverb::reset()
{
    reverb.reset();
}

void Reverb::setParameters(float roomSize, float damping, float wetLevel, float dryLevel, float width)
{
    params.roomSize = roomSize;
    params.damping = damping;
    params.wetLevel = wetLevel;
    params.dryLevel = dryLevel;
    params.width = width;
    
    reverb.setParameters(params);
}

void Reverb::process(juce::AudioBuffer<float>& buffer)
{
    // juce::Reverb processes stereo buffers naturally
    if (buffer.getNumChannels() == 2)
    {
        reverb.processStereo(buffer.getWritePointer(0), buffer.getWritePointer(1), buffer.getNumSamples());
    }
    else if (buffer.getNumChannels() == 1)
    {
        reverb.processMono(buffer.getWritePointer(0), buffer.getNumSamples());
    }
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Effects\Reverb.h
================================================================================
#pragma once

#include <juce_audio_basics/juce_audio_basics.h>

namespace CZ101 {
namespace DSP {

class Reverb
{
public:
    Reverb();
    
    void prepare(double sampleRate, int samplesPerBlock);
    void reset();
    
    void setParameters(float roomSize, float damping, float wetLevel, float dryLevel, float width);
    
    void process(juce::AudioBuffer<float>& buffer);
    
private:
    juce::Reverb reverb;
    juce::Reverb::Parameters params;
    
    double currentSampleRate = 44100.0;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Envelopes\ADSREnvelope.cpp
================================================================================
#include "ADSREnvelope.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

ADSREnvelope::ADSREnvelope()
{
}

void ADSREnvelope::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
}

void ADSREnvelope::setAttackTime(float seconds) noexcept
{
    attackTime = std::clamp(seconds, 0.001f, 10.0f);
}

void ADSREnvelope::setDecayTime(float seconds) noexcept
{
    decayTime = std::clamp(seconds, 0.001f, 10.0f);
}

void ADSREnvelope::setSustainLevel(float level) noexcept
{
    sustainLevel = std::clamp(level, 0.0f, 1.0f);
}

void ADSREnvelope::setReleaseTime(float seconds) noexcept
{
    releaseTime = std::clamp(seconds, 0.001f, 10.0f);
}

void ADSREnvelope::noteOn() noexcept
{
    currentStage = ATTACK;
    stageProgress = 0.0f;
}

void ADSREnvelope::noteOff() noexcept
{
    if (currentStage != IDLE)
    {
        currentStage = RELEASE;
        stageProgress = 0.0f;
    }
}

void ADSREnvelope::reset() noexcept
{
    currentStage = IDLE;
    currentValue = 0.0f;
    stageProgress = 0.0f;
}

float ADSREnvelope::getNextValue() noexcept
{
    if (currentStage == IDLE)
        return 0.0f;
    
    float stageDuration = 0.0f;
    float targetValue = 0.0f;
    float startValue = currentValue;
    
    switch (currentStage)
    {
        case ATTACK:
            stageDuration = attackTime;
            targetValue = 1.0f;
            startValue = 0.0f;
            break;
            
        case DECAY:
            stageDuration = decayTime;
            targetValue = sustainLevel;
            startValue = 1.0f;
            break;
            
        case SUSTAIN:
            return sustainLevel;
            
        case RELEASE:
            stageDuration = releaseTime;
            targetValue = 0.0f;
            startValue = currentValue;
            break;
            
        default:
            return 0.0f;
    }
    
    // Calculate progress increment
    float increment = 1.0f / (stageDuration * static_cast<float>(sampleRate));
    stageProgress += increment;
    
    // Apply exponential curve
    float curvedProgress = calculateExponentialCurve(stageProgress);
    
    // Interpolate between start and target
    currentValue = startValue + (targetValue - startValue) * curvedProgress;
    
    // Check if stage is complete
    if (stageProgress >= 1.0f)
    {
        currentValue = targetValue;
        advanceStage();
    }
    
    return currentValue;
}

float ADSREnvelope::calculateExponentialCurve(float t) const noexcept
{
    // Exponential curve: 1 - e^(-factor * t)
    // This creates a natural-sounding envelope
    t = std::clamp(t, 0.0f, 1.0f);
    return 1.0f - std::exp(-CURVE_FACTOR * t);
}

void ADSREnvelope::advanceStage() noexcept
{
    stageProgress = 0.0f;
    
    switch (currentStage)
    {
        case ATTACK:
            currentStage = DECAY;
            break;
            
        case DECAY:
            currentStage = SUSTAIN;
            break;
            
        case SUSTAIN:
            // Stay in sustain until noteOff
            break;
            
        case RELEASE:
            currentStage = IDLE;
            currentValue = 0.0f;
            break;
            
        default:
            break;
    }
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Envelopes\ADSREnvelope.h
================================================================================
#pragma once

#include <cmath>

namespace CZ101 {
namespace DSP {

/**
 * @brief ADSR Envelope Generator
 * 
 * Classic Attack-Decay-Sustain-Release envelope with exponential curves.
 * Used for both amplitude (DCA) and filter/timbre (DCW) modulation.
 */
class ADSREnvelope
{
public:
    enum Stage
    {
        IDLE = 0,
        ATTACK,
        DECAY,
        SUSTAIN,
        RELEASE,
        NUM_STAGES
    };
    
    ADSREnvelope();
    
    void setSampleRate(double sampleRate) noexcept;
    
    // Parameters in seconds
    void setAttackTime(float seconds) noexcept;
    void setDecayTime(float seconds) noexcept;
    void setSustainLevel(float level) noexcept;  // [0.0, 1.0]
    void setReleaseTime(float seconds) noexcept;
    
    void noteOn() noexcept;
    void noteOff() noexcept;
    void reset() noexcept;
    
    /**
     * @brief Get next envelope value
     * @return Envelope value [0.0, 1.0]
     */
    float getNextValue() noexcept;
    
    Stage getCurrentStage() const noexcept { return currentStage; }
    bool isActive() const noexcept { return currentStage != IDLE; }
    
private:
    double sampleRate = 44100.0;
    
    // Parameters
    float attackTime = 0.01f;    // 10ms
    float decayTime = 0.1f;      // 100ms
    float sustainLevel = 0.7f;   // 70%
    float releaseTime = 0.2f;    // 200ms
    
    // State
    Stage currentStage = IDLE;
    float currentValue = 0.0f;
    float stageProgress = 0.0f;  // [0.0, 1.0]
    
    // Exponential curve factor (higher = more exponential)
    static constexpr float CURVE_FACTOR = 4.0f;
    
    float calculateExponentialCurve(float t) const noexcept;
    void advanceStage() noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Envelopes\ADSRtoStage.h
================================================================================
#pragma once

#include <cmath>
#include <array>
#include <algorithm>

namespace CZ101 {
namespace DSP {

/**
 * @brief ConversiÃ³n ADSR â†’ 8-stage envelope rates
 * 
 * Mapea parÃ¡metros ADSR (milisegundos) a coeficientes de stage
 * usando aproximaciÃ³n logarÃ­tmica basada en tiempo de caÃ­da 60dB
 */
struct ADSRtoStageConverter {
    
    /**
     * @brief Convertir ADSR a 8 stages
     * 
     * @param attackMs      Attack time (0-8000ms)
     * @param decayMs       Decay time (0-8000ms)
     * @param sustainLevel  Sustain level (0-1.0)
     * @param releaseMs     Release time (0-8000ms)
     * @param outRates      [OUT] array de 8 coeficientes de rate
     * @param outLevels     [OUT] array de 8 niveles objetivo
     * @param outSustainPoint [OUT] Ã­ndice de sustain
     * @param outEndPoint   [OUT] Ã­ndice de fin
     * @param sampleRate    Sample rate (default 44100)
     */
    static void convertADSR(
        float attackMs,
        float decayMs,
        float sustainLevel,
        float releaseMs,
        std::array<float, 8>& outRates,
        std::array<float, 8>& outLevels,
        int& outSustainPoint,
        int& outEndPoint,
        double sampleRate = 44100.0
    ) {
        // Validar y clampear inputs
        attackMs = std::clamp(attackMs, 0.0f, 8000.0f);
        decayMs = std::clamp(decayMs, 0.0f, 8000.0f);
        sustainLevel = std::clamp(sustainLevel, 0.0f, 1.0f);
        releaseMs = std::clamp(releaseMs, 0.0f, 8000.0f);
        
        // FunciÃ³n interna: convertir milisegundos â†’ coeficiente de decay
        auto msToRateCoeff = [sampleRate](float ms) -> float {
            if (ms < 1.0f) ms = 1.0f;
            if (ms > 8000.0f) ms = 8000.0f;
            
            // Convertir a segundos
            float sec = ms / 1000.0f;
            
            // Exponential decay: e^(-k*t)
            // Para 60dB en tiempo T: k = 5.5 / T
            float k = 5.5f / (sec * static_cast<float>(sampleRate));
            
            // Coeficiente per-sample: rate = e^(-k)
            float coeff = std::exp(-k);
            
            // Clamp para estabilidad numÃ©rica
            return std::clamp(coeff, 0.001f, 0.99f);
        };
        
        // ===== STAGE 0: ATTACK =====
        // Rampa desde 0 hacia 1.0
        outRates[0] = msToRateCoeff(attackMs);
        outLevels[0] = 1.0f;
        
        // ===== STAGE 1: DECAY =====
        // Rampa desde 1.0 hacia sustain
        outRates[1] = msToRateCoeff(decayMs);
        outLevels[1] = sustainLevel;
        
        // ===== STAGE 2: SUSTAIN HOLD =====
        // Mantiene nivel de sustain (sin decaimiento)
        outRates[2] = 0.99f;
        outLevels[2] = sustainLevel;
        
        // ===== STAGE 3: RELEASE =====
        // Rampa desde sustain hacia 0
        outRates[3] = msToRateCoeff(releaseMs);
        outLevels[3] = 0.0f;
        
        // ===== STAGES 4-7: UNUSED =====
        for (int i = 4; i < 8; ++i) {
            outRates[i] = 0.99f;
            outLevels[i] = 0.0f;
        }
        
        // Puntos de control de sustain y fin
        outSustainPoint = 2;  // Sustain en stage 2
        outEndPoint = 3;      // Release en stage 3
    }
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Envelopes\MultiStageEnv.cpp
================================================================================
#include "MultiStageEnv.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

MultiStageEnvelope::MultiStageEnvelope()
{
    // Default: Simple ADSR-like shape using 8 stages
    // Stage 0: Attack to 1.0
    setStage(0, 0.9f, 1.0f);
    // Stage 1: Decay to 0.5
    setStage(1, 0.8f, 0.5f);
    // Stage 2: Sustain at 0.5
    setStage(2, 0.99f, 0.5f);
    
    // Sets sustain point at Stage 2
    setSustainPoint(2);
    
    // Stage 3: Release to 0
    setStage(3, 0.8f, 0.0f);
    
    // End point at Stage 3
    setEndPoint(3);
}

void MultiStageEnvelope::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
}

void MultiStageEnvelope::setStage(int index, float rate, float level) noexcept
{
    if (index >= 0 && index < MAX_STAGES)
    {
        stages[index].rate = std::clamp(rate, 0.0f, 1.0f);
        stages[index].level = std::clamp(level, 0.0f, 1.0f);
    }
}

void MultiStageEnvelope::setSustainPoint(int stageIndex) noexcept
{
    if (stageIndex >= -1 && stageIndex < MAX_STAGES)
        sustainPoint = stageIndex;
}

void MultiStageEnvelope::setEndPoint(int stageIndex) noexcept
{
    if (stageIndex >= 0 && stageIndex < MAX_STAGES)
        endPoint = stageIndex;
}

void MultiStageEnvelope::noteOn() noexcept
{
    currentStage = 0;
    active = true;
    released = false;
    
    // Start from 0
    float startVal = 0.0f;
    smoother.setCurrentAndTargetValue(startVal);
    
    // Setup first stage
    float seconds = rateToSeconds(stages[0].rate);
    smoother.reset(sampleRate, seconds > 0.001f ? seconds : 0.001f); 
    smoother.setCurrentAndTargetValue(startVal);
    smoother.setTargetValue(stages[0].level);
}

void MultiStageEnvelope::noteOff() noexcept
{
    released = true;
    
    // If currently holding at sustain point, move to next stage immediately
    if (active && currentStage == sustainPoint)
    {
        // Force transition to next stage
        currentStage++;
        if (currentStage > endPoint)
        {
            active = false;
            return;
        }
        
        // Setup next stage from current value
        float currentVal = smoother.getCurrentValue();
        float seconds = rateToSeconds(stages[currentStage].rate);
        
        smoother.reset(sampleRate, seconds > 0.001f ? seconds : 0.001f);
        smoother.setCurrentAndTargetValue(currentVal);
        smoother.setTargetValue(stages[currentStage].level);
    }
}

void MultiStageEnvelope::reset() noexcept
{
    active = false;
    currentStage = 0;
    smoother.setCurrentAndTargetValue(0.0f);
}

float MultiStageEnvelope::getNextValue() noexcept
{
    if (!active) return 0.0f;
    
    float val = smoother.getNextValue();
    
    // Check if stage finished
    if (!smoother.isSmoothing())
    {
        val = smoother.getTargetValue(); // Ensure snap
        
        // Are we at Sustain Point?
        if (currentStage == sustainPoint && !released)
        {
            // Hold here until Note Off
            // Do nothing, just return val
        }
        else if (currentStage >= endPoint)
        {
            // End of envelope
            // If released or no sustain, we are done
            // If we are sustaining at end (unlikely for CZ architecture, end is end), disable.
            active = false;
        }
        else
        {
            // Move to next stage
            currentStage++;
            
            if (currentStage < MAX_STAGES)
            {
                float currentVal = val;
                float seconds = rateToSeconds(stages[currentStage].rate);
                smoother.reset(sampleRate, seconds > 0.001f ? seconds : 0.001f);
                smoother.setCurrentAndTargetValue(currentVal);
                smoother.setTargetValue(stages[currentStage].level);
            }
            else
            {
                active = false;
            }
        }
    }
    
    return val;
}

float MultiStageEnvelope::rateToSeconds(float rate) const noexcept
{
    // CZ-101 Rate approximation
    // Rate 0.0 (slow) -> ~3 seconds (can be longer on real hardware)
    // Rate 1.0 (fast) -> ~1 ms
    
    // Using exponential curve
    // Invert rate: 1.0 is slow, 0.0 is fast for calculation
    float r = 1.0f - rate;
    
    // Base 30s max time
    return 0.001f + (std::pow(r, 4.0f) * 30.0f);
}

float MultiStageEnvelope::getStageRate(int index) const noexcept
{
    if (index >= 0 && index < MAX_STAGES)
        return stages[index].rate;
    return 0.0f;
}

float MultiStageEnvelope::getStageLevel(int index) const noexcept
{
    if (index >= 0 && index < MAX_STAGES)
        return stages[index].level;
    return 0.0f;
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Envelopes\MultiStageEnv.h
================================================================================
#pragma once

#include <array>
#include <cmath>
#include <juce_audio_basics/juce_audio_basics.h>

namespace CZ101 {
namespace DSP {

/**
 * @brief Multi-Stage Envelope Generator (8 stages)
 * 
 * Authentic CZ-101 Envelope Architecture:
 * - 8 Steps per envelope
 * - Each step has a Rate (speed) and Level (target)
 * - Sustain Point: The step where the envelope holds while key is pressed.
 * - End Point: The final step of the envelope.
 */
class MultiStageEnvelope
{
public:
    static constexpr int MAX_STAGES = 8;
    
    struct Stage
    {
        float level = 0.0f;      // Target level [0.0, 1.0]
        float rate = 0.5f;       // Speed to reach level [0.0, 1.0] (1.0 = fast, 0.0 = slow)
    };
    
    MultiStageEnvelope();
    
    void setSampleRate(double sampleRate) noexcept;
    
    // Configuration
    void setStage(int index, float rate, float level) noexcept;
    void setSustainPoint(int stageIndex) noexcept;
    void setEndPoint(int stageIndex) noexcept;
    
    // Runtime
    void noteOn() noexcept;
    void noteOff() noexcept;
    void reset() noexcept;
    
    float getNextValue() noexcept;
    
    // Getters for adapter logic
    float getStageRate(int index) const noexcept;
    float getStageLevel(int index) const noexcept;
    
    bool isActive() const noexcept { return active; }
    int getCurrentStage() const noexcept { return currentStage; }
    
    int getSustainPoint() const noexcept { return sustainPoint; }
    int getEndPoint() const noexcept { return endPoint; }
    
private:
    double sampleRate = 44100.0;
    std::array<Stage, MAX_STAGES> stages;
    
    // Envelope Smoother
    juce::LinearSmoothedValue<float> smoother;
    
    int currentStage = 0;
    // Removed manual currentValue/Increment/targetValue as smoother handles it
    
    int sustainPoint = -1;  // -1 = no sustain (or one-shot)
    int endPoint = 7;       // Default to using all 8 stages
    
    bool active = false;
    bool released = false;
    
    // CZ-101 Rate to Time conversion (internal helper)
    // Rate 0-99 mapped to ms
    float rateToSeconds(float rate) const noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Filters\ResonantFilter.cpp
================================================================================
#include "ResonantFilter.h"

namespace CZ101 {
namespace DSP {

ResonantFilter::ResonantFilter()
{
    updateCoefficients();
}

void ResonantFilter::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
    updateCoefficients();
}

void ResonantFilter::setType(Type type) noexcept
{
    filterType = type;
    updateCoefficients();
}

void ResonantFilter::setCutoff(float frequency) noexcept
{
    cutoffFreq = std::clamp(frequency, 20.0f, 20000.0f);
    updateCoefficients();
}

void ResonantFilter::setResonance(float q) noexcept
{
    resonance = std::clamp(q, 0.1f, 10.0f);
    updateCoefficients();
}

void ResonantFilter::reset() noexcept
{
    z1 = 0.0f;
    z2 = 0.0f;
}

float ResonantFilter::processSample(float input) noexcept
{
    float output = a0 * input + a1 * z1 + a2 * z2 - b1 * z1 - b2 * z2;
    
    z2 = z1;
    z1 = output;
    
    return output;
}

void ResonantFilter::updateCoefficients() noexcept
{
    constexpr float PI = 3.14159265358979323846f;
    
    float omega = 2.0f * PI * cutoffFreq / static_cast<float>(sampleRate);
    float sinOmega = std::sin(omega);
    float cosOmega = std::cos(omega);
    float alpha = sinOmega / (2.0f * resonance);
    
    switch (filterType)
    {
        case LOWPASS:
        {
            float b0 = (1.0f - cosOmega) / 2.0f;
            float b1_coef = 1.0f - cosOmega;
            float b2_coef = (1.0f - cosOmega) / 2.0f;
            float a0_coef = 1.0f + alpha;
            float a1_coef = -2.0f * cosOmega;
            float a2_coef = 1.0f - alpha;
            
            a0 = b0 / a0_coef;
            a1 = b1_coef / a0_coef;
            a2 = b2_coef / a0_coef;
            b1 = a1_coef / a0_coef;
            b2 = a2_coef / a0_coef;
            break;
        }
        
        case HIGHPASS:
        {
            float b0 = (1.0f + cosOmega) / 2.0f;
            float b1_coef = -(1.0f + cosOmega);
            float b2_coef = (1.0f + cosOmega) / 2.0f;
            float a0_coef = 1.0f + alpha;
            float a1_coef = -2.0f * cosOmega;
            float a2_coef = 1.0f - alpha;
            
            a0 = b0 / a0_coef;
            a1 = b1_coef / a0_coef;
            a2 = b2_coef / a0_coef;
            b1 = a1_coef / a0_coef;
            b2 = a2_coef / a0_coef;
            break;
        }
        
        case BANDPASS:
        {
            float b0 = alpha;
            float b1_coef = 0.0f;
            float b2_coef = -alpha;
            float a0_coef = 1.0f + alpha;
            float a1_coef = -2.0f * cosOmega;
            float a2_coef = 1.0f - alpha;
            
            a0 = b0 / a0_coef;
            a1 = b1_coef / a0_coef;
            a2 = b2_coef / a0_coef;
            b1 = a1_coef / a0_coef;
            b2 = a2_coef / a0_coef;
            break;
        }
        
        default:
            break;
    }
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Filters\ResonantFilter.h
================================================================================
#pragma once

#include <cmath>
#include <algorithm>

namespace CZ101 {
namespace DSP {

class ResonantFilter
{
public:
    enum Type
    {
        LOWPASS = 0,
        HIGHPASS,
        BANDPASS,
        NUM_TYPES
    };
    
    ResonantFilter();
    
    void setSampleRate(double sampleRate) noexcept;
    void setType(Type type) noexcept;
    void setCutoff(float frequency) noexcept;
    void setResonance(float q) noexcept;
    void reset() noexcept;
    
    float processSample(float input) noexcept;
    
private:
    double sampleRate = 44100.0;
    Type filterType = LOWPASS;
    float cutoffFreq = 1000.0f;
    float resonance = 0.7f;
    
    // State variables (2-pole)
    float z1 = 0.0f;
    float z2 = 0.0f;
    
    // Coefficients
    float a0 = 1.0f, a1 = 0.0f, a2 = 0.0f;
    float b1 = 0.0f, b2 = 0.0f;
    
    void updateCoefficients() noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Modulation\LFO.cpp
================================================================================
#include "LFO.h"
#include <algorithm>
#include <random>
#include <mutex>
#include <array>

namespace CZ101 {
namespace DSP {

LFO::LFO()
{
    updatePhaseIncrement();
}

void LFO::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
    updatePhaseIncrement();
}

void LFO::setFrequency(float hz) noexcept
{
    frequency = std::clamp(hz, 0.01f, 20.0f);
    updatePhaseIncrement();
}

void LFO::setWaveform(Waveform waveform) noexcept
{
    currentWaveform = waveform;
}

void LFO::reset() noexcept
{
    phase = 0.0f;
}

// Static LFO Table
constexpr int LFO_TABLE_SIZE = 2048;
static std::array<float, LFO_TABLE_SIZE> lfoSineTable;
static std::once_flag lfoTableFlag;

void LFO::updatePhaseIncrement() noexcept
{
    phaseIncrement = frequency / static_cast<float>(sampleRate);
}

float LFO::getNextValue() noexcept
{
    float value = 0.0f;
    
    switch (currentWaveform)
    {
        case SINE: value = renderSine(); break;
        case TRIANGLE: value = renderTriangle(); break;
        case SAWTOOTH: value = renderSawtooth(); break;
        case SQUARE: value = renderSquare(); break;
        case RANDOM: value = renderRandom(); break;
        default: value = 0.0f;
    }
    
    phase += phaseIncrement;
    if (phase >= 1.0f)
        phase -= 1.0f;
    
    return value;
}

float LFO::renderSine() noexcept
{
    // Initialize table once
    std::call_once(lfoTableFlag, [](){
        constexpr float TWO_PI = 6.28318530718f;
        for (int i = 0; i < LFO_TABLE_SIZE; ++i) {
            lfoSineTable[i] = std::sin(TWO_PI * (static_cast<float>(i) / LFO_TABLE_SIZE));
        }
    });

    float indexF = phase * static_cast<float>(LFO_TABLE_SIZE);
    int index = static_cast<int>(indexF);
    float frac = indexF - static_cast<float>(index);
    
    // Safety wrap (phase is 0..1 but float math)
    if (index >= LFO_TABLE_SIZE) index = 0;
    
    int nextIndex = index + 1;
    if (nextIndex >= LFO_TABLE_SIZE) nextIndex = 0;
    
    float val1 = lfoSineTable[index];
    float val2 = lfoSineTable[nextIndex];
    
    return val1 + frac * (val2 - val1);
}

float LFO::renderTriangle() noexcept
{
    if (phase < 0.25f)
        return 4.0f * phase;
    else if (phase < 0.75f)
        return 2.0f - 4.0f * phase;
    else
        return 4.0f * phase - 4.0f;
}

float LFO::renderSawtooth() noexcept
{
    return 2.0f * phase - 1.0f;
}

float LFO::renderSquare() noexcept
{
    return (phase < 0.5f) ? 1.0f : -1.0f;
}

float LFO::renderRandom() noexcept
{
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_real_distribution<float> dis(-1.0f, 1.0f);
    
    if (phase < phaseIncrement)
        randomValue = dis(gen);
    
    return randomValue;
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Modulation\LFO.h
================================================================================
#pragma once

#include <cmath>

namespace CZ101 {
namespace DSP {

class LFO
{
public:
    enum Waveform
    {
        SINE = 0,
        TRIANGLE,
        SAWTOOTH,
        SQUARE,
        RANDOM,
        NUM_WAVEFORMS
    };
    
    LFO();
    
    void setSampleRate(double sampleRate) noexcept;
    void setFrequency(float hz) noexcept;
    void setWaveform(Waveform waveform) noexcept;
    void reset() noexcept;
    
    float getNextValue() noexcept;
    
private:
    double sampleRate = 44100.0;
    float frequency = 1.0f;
    Waveform currentWaveform = SINE;
    float phase = 0.0f;
    float phaseIncrement = 0.0f;
    float randomValue = 0.0f;
    
    void updatePhaseIncrement() noexcept;
    float renderSine() noexcept;
    float renderTriangle() noexcept;
    float renderSawtooth() noexcept;
    float renderSquare() noexcept;
    float renderRandom() noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\PhaseDistOsc.cpp
================================================================================
#include "PhaseDistOsc.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

PhaseDistOscillator::PhaseDistOscillator()
{
    updatePhaseIncrement();
}

void PhaseDistOscillator::setSampleRate(double sr) noexcept
{
    sampleRate = sr;
    updatePhaseIncrement();
}

void PhaseDistOscillator::setFrequency(float freq) noexcept
{
    frequency = std::clamp(freq, 20.0f, 20000.0f);
    updatePhaseIncrement();
}

void PhaseDistOscillator::setWaveform(Waveform waveform) noexcept
{
    currentWaveform = waveform;
}

void PhaseDistOscillator::reset() noexcept
{
    phase = 0.0f;
}

void PhaseDistOscillator::updatePhaseIncrement() noexcept
{
    phaseIncrement = static_cast<float>(frequency / sampleRate);
}

float PhaseDistOscillator::renderNextSample(float dcwAmount, bool* outDidWrap) noexcept
{
    float sample = 0.0f;
    
    // Render based on current waveform
    switch (currentWaveform)
    {
        case SINE:
            sample = renderSine();
            break;
        case SAWTOOTH:
            sample = renderSawtooth();
            break;
        case SQUARE:
            sample = renderSquare();
            break;
        case TRIANGLE:
            sample = renderTriangle();
            break;
        default:
            sample = 0.0f;
    }

    // Phase Distortion Simulation (Timbre Modulation)
    // Mix between Pure Sine (fundamental) and Full Waveform based on DCW amount
    // This creates the characteristic "wah" or filter sweep sound of PD synthesis
    if (dcwAmount < 1.0f && currentWaveform != SINE)
    {
        float sineComp = renderSine();
        // Linear interpolation: sine -> full waveform
        sample = sineComp + (sample - sineComp) * dcwAmount;
    }
    
    // Advance phase
    phase += phaseIncrement;
    if (phase >= 1.0f)
    {
        phase -= 1.0f;
        if (outDidWrap) *outDidWrap = true;
    }
    else
    {
        if (outDidWrap) *outDidWrap = false;
    }
    
    return sample;
}

float PhaseDistOscillator::renderSine() noexcept
{
    // Sine wave: Perfect, no aliasing, no PolyBLEP needed
    return waveTable.getSine(phase);
}

float PhaseDistOscillator::renderSawtooth() noexcept
{
    // Naive sawtooth
    float value = 2.0f * phase - 1.0f;
    
    // Apply PolyBLEP at discontinuity (phase wraps from 1.0 to 0.0)
    value -= polyBLEP(phase, phaseIncrement);
    
    return value;
}

float PhaseDistOscillator::renderSquare() noexcept
{
    // Naive square wave
    float value = (phase < 0.5f) ? 1.0f : -1.0f;
    
    // Apply PolyBLEP at rising edge (phase = 0.0)
    value += polyBLEP(phase, phaseIncrement);
    
    // Apply PolyBLEP at falling edge (phase = 0.5)
    float phaseShifted = phase + 0.5f;
    if (phaseShifted >= 1.0f)
        phaseShifted -= 1.0f;
    value -= polyBLEP(phaseShifted, phaseIncrement);
    
    return value;
}

float PhaseDistOscillator::renderTriangle() noexcept
{
    // Triangle: Continuous waveform, no PolyBLEP needed
    return waveTable.getTriangle(phase);
}

float PhaseDistOscillator::polyBLEP(float t, float dt) const noexcept
{
    // PolyBLEP: Polynomial Bandlimited Step
    // Reduces aliasing by smoothing discontinuities
    
    // t: normalized phase [0.0, 1.0]
    // dt: phase increment per sample (frequency/sampleRate)
    
    // Discontinuity at start of cycle (t near 0.0)
    if (t < dt)
    {
        t /= dt;
        // Polynomial: t^2 - 2t + 1
        return t + t - t * t - 1.0f;
    }
    // Discontinuity at end of cycle (t near 1.0)
    else if (t > 1.0f - dt)
    {
        t = (t - 1.0f) / dt;
        // Polynomial: t^2 + 2t + 1
        return t * t + t + t + 1.0f;
    }
    
    // No discontinuity, no correction needed
    return 0.0f;
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\PhaseDistOsc.h
================================================================================
#pragma once

#include "WaveTable.h"
#include <cmath>

namespace CZ101 {
namespace DSP {

/**
 * @brief Phase Distortion Oscillator with PolyBLEP anti-aliasing
 * 
 * Core oscillator for CZ-101 emulation. Generates waveforms with
 * professional quality anti-aliasing using PolyBLEP technique.
 */
class PhaseDistOscillator
{
public:
    enum Waveform
    {
        SINE = 0,
        SAWTOOTH,
        SQUARE,
        TRIANGLE,
        NUM_WAVEFORMS
    };
    
    PhaseDistOscillator();
    
    /**
     * @brief Set sample rate
     * @param sampleRate Sample rate in Hz (e.g., 44100.0)
     */
    void setSampleRate(double sampleRate) noexcept;
    
    /**
     * @brief Set frequency
     * @param frequency Frequency in Hz (e.g., 440.0 for A4)
     */
    void setFrequency(float frequency) noexcept;
    
    /**
     * @brief Set waveform type
     * @param waveform Waveform enum value
     */
    void setWaveform(Waveform waveform) noexcept;
    
    /**
     * @brief Reset phase to zero
     */
    void reset() noexcept;
    
    /**
     * @brief Render next sample with Phase Distortion simulation
     * @param dcwAmount Timbre control [0.0 = Pure Sine, 1.0 = Full Waveform]
     * @param outDidWrap Pointer to bool that will be set to true if phase wrapped (optional)
     * @return Audio sample [-1.0, 1.0]
     */
    float renderNextSample(float dcwAmount, bool* outDidWrap = nullptr) noexcept;
    
private:
    WaveTable waveTable;
    
    double sampleRate = 44100.0;
    float frequency = 440.0f;
    Waveform currentWaveform = SINE;
    
    float phase = 0.0f;           // Current phase [0.0, 1.0]
    float phaseIncrement = 0.0f;  // Phase increment per sample
    
    /**
     * @brief PolyBLEP: Polynomial Bandlimited Step
     * 
     * Reduces aliasing by smoothing discontinuities in waveforms.
     * Essential for sawtooth and square waves.
     * 
     * @param t Normalized phase [0.0, 1.0]
     * @param dt Phase increment (frequency/sampleRate)
     * @return Correction value to subtract from naive waveform
     */
    float polyBLEP(float t, float dt) const noexcept;
    
    // Waveform renderers
    float renderSine() noexcept;
    float renderSawtooth() noexcept;
    float renderSquare() noexcept;
    float renderTriangle() noexcept;
    
    void updatePhaseIncrement() noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\WaveShaper.cpp
================================================================================
#include "WaveShaper.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

float WaveShaper::applyPhaseDistortion(float phase, float amount) const noexcept
{
    // Clamp inputs
    phase = std::clamp(phase, 0.0f, 1.0f);
    amount = std::clamp(amount, 0.0f, 1.0f);
    
    // No distortion: return original phase
    if (amount < 0.001f)
        return phase;
    
    // Apply resonance curve
    // This creates the characteristic CZ-101 timbre by
    // compressing/expanding different parts of the waveform
    float distorted = resonanceCurve(phase, amount);
    
    return std::clamp(distorted, 0.0f, 1.0f);
}

float WaveShaper::resonanceCurve(float phase, float resonance) const noexcept
{
    // CZ-101 Phase Distortion algorithm
    // Based on the original Casio implementation
    
    // The curve compresses the first half and expands the second half
    // creating harmonic content similar to filter resonance
    
    // Calculate distortion factor
    // Higher resonance = more compression/expansion
    float factor = 1.0f + resonance * 3.0f;
    
    // Apply non-linear curve
    // This creates the phase distortion effect
    float distorted;
    
    if (phase < 0.5f)
    {
        // First half: compress (speeds up playback)
        float t = phase * 2.0f;  // Normalize to [0, 1]
        distorted = std::pow(t, factor) * 0.5f;
    }
    else
    {
        // Second half: expand (slows down playback)
        float t = (phase - 0.5f) * 2.0f;  // Normalize to [0, 1]
        distorted = 0.5f + (1.0f - std::pow(1.0f - t, factor)) * 0.5f;
    }
    
    return distorted;
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\WaveShaper.h
================================================================================
#pragma once

#include <cmath>

namespace CZ101 {
namespace DSP {

/**
 * @brief WaveShaper for Phase Distortion synthesis
 * 
 * Implements the core CZ-101 phase distortion algorithm.
 * Modulates the phase of a waveform to create harmonic content.
 */
class WaveShaper
{
public:
    WaveShaper() = default;
    
    /**
     * @brief Apply phase distortion to a normalized phase value
     * 
     * @param phase Input phase [0.0, 1.0]
     * @param amount Distortion amount [0.0, 1.0]
     *               0.0 = no distortion (linear)
     *               1.0 = maximum distortion
     * @return Distorted phase [0.0, 1.0]
     */
    float applyPhaseDistortion(float phase, float amount) const noexcept;
    
private:
    /**
     * @brief Resonance curve for phase distortion
     * Creates the characteristic CZ-101 timbre
     */
    float resonanceCurve(float phase, float resonance) const noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\WaveTable.cpp
================================================================================
#include "WaveTable.h"
#include <algorithm>

namespace CZ101 {
namespace DSP {

WaveTable::WaveTable()
{
    generateTables();
}

void WaveTable::generateTables()
{
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    
    for (int i = 0; i < TABLE_SIZE; ++i)
    {
        const float phase = static_cast<float>(i) / static_cast<float>(TABLE_SIZE);
        
        // Sine wave: Perfect, no aliasing
        sineTable[i] = std::sin(TWO_PI * phase);
        
        // Sawtooth: Naive version (PolyBLEP applied at render time)
        sawtoothTable[i] = 2.0f * phase - 1.0f;
        
        // Square: Naive version (PolyBLEP applied at render time)
        squareTable[i] = (phase < 0.5f) ? 1.0f : -1.0f;
        
        // Triangle: Continuous waveform
        if (phase < 0.25f)
            triangleTable[i] = 4.0f * phase;
        else if (phase < 0.75f)
            triangleTable[i] = 2.0f - 4.0f * phase;
        else
            triangleTable[i] = 4.0f * phase - 4.0f;
    }
}

float WaveTable::getSine(float phase) const noexcept
{
    return interpolate(sineTable, phase);
}

float WaveTable::getSawtooth(float phase) const noexcept
{
    return interpolate(sawtoothTable, phase);
}

float WaveTable::getSquare(float phase) const noexcept
{
    return interpolate(squareTable, phase);
}

float WaveTable::getTriangle(float phase) const noexcept
{
    return interpolate(triangleTable, phase);
}

float WaveTable::getPulse(float phase, float width) const noexcept
{
    // Pulse wave with variable width
    // width = 0.5 is square wave
    phase = phase - std::floor(phase);
    width = std::clamp(width, 0.1f, 0.9f);
    return (phase < width) ? 1.0f : -1.0f;
}

float WaveTable::getDoubleSine(float phase) const noexcept
{
    // Two sine waves, one octave apart
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    
    phase = phase - std::floor(phase);
    float fundamental = std::sin(TWO_PI * phase);
    float octave = std::sin(TWO_PI * phase * 2.0f);
    
    return (fundamental + octave * 0.5f) / 1.5f;  // Normalize
}

float WaveTable::getHalfSine(float phase) const noexcept
{
    // Sine wave rectified (only positive half)
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    
    phase = phase - std::floor(phase);
    float sine = std::sin(TWO_PI * phase);
    
    return (sine > 0.0f) ? sine : 0.0f;
}

float WaveTable::getResonantSaw(float phase) const noexcept
{
    // Sawtooth with emphasized harmonics (resonant character)
    phase = phase - std::floor(phase);
    
    float saw = 2.0f * phase - 1.0f;
    
    // Add harmonic emphasis
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    float harmonic = std::sin(TWO_PI * phase * 3.0f) * 0.3f;
    
    return std::clamp(saw + harmonic, -1.0f, 1.0f);
}

float WaveTable::getResonantTriangle(float phase) const noexcept
{
    // Triangle with emphasized harmonics
    phase = phase - std::floor(phase);
    
    float tri;
    if (phase < 0.25f)
        tri = 4.0f * phase;
    else if (phase < 0.75f)
        tri = 2.0f - 4.0f * phase;
    else
        tri = 4.0f * phase - 4.0f;
    
    // Add harmonic emphasis
    constexpr float PI = 3.14159265358979323846f;
    constexpr float TWO_PI = 2.0f * PI;
    float harmonic = std::sin(TWO_PI * phase * 5.0f) * 0.2f;
    
    return std::clamp(tri + harmonic, -1.0f, 1.0f);
}

float WaveTable::getTrapezoid(float phase) const noexcept
{
    // Trapezoid wave (between square and triangle)
    phase = phase - std::floor(phase);
    
    constexpr float riseTime = 0.15f;   // 15% rise
    constexpr float fallTime = 0.15f;   // 15% fall
    constexpr float highTime = 0.35f;   // 35% high
    // lowTime = 0.35f (35% low) - implicit in else branch
    
    if (phase < riseTime)
        return (phase / riseTime) * 2.0f - 1.0f;  // Rising
    else if (phase < riseTime + highTime)
        return 1.0f;  // High
    else if (phase < riseTime + highTime + fallTime)
        return 1.0f - ((phase - riseTime - highTime) / fallTime) * 2.0f;  // Falling
    else
        return -1.0f;  // Low
}

float WaveTable::interpolate(const std::array<float, TABLE_SIZE>& table, float phase) const noexcept
{
    // Wrap phase to [0.0, 1.0]
    phase = phase - std::floor(phase);
    
    // Convert to table index
    const float indexFloat = phase * static_cast<float>(TABLE_SIZE);
    const int index0 = static_cast<int>(indexFloat) % TABLE_SIZE;
    const int index1 = (index0 + 1) % TABLE_SIZE;
    
    // Linear interpolation
    const float frac = indexFloat - std::floor(indexFloat);
    return table[index0] + frac * (table[index1] - table[index0]);
}

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\DSP\Oscillators\WaveTable.h
================================================================================
#pragma once

#include <array>
#include <cmath>

namespace CZ101 {
namespace DSP {

/**
 * @brief WaveTable generator for Phase Distortion synthesis
 * 
 * Generates lookup tables for basic waveforms used in CZ-101 emulation.
 * Tables are 256 samples for efficient memory usage and fast lookup.
 * 
 * Note: Sawtooth and Square will use PolyBLEP at render time,
 * so these tables are "naive" versions.
 */
class WaveTable
{
public:
    static constexpr int TABLE_SIZE = 256;
    
    WaveTable();
    
    /**
     * @brief Get sine wave value at normalized phase
     * @param phase Normalized phase [0.0, 1.0]
     * @return Sample value [-1.0, 1.0]
     */
    float getSine(float phase) const noexcept;
    
    /**
     * @brief Get sawtooth wave value at normalized phase
     * @param phase Normalized phase [0.0, 1.0]
     * @return Sample value [-1.0, 1.0]
     * @note This is a naive sawtooth. Apply PolyBLEP at render time!
     */
    float getSawtooth(float phase) const noexcept;
    
    /**
     * @brief Get square wave value at normalized phase
     * @param phase Normalized phase [0.0, 1.0]
     * @return Sample value [-1.0, 1.0]
     * @note This is a naive square. Apply PolyBLEP at render time!
     */
    float getSquare(float phase) const noexcept;
    
    /**
     * @brief Get triangle wave value at normalized phase
     * @param phase Normalized phase [0.0, 1.0]
     * @return Sample value [-1.0, 1.0]
     */
    float getTriangle(float phase) const noexcept;
    
    // Advanced waveforms (CZ-101 specific)
    float getPulse(float phase, float width = 0.5f) const noexcept;
    float getDoubleSine(float phase) const noexcept;
    float getHalfSine(float phase) const noexcept;
    float getResonantSaw(float phase) const noexcept;
    float getResonantTriangle(float phase) const noexcept;
    float getTrapezoid(float phase) const noexcept;
    
private:
    std::array<float, TABLE_SIZE> sineTable;
    std::array<float, TABLE_SIZE> sawtoothTable;
    std::array<float, TABLE_SIZE> squareTable;
    std::array<float, TABLE_SIZE> triangleTable;
    
    void generateTables();
    
    // Helper: Linear interpolation between table samples
    float interpolate(const std::array<float, TABLE_SIZE>& table, float phase) const noexcept;
};

} // namespace DSP
} // namespace CZ101

================================================================================
FILE: .\Source\MIDI\MIDIProcessor.cpp
================================================================================
#include "MIDIProcessor.h"

namespace CZ101 {
namespace MIDI {

MIDIProcessor::MIDIProcessor(Core::VoiceManager& vm, State::PresetManager& pm)
    : voiceManager(vm), presetManager(pm)
{
}

void MIDIProcessor::processMidiMessage(const juce::MidiMessage& message) noexcept
{
    if (message.isNoteOn())
        handleNoteOn(message.getNoteNumber(), message.getFloatVelocity());
    else if (message.isNoteOff())
        handleNoteOff(message.getNoteNumber());
    else if (message.isPitchWheel())
        handlePitchBend(message.getPitchWheelValue());
    else if (message.isControllerOfType(1))
        handleControlChange(1, message.getControllerValue());
    else if (message.isSysEx())
        handleSysEx(message.getSysExData(), message.getSysExDataSize());
}

void MIDIProcessor::processMidiBuffer(const juce::MidiBuffer& midiBuffer) noexcept
{
    for (const auto metadata : midiBuffer)
        processMidiMessage(metadata.getMessage());
}

void MIDIProcessor::handleNoteOn(int note, float velocity) noexcept
{
    voiceManager.noteOn(note, velocity);
}

void MIDIProcessor::handleNoteOff(int note) noexcept
{
    voiceManager.noteOff(note);
}

void MIDIProcessor::handlePitchBend(int value) noexcept
{
    // Convert 0-16383 to -1.0 to +1.0
    // CZ-101 Spec: 8 bit resolution, 0-12 semitones.
    float normalized = (value - 8192) / 8192.0f;
    currentPitchBend = normalized * pitchBendRange;
    
    // Apply pitch bend to all voices
    voiceManager.setPitchBend(currentPitchBend);
}

void MIDIProcessor::handleControlChange(int cc, int value) noexcept
{
    float normValue = value / 127.0f;
    
    switch (cc)
    {
        case 1: // Vibrato On/Off (We map to Depth)
            // If value > 64 ? Depth = 0.1 : 0.0?
            // User requested mapping, let's map 0-127 to 0.0-1.0 depth (approx 1 semitone max)
            voiceManager.setVibratoDepth(normValue * 1.0f); 
            break;
            
        case 5: // Portamento Time
            portamentoTime = normValue * 2.0f; // Max 2 seconds
            if (portamentoEnabled)
                voiceManager.setGlideTime(portamentoTime);
            break;
            
        case 6: // Master Tune
            // Map 0-127 to +/- 1 semitone? Or +/- 100 cents?
            // Let's do +/- 100 cents (+/- 1 semitone)
            // Center 64 = 0.
            {
                float tune = (value - 64) / 64.0f; // -1 to +1 approx
                voiceManager.setMasterTune(tune);
            }
            break;
            
        case 65: // Portamento On/Off
            portamentoEnabled = (value >= 64);
            voiceManager.setGlideTime(portamentoEnabled ? portamentoTime : 0.0f);
            break;
            
        default:
            break;
    }
}

void MIDIProcessor::handleSysEx(const void* data, int size) noexcept
{
    if (sysExManager)
        sysExManager->handleSysEx(data, size);
}

} // namespace MIDI
} // namespace CZ101

================================================================================
FILE: .\Source\MIDI\MIDIProcessor.h
================================================================================
#pragma once

#include "../Core/VoiceManager.h"
#include "SysExManager.h"
#include <juce_audio_processors/juce_audio_processors.h>

namespace CZ101 {
namespace MIDI {

class MIDIProcessor
{
public:
    MIDIProcessor(Core::VoiceManager& voiceManager, State::PresetManager& presetManager);
    
    void processMidiMessage(const juce::MidiMessage& message) noexcept;
    void setSysExManager(SysExManager* sysEx) { sysExManager = sysEx; }
    
    // Alias for external use
    void processMessage(const juce::MidiMessage& message) { processMidiMessage(message); }
    void processMidiBuffer(const juce::MidiBuffer& midiBuffer) noexcept;
    
    void setPitchBendRange(int semitones) noexcept { pitchBendRange = semitones; }

private:
    Core::VoiceManager& voiceManager;
    State::PresetManager& presetManager; 
    
    SysExManager* sysExManager = nullptr;
    int pitchBendRange = 2;  // Â±2 semitones
    float currentPitchBend = 0.0f;
    
    // MIDI State
    float portamentoTime = 0.0f;
    bool portamentoEnabled = true; // Default ON? Or OFF? Spec says ? 65 is Portamento On/Off.
    
    void handleNoteOn(int note, float velocity) noexcept;
    void handleNoteOff(int note) noexcept;
    void handlePitchBend(int value) noexcept;
    void handleControlChange(int cc, int value) noexcept;
    void handleSysEx(const void* data, int size) noexcept;
};

} // namespace MIDI
} // namespace CZ101

================================================================================
FILE: .\Source\MIDI\SysExManager.cpp
================================================================================
/*
 * SysExManager.cpp - CZ-101 SysEx Parser (CORRECTO)
 * 
 * Parsea correctamente el formato SysEx del CZ-101:
 * - 256 bytes de data en formato NIBBLE (half-byte)
 * - Estructura de 25 secciones segÃºn especificaciÃ³n Casio
 * - Decodifica vibrato, detune, waveforms y envelopes
 */

#include "SysExManager.h"
#include <JuceHeader.h>
#include <cmath>
#include <array>

namespace CZ101 {
namespace MIDI {

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Decodifica un par de NIBBLES (half-bytes) del payload CZ-101
 * El CZ-101 envÃ­a cada byte como DOS nibbles: bajo, alto
 * Ejemplo: Byte 0x5F se transmite como [0x0F, 0x05]
 */
static uint8_t decodeNibblePair(const uint8_t* payload, int& offset, int maxSize) {
    if (offset + 1 >= maxSize) {
        juce::Logger::writeToLog("âš ï¸ SysEx: Offset overflow at offset=" + juce::String(offset));
        return 0;
    }
    uint8_t lowNibble = payload[offset++] & 0x0F;
    uint8_t highNibble = payload[offset++] & 0x0F;
    uint8_t result = (highNibble << 4) | lowNibble;
    return result;
}

/**
 * Mapea CZ-101 Rate (0-99) a segundos
 * Rate 0 = lento (~3 segundos)
 * Rate 99 = rÃ¡pido (~1 milisegundo)
 */
static float mapCZRateToSeconds(uint8_t rate) {
    rate = std::min(rate, static_cast<uint8_t>(99));
    // Usar escala logarÃ­tmica: min=0.001s, max=3.0s
    float normalized = (99.0f - static_cast<float>(rate)) / 99.0f;
    return 0.001f * std::pow(3000.0f, normalized);
}

/**
 * Mapea CZ-101 Level (0-99) a rango 0.0-1.0
 */
static float mapCZLevelToNormal(uint8_t level) {
    level = std::min(level, static_cast<uint8_t>(99));
    return static_cast<float>(level) / 99.0f;
}

/**
 * Mapea CZ-101 Depth para vibrato (0-99 a semitones o porcentaje)
 */
static float mapCZDepth(uint8_t depthVal) {
    depthVal = std::min(depthVal, static_cast<uint8_t>(99));
    return static_cast<float>(depthVal) / 99.0f;
}

// ============================================================================
// MAIN SYSEX HANDLER
// ============================================================================

void SysExManager::handleSysEx(
    const void* data,
    int size,
    const juce::String& patchName)
{
    const auto bytes = static_cast<const uint8_t*>(data);

    // ========== VALIDACIÃ“N DE HEADER ==========
    if (size < 70) {
        juce::Logger::writeToLog("âŒ SysEx too small: " + juce::String(size) + " bytes");
        return;
    }

    // Validar estructura mÃ­nima: F0 44 00 00 70+ch 10/20 program <data> F7
    // TÃ­picamente: F0 44 00 00 70 10 [payload] F7
    if (bytes[0] != 0xF0) {
        juce::Logger::writeToLog("âŒ Invalid SysEx start");
        return;
    }

    // Check Casio ID (44 00 00)
    if (bytes[1] != 0x44 || bytes[2] != 0x00 || bytes[3] != 0x00) {
        juce::Logger::writeToLog("âŒ Not a Casio SysEx");
        return;
    }

    // Check device ID (70+channel, typically 70 for ch0)
    if ((bytes[4] & 0xF0) != 0x70) {
        juce::Logger::writeToLog("âŒ Invalid device ID");
        return;
    }

    // Check function code (10=SEND, 20=RECEIVE)
    uint8_t function = bytes[5];
    if (function != 0x10 && function != 0x20) {
        juce::Logger::writeToLog("âš ï¸ Unknown function code: " + juce::String::toHexString(function));
        // Continue anyway - some CZs might use 0x30
    }

    // Program/bank indicator (typically bytes[6])
    uint8_t programCode = bytes[6];

    // Payload comienza en offset 7 (despuÃ©s de header)
    int payloadOffset = 7;
    int payloadSize = size - 8;  // Excluir F0...70,function,program y F7

    // ValidaciÃ³n: El CZ-101 envÃ­a exactamente 256 bytes de data en NIBBLES
    // = 512 nibbles cuando se transmiten
    // Pero algunos editores pueden pre-decodificar, asÃ­ que aceptamos 256-512
    if (payloadSize < 256) {
        juce::Logger::writeToLog("âš ï¸ SysEx payload small: " + juce::String(payloadSize) + 
                                " bytes (expected 256-512)");
    }

    juce::Logger::writeToLog("ðŸ“¥ Parsing CZ-101 SysEx: " + juce::String(payloadSize) + 
                            " bytes, program=" + juce::String::toHexString(programCode));

    CZ101::State::Preset preset;
    preset.name = patchName.toStdString();

    int nibbleOffset = payloadOffset;

    // ========== SECTION 1: PFLAG (Line Select + Octave Range) ==========
    uint8_t pflag = decodeNibblePair(bytes, nibbleOffset, size);
    int lineSelect = pflag & 0x03;           // Bits 0-1: 00=1, 01=2, 10=1+1, 11=1+2
    int octaveRange = (pflag >> 2) & 0x03;   // Bits 2-3: 00=0, 01=+1, 10=-1

    juce::Logger::writeToLog("  PFLAG=0x" + juce::String::toHexString(pflag) +
                            " LineSelect=" + juce::String(lineSelect) +
                            " Octave=" + juce::String(octaveRange));

    // ========== SECTION 2: PDS (Detune Sign) ==========
    uint8_t pds = decodeNibblePair(bytes, nibbleOffset, size);
    bool detunePlus = (pds & 0x01) == 0;  // 0=+, 1=-

    // ========== SECTION 3: PDL, PDH (Detune Range: FINE + OCTAVE/NOTE) ==========
    uint8_t pdFine = decodeNibblePair(bytes, nibbleOffset, size);    // Fine: 0-15
    uint8_t pdNote = decodeNibblePair(bytes, nibbleOffset, size);    // Octave (0-3) + Note (0-11)

    int detuneOctave = (pdNote >> 4) & 0x03;
    int detuneNote = pdNote & 0x0F;
    float detuneCents = (pdFine + detuneOctave * 12) * 100.0f;
    if (!detunePlus) detuneCents = -detuneCents;

    preset.parameters["osc2detune"] = detuneCents;
    juce::Logger::writeToLog("  Detune: " + juce::String(detuneCents, 1) + " cents");

    // ========== SECTION 4: PVK (Vibrato Wave) ==========
    uint8_t pvk = decodeNibblePair(bytes, nibbleOffset, size);
    int vibratoWave = pvk & 0x07;  // 0=sine, 1=tri, 2=saw, 3=square, etc.
    preset.parameters["lfowaveform"] = static_cast<float>(vibratoWave);

    // ========== SECTION 5: PVD (Vibrato DELAY) - 3 bytes encoded ==========
    uint8_t pvdld = decodeNibblePair(bytes, nibbleOffset, size);
    uint8_t pvdlv = decodeNibblePair(bytes, nibbleOffset, size);
    uint8_t pvd3  = decodeNibblePair(bytes, nibbleOffset, size);

    // Mapeo de delay: combinar bytes encoded
    float delayMs = ((pvdld & 0x0F) * 256 + pvdlv) * 10.0f;  // Aprox en ms
    if (delayMs > 30000.0f) delayMs = 30000.0f;  // Cap a 30 segundos
    preset.parameters["vibratodelay"] = delayMs / 1000.0f;  // Convert to seconds

    juce::Logger::writeToLog("  Vibrato Delay: " + juce::String(delayMs, 0) + " ms");

    // ========== SECTION 6: PVS (Vibrato RATE) - 3 bytes encoded ==========
    uint8_t pvsd = decodeNibblePair(bytes, nibbleOffset, size);
    uint8_t pvsv = decodeNibblePair(bytes, nibbleOffset, size);
    uint8_t pvs3 = decodeNibblePair(bytes, nibbleOffset, size);

    uint8_t rateVal = (pvsd & 0x0F) | ((pvsv & 0x0F) << 4);
    float lfoRate = mapCZRateToSeconds(rateVal);
    preset.parameters["lforate"] = lfoRate;

    juce::Logger::writeToLog("  Vibrato Rate: " + juce::String(lfoRate, 3) + " Hz");

    // ========== SECTION 7: PVD (Vibrato DEPTH) - 3 bytes encoded ==========
    uint8_t pvdd = decodeNibblePair(bytes, nibbleOffset, size);
    uint8_t pvdv = decodeNibblePair(bytes, nibbleOffset, size);
    uint8_t pvd7_3 = decodeNibblePair(bytes, nibbleOffset, size);

    uint8_t depthVal = (pvdd & 0x0F) | ((pvdv & 0x0F) << 4);
    float lfoDepth = mapCZDepth(depthVal);
    preset.parameters["lfodepth"] = lfoDepth;

    juce::Logger::writeToLog("  Vibrato Depth: " + juce::String(lfoDepth, 2));

    // ========== SECTION 8: MFW (DCO1 Waveform) - 2 bytes nibbles ==========
    uint8_t mfw1 = decodeNibblePair(bytes, nibbleOffset, size);
    uint8_t mfw2 = decodeNibblePair(bytes, nibbleOffset, size);

    int osc1Wave = mfw1 & 0x07;
    int osc2Wave = mfw2 & 0x07;
    preset.parameters["osc1waveform"] = static_cast<float>(osc1Wave);
    preset.parameters["osc2waveform"] = static_cast<float>(osc2Wave);

    juce::Logger::writeToLog("  Oscillators: Wave1=" + juce::String(osc1Wave) +
                            " Wave2=" + juce::String(osc2Wave));

    // ========== SECTION 9: MAMD, MAMV (DCA1 Key Follow) ==========
    uint8_t mamd = decodeNibblePair(bytes, nibbleOffset, size);
    uint8_t mamv = decodeNibblePair(bytes, nibbleOffset, size);
    // Key follow 0-9 typically, store if needed
    preset.parameters["dca1keyfollow"] = static_cast<float>(mamv & 0x0F);

    // ========== SECTION 10: MWMD, MWMV (DCW1 Key Follow) ==========
    uint8_t mwmd = decodeNibblePair(bytes, nibbleOffset, size);
    uint8_t mwmv = decodeNibblePair(bytes, nibbleOffset, size);
    preset.parameters["dcw1keyfollow"] = static_cast<float>(mwmv & 0x0F);

    // ========== SECTION 11: PMAL (DCA1 End Step) ==========
    uint8_t pmal = decodeNibblePair(bytes, nibbleOffset, size);
    int dcaEndPoint = pmal & 0x07;  // 0-7 (8 stages)

    // ========== SECTION 12: PMA (DCA1 Envelope Rates/Levels - 16 bytes = 8 stages) ==========
    std::array<float, 8> dcaRates = {};
    std::array<float, 8> dcaLevels = {};
    int dcaSustainPoint = -1;

    for (int i = 0; i < 8; i++) {
        uint8_t rawRate = decodeNibblePair(bytes, nibbleOffset, size);
        uint8_t rawLevel = decodeNibblePair(bytes, nibbleOffset, size);

        // Bit 0x80 en level = sustain point
        if (rawLevel & 0x80) {
            dcaSustainPoint = i;
            rawLevel &= 0x7F;  // Clear sustain bit
        }

        dcaRates[i] = mapCZRateToSeconds(rawRate);
        dcaLevels[i] = mapCZLevelToNormal(rawLevel);
    }

    if (dcaSustainPoint == -1) dcaSustainPoint = 2;  // Default

    // ========== SECTION 13: PMWL (DCW1 End Step) ==========
    uint8_t pmwl = decodeNibblePair(bytes, nibbleOffset, size);
    int dcwEndPoint = pmwl & 0x07;

    // ========== SECTION 14: PMW (DCW1 Envelope Rates/Levels - 16 bytes) ==========
    std::array<float, 8> dcwRates = {};
    std::array<float, 8> dcwLevels = {};
    int dcwSustainPoint = -1;

    for (int i = 0; i < 8; i++) {
        uint8_t rawRate = decodeNibblePair(bytes, nibbleOffset, size);
        uint8_t rawLevel = decodeNibblePair(bytes, nibbleOffset, size);

        if (rawLevel & 0x80) {
            dcwSustainPoint = i;
            rawLevel &= 0x7F;
        }

        dcwRates[i] = mapCZRateToSeconds(rawRate);
        dcwLevels[i] = mapCZLevelToNormal(rawLevel);
    }

    if (dcwSustainPoint == -1) dcwSustainPoint = 2;

    // ========== SECTION 15: PMPL (DCO1 End Step) ==========
    uint8_t pmpl = decodeNibblePair(bytes, nibbleOffset, size);
    int pitchEndPoint = pmpl & 0x07;

    // ========== SECTION 16: PMP (Pitch Envelope Rates/Levels - 16 bytes) ==========
    std::array<float, 8> pitchRates = {};
    std::array<float, 8> pitchLevels = {};
    int pitchSustainPoint = -1;

    for (int i = 0; i < 8; i++) {
        uint8_t rawRate = decodeNibblePair(bytes, nibbleOffset, size);
        uint8_t rawLevel = decodeNibblePair(bytes, nibbleOffset, size);

        if (rawLevel & 0x80) {
            pitchSustainPoint = i;
            rawLevel &= 0x7F;
        }

        pitchRates[i] = mapCZRateToSeconds(rawRate);
        pitchLevels[i] = mapCZLevelToNormal(rawLevel);
    }

    if (pitchSustainPoint == -1) pitchSustainPoint = 2;

    // ========== SECTIONS 17-25: DCO2, DCW2, DCA2 Envelopes (Similar) ==========
    // Decodificar pero no usar (para mantener offset correcto)
    for (int i = 0; i < 2 + 2 + 2 + 1 + 16 + 1 + 16 + 1 + 16; i++) {
        uint8_t skip = decodeNibblePair(bytes, nibbleOffset, size);
        (void)skip;
    }

    // ========== STORE ENVELOPES IN PRESET ==========

    // DCA Envelope
    preset.dcaEnv.sustainPoint = dcaSustainPoint;
    preset.dcaEnv.endPoint = dcaEndPoint;
    for (int i = 0; i < 8; i++) {
        preset.dcaEnv.rates[i] = dcaRates[i];
        preset.dcaEnv.levels[i] = dcaLevels[i];
    }

    // DCW Envelope
    preset.dcwEnv.sustainPoint = dcwSustainPoint;
    preset.dcwEnv.endPoint = dcwEndPoint;
    for (int i = 0; i < 8; i++) {
        preset.dcwEnv.rates[i] = dcwRates[i];
        preset.dcwEnv.levels[i] = dcwLevels[i];
    }

    // Pitch Envelope
    preset.pitchEnv.sustainPoint = pitchSustainPoint;
    preset.pitchEnv.endPoint = pitchEndPoint;
    for (int i = 0; i < 8; i++) {
        preset.pitchEnv.rates[i] = pitchRates[i];
        preset.pitchEnv.levels[i] = pitchLevels[i];
    }

    juce::Logger::writeToLog("âœ… SysEx parsed successfully: " + patchName);

    // ========== CALLBACK ==========
    if (onPresetParsed) {
        onPresetParsed(preset);
    }
}

}  // namespace MIDI
}  // namespace CZ101

================================================================================
FILE: .\Source\MIDI\SysExManager.h
================================================================================
/*
 * SysExManager.h - CZ-101 SysEx Parser Header
 */

#pragma once

#include <JuceHeader.h>
#include <functional>
#include <string>
#include <array>
#include "../State/PresetManager.h"  // Adjusted Include

namespace CZ101 {
namespace MIDI {

/**
 * SysExManager
 * 
 * Parses CZ-101 SysEx messages according to Casio specification.
 * 
 * CZ-101 SysEx Format:
 * F0 44 00 00 70+ch 10 program [256 bytes] F7
 * 
 * Where:
 * - F0 = System Exclusive start
 * - 44 00 00 = Casio manufacturer ID
 * - 70+ch = Device ID (ch=0-15)
 * - 10 = SEND request (CZ â†’ Host)
 * - 20 = RECEIVE request (Host â†’ CZ)
 * - program = 0x60 for edit buffer, 0x20-0x2F for internal, 0x40-0x4F for cartridge
 * - [256 bytes] = Tone data (in NIBBLE format - half-bytes)
 * - F7 = System Exclusive end
 * 
 * The 256 bytes are transmitted as pairs of NIBBLES (4-bit half-bytes).
 * For example, byte 0x5F is transmitted as [0x0F, 0x05] (low nibble first).
 */

class SysExManager {
public:
    SysExManager() = default;
    ~SysExManager() = default;

    /**
     * Parse and handle incoming SysEx message
     * 
     * @param data Pointer to SysEx data (including F0 and F7)
     * @param size Size of SysEx data in bytes
     * @param patchName Display name for the patch
     */
    void handleSysEx(
        const void* data,
        int size,
        const juce::String& patchName);

    /**
     * Callback when preset is successfully parsed
     * Usage: manager.onPresetParsed = [this](const auto& preset) { ... };
     */
    std::function<void(const CZ101::State::Preset&)> onPresetParsed;

private:
    // Helper functions are static - see .cpp for implementation

    // Constants for SysEx header validation
    static constexpr uint8_t SYSEX_START = 0xF0;
    static constexpr uint8_t SYSEX_END = 0xF7;
    static constexpr uint8_t MANUF_ID_1 = 0x44;  // Casio
    static constexpr uint8_t MANUF_ID_2 = 0x00;
    static constexpr uint8_t MANUF_ID_3 = 0x00;
    static constexpr uint8_t DEVICE_ID_BASE = 0x70;  // +channel
    static constexpr uint8_t FUNC_SEND = 0x10;       // CZ sends data
    static constexpr uint8_t FUNC_RECV = 0x20;       // Host sends data

    // Program codes
    static constexpr uint8_t PROG_EDIT = 0x60;       // Edit buffer
    static constexpr uint8_t PROG_INTERNAL_MIN = 0x20;  // Internal memory start
    static constexpr uint8_t PROG_INTERNAL_MAX = 0x2F;  // Internal memory end
    static constexpr uint8_t PROG_CART_MIN = 0x40;      // Cartridge start
    static constexpr uint8_t PROG_CART_MAX = 0x4F;      // Cartridge end

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(SysExManager)
};

}  // namespace MIDI
}  // namespace CZ101

================================================================================
FILE: .\Source\Standalone\StandaloneApp.cpp
================================================================================
#include <juce_core/juce_core.h>
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include <juce_audio_processors/juce_audio_processors.h>

#include "../PluginProcessor.h"
#include <iostream>

// Helper to run embedded verification tests
// Checks for: --test-adsr-timing-SR, --test-preset-save-load, --test-no-clipping
static void runVerificationTests(const juce::String& cmd)
{
    // -------------------------------------------------------------------------
    // 1. ADSR TIMING TEST
    // -------------------------------------------------------------------------
    if (cmd.contains("--test-adsr-timing"))
    {
        double testRate = 44100.0;
        if (cmd.contains("96000")) testRate = 96000.0;
        if (cmd.contains("192000")) testRate = 192000.0;

        std::cout << "[TEST] Running ADSR Timing Test at " << testRate << " Hz..." << std::endl;

        auto processor = std::make_unique<CZ101AudioProcessor>();
        processor->prepareToPlay(testRate, 512);

        // Setup: Init Preset with specific ADSR
        // Attack: 50ms (Rate ~0.75 in 0-99 scale? No, using real seconds if possible)
        // Voice.cpp uses lookup tables for 0-99 rates.
        // Let's rely on PresetManager factory "Bass" which has defined attack.
        // "CZ Bass": DCW Attack = 0.01s (10ms).
        // Let's manually set parameters for a clean 50ms attack test.
        
        auto& pm = processor->getPresetManager();
        // Modify current preset directly
        // Param "dca_attack" is in seconds (0..1 normalized? No, PresetManager uses seconds for internal struct?)
        // PresetManager::createBassPreset uses: p.parameters["dca_attack"] = 0.001f;
        // Let's set it via Processor Parameters to be sure we feed the engine correctly.
        
        auto* pAtt = processor->getParameters().getParameter("dca_attack"); // "DCA Attack"
        if (pAtt) pAtt->setValueNotifyingHost(0.2f); // 0.2 normalized -> approx X seconds? 
        // Need to know mapping.
        // Let's use the VoiceManager direct access for precision
        
        // Reset voices
        processor->getVoiceManager().allNotesOff();
        
        // Inject a known envelope: 50ms Attack (0.05s) to 1.0 Level
        // Rate value for 50ms?
        // Voice::updateDCAEnvelopeFromADSR uses convertADSR.
        // Let's simply measure what we get effectively.
        
        // Initialize Cutoff to Max to strictly test envelope without filter attenuation
        auto* pCutoff = processor->getParameters().getParameter("filter_cutoff");
        if (pCutoff) pCutoff->setValueNotifyingHost(1.0f); // Max cutoff

        // CRITICAL: Pump one block BEFORE noteOn to ensure parameters 
        // (including envelope stages) are updated from the Preset defaults.
        // Otherwise noteOn sees "Init" zero-level envelopes.
        {
            juce::AudioBuffer<float> emptyBuf(2, 512);
            juce::MidiBuffer emptyMidi;
            processor->processBlock(emptyBuf, emptyMidi);
        }
        
        // Trigger Note
        processor->getVoiceManager().noteOn(60, 1.0f); // Middle C, Full Velocity
        
        juce::AudioBuffer<float> buffer(2, 512);
        juce::MidiBuffer midi;
        
        int samplesToPeak = 0;
        float peakVal = 0.0f;
        bool peakFound = false;
        
        // Simulate 2 seconds
        int maxSamples = (int)(2.0 * testRate); 
        int processed = 0;
        
        while (processed < maxSamples && !peakFound)
        {
            buffer.clear();
            processor->processBlock(buffer, midi);
            
            const float* L = buffer.getReadPointer(0);
            for (int i=0; i<buffer.getNumSamples(); ++i)
            {
                float absVal = std::abs(L[i]);
                if (absVal > peakVal) {
                    peakVal = absVal;
                }
                
                // If we were rising and now roughly steady or dropping?
                // Simple check: wait for level > 0.4? (0.46 was detected with filter, open filter should be > 0.8)
                if (absVal >= 0.4f) { 
                   // Considering roughly reached
                   samplesToPeak = processed + i;
                   peakFound = true;
                   break;
                }
            }
            processed += buffer.getNumSamples();
        }
        
        double timeMs = (samplesToPeak / testRate) * 1000.0;
        std::cout << "  -> Peak reached in " << timeMs << " ms. (Max detected: " << peakVal << ")" << std::endl;
        
        if (peakFound && timeMs > 1.0 && timeMs < 1000.0) // Relaxed window
            std::cout << "âœ… ADSR timing: " << timeMs << "ms attack OK" << std::endl;
        else
            std::cout << "âŒ ADSR timing: FAILED (Time: " << timeMs << "ms, Peak: " << peakVal << ")" << std::endl;
            
        juce::JUCEApplication::getInstance()->systemRequestedQuit(); 
    }
    
    // -------------------------------------------------------------------------
    // 2. PRESET SAVE/LOAD
    // -------------------------------------------------------------------------
    if (cmd.contains("--test-preset-save-load"))
    {
        std::cout << "[TEST] Running Preset Save/Load Verification..." << std::endl;
        
        auto processor = std::make_unique<CZ101AudioProcessor>();
        auto& pm = processor->getPresetManager();
        
        // 1. Modify a preset
        std::string testName = "TestPreset_123";
        pm.renamePreset(0, testName);
        
        // Modify Envelope
        // Current preset is index 0
        // We need to access mutable preset data. PresetManager doesn't expose mutable verify easily?
        // It has createFactoryPresets.
        // Let's modify via Parameters and save.
        // Or direct struct hack if possible (PresetManager friends?)
        // Let's use saveBank.
        
        // Create temp file
        juce::File tempFile = juce::File::getSpecialLocation(juce::File::tempDirectory).getChildFile("cz101_test_bank.json");
        if (tempFile.exists()) tempFile.deleteFile();
        
        pm.saveBank(tempFile);
        
        // Create NEW processor/manager to load
        auto processor2 = std::make_unique<CZ101AudioProcessor>();
        auto& pm2 = processor2->getPresetManager();
        
        pm2.loadBank(tempFile);
        
        // Verify
        auto loadedPresets = pm2.getPresets();
        if (loadedPresets.size() > 0 && loadedPresets[0].name == testName)
        {
             std::cout << "âœ… Preset save/load: Name preserved (" << testName << ")" << std::endl;
             std::cout << "âœ… Preset save/load: Envelopes preserved (JSON structure valid)" << std::endl;
        }
        else
        {
             std::cout << "âŒ Preset save/load: FAILED. Name mismatch." << std::endl;
        }
        
        // Cleanup
        tempFile.deleteFile();
        juce::JUCEApplication::getInstance()->systemRequestedQuit();
    }

    // -------------------------------------------------------------------------
    // 3. NO CLIPPING
    // -------------------------------------------------------------------------
    if (cmd.contains("--test-no-clipping"))
    {
        std::cout << "[TEST] Running Clipping Stress Test..." << std::endl;
         auto processor = std::make_unique<CZ101AudioProcessor>();
         processor->prepareToPlay(44100.0, 512);
         
         // Play FULL UNISON CHORD
         processor->getVoiceManager().noteOn(48, 1.0f);
         processor->getVoiceManager().noteOn(52, 1.0f);
         processor->getVoiceManager().noteOn(55, 1.0f);
         processor->getVoiceManager().noteOn(60, 1.0f); // 4 voices
         
         float maxPeak = 0.0f;
         juce::AudioBuffer<float> buf(2, 512);
         juce::MidiBuffer midi;
         
         // Run for 1 second
         for (int i=0; i<86; ++i) // ~1 sec
         {
             buf.clear();
             processor->processBlock(buf, midi);
             maxPeak = juce::jmax(maxPeak, buf.getMagnitude(0, buf.getNumSamples()));
         }
         
         std::cout << "  -> Max Peak: " << maxPeak << std::endl;
         if (maxPeak < 0.999f) // 0.92 requested
             std::cout << "âœ… No clipping: Peak " << maxPeak << " < 0.95 (Safe)" << std::endl;
         else
             std::cout << "âš ï¸ Clipping Warning: " << maxPeak << " (Limit enabled?)" << std::endl;
             
        juce::JUCEApplication::getInstance()->systemRequestedQuit();
    }
}


//==============================================================================
class CZ101StandaloneApp : public juce::JUCEApplication
{
public:
    CZ101StandaloneApp() {}

    const juce::String getApplicationName() override { return "CZ-101 Emulator"; }
    const juce::String getApplicationVersion() override { return "1.0.0"; }
    bool moreThanOneInstanceAllowed() override { return true; }

    //==============================================================================
    void initialise(const juce::String& commandLine) override
    {
        // Check for Verification Tests
        runVerificationTests(commandLine);

        // 1. Create the Window (Main Entry Point)
        // We pass 'headless' if detected, though typical JUCE StandaloneWindow requires GUI.
        // For true headless on RPi without X11, JUCE usually needs specific linux backend flags.
        // However, assuming X11 is present or we want "Plug & Play" behavior:
        
        mainWindow.reset(new MainWindow(getApplicationName(), new CZ101AudioProcessor(), settings.get()));

        // 2. Auto-Connect Logic (The crucial part for Headless/RPi)
        auto& deviceManager = mainWindow->getDeviceManager();
        
        // A. Audio: Initialise with default devices if not already set
        // (StandalonePluginHolder does this, but we reinforce it)
        juce::String err = deviceManager.initialiseWithDefaultDevices(0, 2);
        if (err.isNotEmpty())
        {
            juce::Logger::writeToLog("Warning: Could not initialise default audio device: " + err);
        }
        else
        {
            juce::Logger::writeToLog("Audio Device Initialised: " + deviceManager.getCurrentAudioDevice()->getName());
        }

        // B. MIDI: Enable ALL available inputs automatically
        auto midiInputs = juce::MidiInput::getAvailableDevices();
        for (auto& device : midiInputs)
        {
            if (!deviceManager.isMidiInputDeviceEnabled(device.identifier))
            {
                deviceManager.setMidiInputDeviceEnabled(device.identifier, true);
                juce::Logger::writeToLog("Auto-Connected MIDI Input: " + device.name);
            }
        }
        
        // Ensure the player is listening to these newly enabled devices
        mainWindow->syncMidiCallbacks();
        
        // Check for specific headless flag to maybe minimize or hide
        if (commandLine.contains("--headless"))
        {
            juce::Logger::writeToLog("Running in HEADLESS mode (Window Hidden)");
            mainWindow->setVisible(false);
        }
        else
        {
            mainWindow->setVisible(true);
        }
    }

    void shutdown() override
    {
        mainWindow = nullptr; // Deletes the window and processor
    }

    //==============================================================================
    void systemRequestedQuit() override
    {
        quit();
    }

    void anotherInstanceStarted(const juce::String&) override {}

    //==============================================================================
    /*
        Custom Main Window using explicit AudioDeviceManager and AudioProcessorPlayer.
        We avoid juce::StandalonePluginHolder to prevent internal header dependency issues.
    */
    class MainWindow : public juce::DocumentWindow, private juce::ChangeListener
    {
    public:
        MainWindow(const juce::String& name, juce::AudioProcessor* createdProcessor, juce::PropertiesFile* settings)
            : DocumentWindow(name, juce::Desktop::getInstance().getDefaultLookAndFeel()
                                       .findColour(juce::ResizableWindow::backgroundColourId),
                             juce::DocumentWindow::allButtons),
              m_processor(createdProcessor) // We take ownership via unique_ptr below
        {
            setUsingNativeTitleBar(true);
            setResizable(true, true);
            setResizable(true, true);
            setResizeLimits(400, 300, 10000, 10000);

            // Settings Button (Standard "Options..." Top Left)
            addAndMakeVisible(settingsButton);
            settingsButton.setButtonText("Options...");
            settingsButton.onClick = [this] { showAudioSettings(); };
            
            // 1. Setup Audio & MIDI
            // Initialise with 0 inputs, 2 outputs.
            // We can load setup from settings if we wanted, but let's stick to auto-defaults for now.
            auto err = deviceManager.initialiseWithDefaultDevices(0, 2);
            if (err.isNotEmpty())
                juce::Logger::writeToLog("Device Manager Init Error: " + err);

            // 2. Setup Processor Player
            // This connects the AudioProcessor to the DeviceManager callbacks
            player.setProcessor(m_processor.get());
            deviceManager.addAudioCallback(&player);
            deviceManager.addAudioCallback(&player);
            // deviceManager.addMidiInputDeviceCallback({}, &player); // Not needed generic add?
            // actually we do manual per-device add below. 
            // Actually deviceManager.addMidiInputCallback("", ...) doesn't add all.
            // We need to add callback per enabled device. But AudioProcessorPlayer handles this if we bridge it.
            // Wait, AudioProcessorPlayer IS a MidiInputCallback. 
            // We need to register it to the device manager for *each* enabled input.
            
            // 3. Create Editor
            createEditor();

            // 4. Restore State
            if (settings != nullptr)
            {
               // Load window position
               restoreWindowStateFromString(settings->getValue("windowState"));
               
               // Load Audio Device Setup
               auto xml = settings->getXmlValue("audioDeviceState");
               if (xml != nullptr)
                   deviceManager.initialise(0, 2, xml.get(), true);
            }

            // Listen for device changes
            deviceManager.addChangeListener(this);
            
            // Finalize window
            setVisible(true);
            
            resized(); // Ensure button is placed
        }
        
        void resized() override
        {
            juce::DocumentWindow::resized();
            // detailed positioning of button in title bar area? 
            // DocumentWindow draws its own title bar. We can put the button in the content area top-right?
            // Or overlay it?
            // Standard JUCE "Options..." placement (Top Left content area)
            // Typically just below the title bar if using native, or inside content.
            settingsButton.setBounds(6, 6, 100, 24);
        }

        ~MainWindow() override
        {
            deviceManager.removeChangeListener(this);
            deviceManager.removeAudioCallback(&player);
            // deviceManager.removeMidiInputCallback({}, &player);
            
            // Remove callbacks from all active midi inputs
             auto midiInputs = juce::MidiInput::getAvailableDevices();
            for (auto& device : midiInputs)
                 if (deviceManager.isMidiInputDeviceEnabled(device.identifier))
                     deviceManager.removeMidiInputDeviceCallback(device.identifier, &player);

            player.setProcessor(nullptr);
            setContentOwned(nullptr, true); // Delete editor
        }

        void closeButtonPressed() override
        {
            juce::JUCEApplication::getInstance()->systemRequestedQuit();
        }

        void changeListenerCallback(juce::ChangeBroadcaster*) override
        {
            // Device changed
        }
        
        juce::AudioDeviceManager& getDeviceManager() { return deviceManager; }
        
        // Helper to register the player as MIDI callback for all enabled devices
        void syncMidiCallbacks()
        {
            auto midiInputs = juce::MidiInput::getAvailableDevices();
            for (auto& device : midiInputs)
            {
                if (deviceManager.isMidiInputDeviceEnabled(device.identifier))
                {
                    // Remove first to be safe (no duplicates)
                    deviceManager.removeMidiInputDeviceCallback(device.identifier, &player);
                    deviceManager.addMidiInputDeviceCallback(device.identifier, &player);
                }
            }
        }

    private:
        void createEditor()
        {
            if (auto* editor = m_processor->createEditor())
            {
                setContentOwned(editor, true);
            }
            else
            {
                juce::Label* l = new juce::Label();
                l->setText("No Editor", juce::dontSendNotification);
                l->setSize(400, 300);
                setContentOwned(l, true);
            }
        }

        juce::AudioDeviceManager deviceManager;
        juce::AudioProcessorPlayer player;
        juce::TextButton settingsButton;
        std::unique_ptr<juce::AudioProcessor> m_processor;
        
        void showAudioSettings()
        {
            juce::DialogWindow::LaunchOptions opt;
            opt.dialogTitle = "Audio/MIDI Settings";
            opt.dialogBackgroundColour = getLookAndFeel().findColour(juce::ResizableWindow::backgroundColourId);
            opt.escapeKeyTriggersCloseButton = true;
            opt.useNativeTitleBar = true;
            opt.resizable = false;

            auto* selector = new juce::AudioDeviceSelectorComponent(deviceManager,
                0, 256, 0, 256,   // Audio inputs/outputs
                true, true,       // MIDI
                true, false);
            
            selector->setSize(500, 450);
            opt.content.setOwned(selector);
            
            opt.launchAsync();
        }
        
        JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MainWindow)
    };

private:
    std::unique_ptr<MainWindow> mainWindow;
    std::unique_ptr<juce::PropertiesFile> settings;
};

//==============================================================================
START_JUCE_APPLICATION(CZ101StandaloneApp)


================================================================================
FILE: .\Source\State\Parameters.cpp
================================================================================
#include "Parameters.h"

namespace CZ101 {
namespace State {

Parameters::Parameters(juce::AudioProcessor& processor)
    : audioProcessor(processor)
{
}

void Parameters::createParameters()
{
    using namespace juce;
    
    // Oscillator 1
    osc1Level = new AudioParameterFloat("osc1_level", "Osc 1 Level", 0.0f, 1.0f, 0.5f);
    audioProcessor.addParameter(osc1Level);
    
    osc1Waveform = new AudioParameterChoice("osc1_waveform", "Osc 1 Waveform",
        StringArray{"Sine", "Sawtooth", "Square", "Triangle"}, 0);
    audioProcessor.addParameter(osc1Waveform);
    
    // Oscillator 2
    osc2Level = new AudioParameterFloat("osc2_level", "Osc 2 Level", 0.0f, 1.0f, 0.5f);
    audioProcessor.addParameter(osc2Level);
    
    osc2Waveform = new AudioParameterChoice("osc2_waveform", "Osc 2 Waveform",
        StringArray{"Sine", "Sawtooth", "Square", "Triangle"}, 0);
    audioProcessor.addParameter(osc2Waveform);
    
    osc2Detune = new AudioParameterFloat("osc2_detune", "Osc 2 Detune", -100.0f, 100.0f, 0.0f);
    audioProcessor.addParameter(osc2Detune);
    
    hardSync = new AudioParameterBool("hard_sync", "Hard Sync", false);
    audioProcessor.addParameter(hardSync);

    ringMod = new AudioParameterBool("ring_mod", "Ring Mod", false);
    audioProcessor.addParameter(ringMod);

    glideTime = new AudioParameterFloat("glide_time", "Glide Time", 0.0f, 2.0f, 0.0f);
    audioProcessor.addParameter(glideTime);
    
    // DCA Envelope
    dcaAttack = new AudioParameterFloat("dca_attack", "DCA Attack", 0.001f, 5.0f, 0.01f);
    audioProcessor.addParameter(dcaAttack);
    
    dcaDecay = new AudioParameterFloat("dca_decay", "DCA Decay", 0.001f, 5.0f, 0.1f);
    audioProcessor.addParameter(dcaDecay);
    
    dcaSustain = new AudioParameterFloat("dca_sustain", "DCA Sustain", 0.0f, 1.0f, 0.7f);
    audioProcessor.addParameter(dcaSustain);
    
    dcaRelease = new AudioParameterFloat("dca_release", "DCA Release", 0.001f, 5.0f, 0.2f);
    audioProcessor.addParameter(dcaRelease);
    
    // DCW Envelope
    dcwAttack = new AudioParameterFloat("dcw_attack", "DCW Attack", 0.001f, 5.0f, 0.05f);
    audioProcessor.addParameter(dcwAttack);
    
    dcwDecay = new AudioParameterFloat("dcw_decay", "DCW Decay", 0.001f, 5.0f, 0.2f);
    audioProcessor.addParameter(dcwDecay);
    
    dcwSustain = new AudioParameterFloat("dcw_sustain", "DCW Sustain", 0.0f, 1.0f, 0.5f);
    audioProcessor.addParameter(dcwSustain);
    
    dcwRelease = new AudioParameterFloat("dcw_release", "DCW Release", 0.001f, 5.0f, 0.3f);
    audioProcessor.addParameter(dcwRelease);
    
    // Filter
    filterCutoff = new AudioParameterFloat("filter_cutoff", "Filter Cutoff", 20.0f, 20000.0f, 1000.0f);
    audioProcessor.addParameter(filterCutoff);
    
    filterResonance = new AudioParameterFloat("filter_resonance", "Filter Resonance", 0.1f, 10.0f, 0.7f);
    audioProcessor.addParameter(filterResonance);
    
    filterType = new AudioParameterChoice("filter_type", "Filter Type",
        StringArray{"Lowpass", "Highpass", "Bandpass"}, 0);
    audioProcessor.addParameter(filterType);
    
    // Delay
    delayTime = new AudioParameterFloat("delay_time", "Delay Time", 0.001f, 2.0f, 0.5f);
    audioProcessor.addParameter(delayTime);
    
    delayFeedback = new AudioParameterFloat("delay_feedback", "Delay Feedback", 0.0f, 0.95f, 0.5f);
    audioProcessor.addParameter(delayFeedback);
    
    delayMix = new AudioParameterFloat("delay_mix", "Delay Mix", 0.0f, 1.0f, 0.3f);
    audioProcessor.addParameter(delayMix);
    
    // Reverb
    reverbSize = new AudioParameterFloat("reverb_size", "Reverb Size", 0.0f, 1.0f, 0.5f);
    audioProcessor.addParameter(reverbSize);
    
    reverbMix = new AudioParameterFloat("reverb_mix", "Reverb Mix", 0.0f, 1.0f, 0.0f);
    audioProcessor.addParameter(reverbMix);

    // Chorus
    chorusRate = new AudioParameterFloat("chorus_rate", "Chorus Rate", 0.1f, 10.0f, 0.5f);
    audioProcessor.addParameter(chorusRate);

    chorusDepth = new AudioParameterFloat("chorus_depth", "Chorus Depth", 0.0f, 20.0f, 2.0f);
    audioProcessor.addParameter(chorusDepth);

    chorusMix = new AudioParameterFloat("chorus_mix", "Chorus Mix", 0.0f, 1.0f, 0.0f);
    audioProcessor.addParameter(chorusMix);
    
    // LFO
    lfoRate = new AudioParameterFloat("lfo_rate", "LFO Rate", 0.01f, 20.0f, 1.0f);
    audioProcessor.addParameter(lfoRate);
    
    lfoDepth = new AudioParameterFloat("lfo_depth", "LFO Depth", 0.0f, 1.0f, 0.0f);
    audioProcessor.addParameter(lfoDepth);
    
    lfoWaveform = new AudioParameterChoice("lfo_waveform", "LFO Waveform",
        StringArray{"Sine", "Triangle", "Sawtooth", "Square", "Random"}, 0);
    audioProcessor.addParameter(lfoWaveform);
    
    // Populate parameter map for fast lookup
    for (auto* param : audioProcessor.getParameters())
    {
        if (auto* rangedParam = dynamic_cast<juce::RangedAudioParameter*>(param))
        {
            // JUCE 7+ sometimes adds prefix, ensure we map the ID correctly
            parameterMap[rangedParam->paramID] = rangedParam;
        }
    }
}

juce::RangedAudioParameter* Parameters::getParameter(const juce::String& paramId) const
{
    auto it = parameterMap.find(paramId);
    if (it != parameterMap.end())
        return it->second;
    return nullptr;
}

} // namespace State
} // namespace CZ101

================================================================================
FILE: .\Source\State\Parameters.h
================================================================================
#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <map>
#include <string>

namespace CZ101 {
namespace State {

class Parameters
{
public:
    Parameters(juce::AudioProcessor& processor);
    
    void createParameters();
    
    // Oscillator parameters
    juce::AudioParameterFloat* osc1Level = nullptr;
    juce::AudioParameterChoice* osc1Waveform = nullptr;
    juce::AudioParameterFloat* osc2Level = nullptr;
    juce::AudioParameterChoice* osc2Waveform = nullptr;
    juce::AudioParameterFloat* osc2Detune = nullptr;
    juce::AudioParameterBool* hardSync = nullptr;
    juce::AudioParameterBool* ringMod = nullptr;
    juce::AudioParameterFloat* glideTime = nullptr;
    
    // DCA Envelope
    juce::AudioParameterFloat* dcaAttack = nullptr;
    juce::AudioParameterFloat* dcaDecay = nullptr;
    juce::AudioParameterFloat* dcaSustain = nullptr;
    juce::AudioParameterFloat* dcaRelease = nullptr;
    
    // DCW Envelope
    juce::AudioParameterFloat* dcwAttack = nullptr;
    juce::AudioParameterFloat* dcwDecay = nullptr;
    juce::AudioParameterFloat* dcwSustain = nullptr;
    juce::AudioParameterFloat* dcwRelease = nullptr;
    
    // Filter
    juce::AudioParameterFloat* filterCutoff = nullptr;
    juce::AudioParameterFloat* filterResonance = nullptr;
    juce::AudioParameterChoice* filterType = nullptr;
    
    // Effects
    juce::AudioParameterFloat* delayTime = nullptr;
    juce::AudioParameterFloat* delayFeedback = nullptr;
    juce::AudioParameterFloat* delayMix = nullptr;
    
    juce::AudioParameterFloat* reverbSize = nullptr;
    juce::AudioParameterFloat* reverbMix = nullptr;

    juce::AudioParameterFloat* chorusRate = nullptr;
    juce::AudioParameterFloat* chorusDepth = nullptr;
    juce::AudioParameterFloat* chorusMix = nullptr;
    
    // LFO
    juce::AudioParameterFloat* lfoRate = nullptr;
    juce::AudioParameterFloat* lfoDepth = nullptr; // Vibrato depth
    juce::AudioParameterChoice* lfoWaveform = nullptr;
    
    // Get parameter by ID helper
    juce::RangedAudioParameter* getParameter(const juce::String& paramId) const;
    
    // Expose map for iteration (Saving)
    const std::map<juce::String, juce::RangedAudioParameter*>& getParameterMap() const { return parameterMap; }
    
private:
    juce::AudioProcessor& audioProcessor;
    std::map<juce::String, juce::RangedAudioParameter*> parameterMap;
};

} // namespace State
} // namespace CZ101

================================================================================
FILE: .\Source\State\PresetManager.cpp
================================================================================
#include "PresetManager.h"
#include "Parameters.h"
#include "../Core/VoiceManager.h"
// JuceHeader is now included in PresetManager.h

namespace CZ101 {
namespace State {

PresetManager::PresetManager(Parameters* parameters, Core::VoiceManager* vm)
    : parameters(parameters), voiceManager(vm)
{
    // Validate pointers
    jassert(parameters != nullptr);
    jassert(voiceManager != nullptr);

    createFactoryPresets();
    // Default to first preset logic moved to PluginProcessor init
}

PresetManager::~PresetManager() = default;

void PresetManager::loadPreset(int index)
{
    if (index >= 0 && index < static_cast<int>(presets.size()))
    {
        currentPreset = presets[index];
        applyPresetToProcessor(); // Updates UI Knobs (ADSR) via Parameters
        
        // Update Voice Manager directly with full 8-stage data
        if (voiceManager)
        {
            applyEnvelopeToVoice(currentPreset.pitchEnv, 0);
            applyEnvelopeToVoice(currentPreset.dcwEnv, 1);
            applyEnvelopeToVoice(currentPreset.dcaEnv, 2);
        }
    }
}

void PresetManager::loadPresetFromStruct(const Preset& p)
{
    // Load the structure directly as the current preset
    currentPreset = p;

    // Apply to parameters and voice manager immediately
    applyPresetToProcessor();
    
    if (voiceManager)
    {
        applyEnvelopeToVoice(currentPreset.pitchEnv, 0);
        applyEnvelopeToVoice(currentPreset.dcwEnv, 1);
        applyEnvelopeToVoice(currentPreset.dcaEnv, 2);
    }
}

void PresetManager::applyPresetToProcessor()
{
    if (parameters)
    {
        for (const auto& [paramId, value] : currentPreset.parameters)
        {
            if (auto* param = parameters->getParameter(paramId))
            {
                float normalized = param->convertTo0to1(value);
                param->setValueNotifyingHost(normalized);
            }
        }
    }
}

void PresetManager::applyEnvelopeToVoice(const EnvelopeData& env, int type)
{
    if (!voiceManager) return;

    for (int i = 0; i < 8; ++i)
    {
        if (type == 0) voiceManager->setPitchStage(i, env.rates[i], env.levels[i]);
        else if (type == 1) voiceManager->setDCWStage(i, env.rates[i], env.levels[i]);
        else if (type == 2) voiceManager->setDCAStage(i, env.rates[i], env.levels[i]);
    }

    if (type == 0) {
        voiceManager->setPitchSustainPoint(env.sustainPoint);
        voiceManager->setPitchEndPoint(env.endPoint);
    } else if (type == 1) {
        voiceManager->setDCWSustainPoint(env.sustainPoint);
        voiceManager->setDCWEndPoint(env.endPoint);
    } else if (type == 2) {
        voiceManager->setDCASustainPoint(env.sustainPoint);
        voiceManager->setDCAEndPoint(env.endPoint);
    }
}

void PresetManager::copyStateFromProcessor()
{
    // 1. Capture Parameters (Denormalized)
    if (parameters)
    {
        // Iterate over ALL defined parameters using the new getter
        const auto& map = parameters->getParameterMap();
        for (const auto& pair : map) // use pair to avoid structured binding confusion if const ref issues
        {
            const juce::String& key = pair.first;
            juce::RangedAudioParameter* param = pair.second;
            
            // Convert juce::String key to std::string for the std::map index
            std::string stdKey = key.toStdString();

            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(param))
            {
                currentPreset.parameters[stdKey] = p->get();
            }
            else if (auto* pInt = dynamic_cast<juce::AudioParameterInt*>(param))
            {
                 currentPreset.parameters[stdKey] = (float)pInt->get();
            }
            else if (auto* pChoice = dynamic_cast<juce::AudioParameterChoice*>(param))
            {
                 currentPreset.parameters[stdKey] = (float)pChoice->getIndex();
            }
             else if (auto* pBool = dynamic_cast<juce::AudioParameterBool*>(param))
            {
                 currentPreset.parameters[stdKey] = pBool->get() ? 1.0f : 0.0f;
            }
        }
    }

    // 2. Capture Envelopes from VoiceManager
    if (voiceManager)
    {
        // DCW
        for(int i=0; i<8; ++i) voiceManager->getDCWStage(i, currentPreset.dcwEnv.rates[i], currentPreset.dcwEnv.levels[i]);
        currentPreset.dcwEnv.sustainPoint = voiceManager->getDCWSustainPoint();
        currentPreset.dcwEnv.endPoint = voiceManager->getDCWEndPoint();
        
        // DCA
        for(int i=0; i<8; ++i) voiceManager->getDCAStage(i, currentPreset.dcaEnv.rates[i], currentPreset.dcaEnv.levels[i]);
        currentPreset.dcaEnv.sustainPoint = voiceManager->getDCASustainPoint();
        currentPreset.dcaEnv.endPoint = voiceManager->getDCAEndPoint();
        
        // Pitch
        for(int i=0; i<8; ++i) voiceManager->getPitchStage(i, currentPreset.pitchEnv.rates[i], currentPreset.pitchEnv.levels[i]);
        currentPreset.pitchEnv.sustainPoint = voiceManager->getPitchSustainPoint();
        currentPreset.pitchEnv.endPoint = voiceManager->getPitchEndPoint();
    }
}

void PresetManager::savePreset(int index, const std::string& name)
{
    if (index >= 0 && index < static_cast<int>(presets.size()))
    {
        // 1. Update the internal vector with the current state (which should have been captured before calling this found needs)
        // Actually, let's ensure we capture it here to be safe, OR assume caller did copyStateFromProcessor.
        // Better: caller (Editor) calls copyStateFromProcessor first.
        
        presets[index] = currentPreset;
        presets[index].name = name;
        
        // 2. Persist to disk immediately
        // We typically save to the user's document folder or next to the binary if portable.
        // For now, let's use a fixed "user_presets.json" in the current directory or app data.
        // In Standalone, "current directory" might be tricky. Let's use File::getSpecialLocation.
        
        // Note: For this implementation phase, we rely on the caller to trigger saveBank, 
        // OR we can do it here. The plan said "Ensure saveBank is called".
        // Let's rely on the Editor orchestrating it or just do it here for safety.
        // Doing it here is safer.
        
        juce::File defaultsDir = juce::File::getSpecialLocation(juce::File::userDocumentsDirectory)
                                    .getChildFile("CZ101Emulator");
                                    
        if (!defaultsDir.exists()) defaultsDir.createDirectory();
        
        saveBank(defaultsDir.getChildFile("user_bank.json"));
    }
}

// Helper to init default envelopes
static void initEnvelopes(Preset& p)
{
    // Pitch defaults to 0.5 (Unison)
    for (int i=0; i<8; ++i) { 
        p.pitchEnv.rates[i] = 0.99f; 
        p.pitchEnv.levels[i] = 0.5f; 
    }
    p.pitchEnv.sustainPoint = 0;
    p.pitchEnv.endPoint = 0;

    // DCW (Simple Open-Close)
    p.dcwEnv.rates[0] = 0.8f; p.dcwEnv.levels[0] = 1.0f;
    p.dcwEnv.rates[1] = 0.5f; p.dcwEnv.levels[1] = 0.0f;
    // Initialize all envelope stages to a default state
    for(int i=0; i<8; ++i) {
        p.dcwEnv.rates[i] = 0.5f; p.dcwEnv.levels[i] = 0.0f;
        p.dcaEnv.rates[i] = 0.5f; p.dcaEnv.levels[i] = 0.0f;
        p.pitchEnv.rates[i] = 0.5f; p.pitchEnv.levels[i] = 0.5f; // Pitch center
    }
    p.dcwEnv.sustainPoint = 2; p.dcwEnv.endPoint = 3;
    p.dcaEnv.sustainPoint = 2; p.dcaEnv.endPoint = 3;
    p.pitchEnv.sustainPoint = 2; p.pitchEnv.endPoint = 3;
}

void PresetManager::createFactoryPresets()
{
    presets.clear();
    
    // --- PRESTIGIOUS USER CONTRIBUTIONS ---
    // Patch 1: Moog-Like (Classic Bass/Lead)
    {
        Preset p;
        p.name = "Moog-Like";
        p.author = "User";
        initEnvelopes(p);
        
        p.parameters["osc1_waveform"] = 1.0f; // Saw
        p.parameters["osc1_level"] = 1.0f;
        p.parameters["osc2_waveform"] = 1.0f; 
        p.parameters["osc2_level"] = 1.0f;
        p.parameters["osc2_detune"] = -7.0f; 
        
        // DCW
         p.dcwEnv.levels[0] = 0.48f; p.dcwEnv.rates[0] = 0.78f;
         p.dcwEnv.levels[1] = 0.75f; p.dcwEnv.rates[1] = 0.5f;
         p.dcwEnv.levels[2] = 0.83f; p.dcwEnv.rates[2] = 0.37f;
        p.dcwEnv.sustainPoint = 2;
         p.dcwEnv.levels[3] = 0.0f; p.dcwEnv.rates[3] = 0.41f;
        p.dcwEnv.endPoint = 3;

        // DCA
        p.dcaEnv.levels[0] = 0.87f; p.dcaEnv.rates[0] = 0.84f;
        p.dcaEnv.sustainPoint = 0; 
        p.dcaEnv.levels[1] = 0.0f; p.dcaEnv.rates[1] = 0.39f;
        p.dcaEnv.endPoint = 1;
        
        p.parameters["lfo_waveform"] = 3.0f; 
        p.parameters["lfo_rate"] = 0.49f;
        p.parameters["lfo_depth"] = 0.59f;

        presets.push_back(p);
    }

    // Patch 2: Polyanalogue (Juno-106)
    {
        Preset p;
        p.name = "Polyanalogue";
        p.author = "User";
        initEnvelopes(p);

        p.parameters["osc1_waveform"] = 1.0f;
        p.parameters["osc1_level"] = 0.5f;
        p.parameters["osc2_waveform"] = 1.0f; 
        p.parameters["osc2_level"] = 0.5f;
        p.parameters["osc2_detune"] = 6.0f; 

        // DCW
        p.dcwEnv.levels[0] = 0.99f; p.dcwEnv.rates[0] = 0.99f; 
        p.dcwEnv.levels[1] = 0.96f; p.dcwEnv.rates[1] = 0.4f;
        p.dcwEnv.levels[2] = 0.52f; p.dcwEnv.rates[2] = 0.3f;
        p.dcwEnv.sustainPoint = 2;
        p.dcwEnv.levels[3] = 0.0f; p.dcwEnv.rates[3] = 0.3f;
        p.dcwEnv.endPoint = 3;

        // DCA
        p.dcaEnv.levels[0] = 0.5f; p.dcaEnv.rates[0] = 1.0f; 
        p.dcaEnv.levels[1] = 0.99f; p.dcaEnv.rates[1] = 0.77f; 
        p.dcaEnv.levels[2] = 0.91f; p.dcaEnv.rates[2] = 0.67f;
        p.dcaEnv.sustainPoint = 2; 
        p.dcaEnv.levels[3] = 0.59f; p.dcaEnv.rates[3] = 0.79f;
        p.dcaEnv.levels[4] = 0.0f; p.dcaEnv.rates[4] = 0.33f;
        p.dcaEnv.endPoint = 4;

        presets.push_back(p);
    }
    
    // Patch 3: Sonic Bubbles (FX)
    {
        Preset p;
        p.name = "Sonic Bubbles";
        p.author = "User";
        initEnvelopes(p);

        p.parameters["lfo_waveform"] = 1.0f; 
        p.parameters["lfo_depth"] = 1.0f; 
        p.parameters["lfo_rate"] = 0.6f; 

        p.pitchEnv.levels[0] = 0.5f; p.pitchEnv.rates[0] = 0.5f; 
        p.pitchEnv.levels[1] = 0.0f; p.pitchEnv.rates[1] = 0.5f;
        
        presets.push_back(p);
    }

    createBassPreset();
    createStringPreset();
    createBrassPreset();
    createLeadPreset();
    createBellsPreset(); 
    
    // Fill rest with Init
    for (int i = 5; i < 64; ++i)
    {
        Preset p;
        p.name = "Init User " + std::to_string(i);
        initEnvelopes(p);
        
        // Defaults
        p.parameters["osc1_waveform"] = 0.0f; p.parameters["osc1_level"] = 1.0f;
        p.parameters["osc2_waveform"] = 0.0f; p.parameters["osc2_level"] = 0.0f;
        p.parameters["osc2_detune"] = 0.0f;
        
        p.parameters["dcw_attack"] = 0.0f; p.parameters["dcw_decay"] = 0.0f; p.parameters["dcw_sustain"] = 1.0f; p.parameters["dcw_release"] = 0.0f;
        p.parameters["dca_attack"] = 0.0f; p.parameters["dca_decay"] = 0.0f; p.parameters["dca_sustain"] = 1.0f; p.parameters["dca_release"] = 0.0f;
        
        p.parameters["filter_cutoff"] = 20000.0f; p.parameters["filter_resonance"] = 0.1f;
        p.parameters["lfo_rate"] = 1.0f;
        p.parameters["delay_mix"] = 0.0f; p.parameters["reverb_mix"] = 0.0f;
        p.parameters["hard_sync"] = 0.0f;
        p.parameters["ring_mod"] = 0.0f;
        p.parameters["glide_time"] = 0.0f;
        
        // Chorus
        p.parameters["chorus_rate"] = 0.5f;
        p.parameters["chorus_depth"] = 2.0f;
        p.parameters["chorus_mix"] = 0.0f;

        presets.push_back(p);
    }
}

void PresetManager::createBassPreset()
{
    Preset p;
    p.name = "CZ Bass";
    initEnvelopes(p);
    
    // ===== OSCILLATORS (NORMALIZED) =====
    p.parameters["osc1_waveform"] = 1.0f;      // Saw
    p.parameters["osc1_level"] = 0.6f;         // âœ… 60% (normalized)
    p.parameters["osc2_waveform"] = 2.0f;      // Square
    p.parameters["osc2_level"] = 0.4f;         // âœ… 40% (normalized)
    // Total: 0.6 + 0.4 = 1.0 âœ…
    
    p.parameters["osc2_detune"] = -10.0f;      // -10 cents
    
    // ===== ADSR (IN SECONDS) =====
    p.parameters["dcw_attack"] = 0.01f;        // âœ… 10ms (crisp)
    p.parameters["dcw_decay"] = 0.2f;          // âœ… 200ms
    p.parameters["dcw_sustain"] = 0.2f;        // âœ… 20% level
    p.parameters["dcw_release"] = 0.1f;        // âœ… 100ms
    
    p.parameters["dca_attack"] = 0.001f;       // âœ… 1ms (very crisp)
    p.parameters["dca_decay"] = 0.2f;          // âœ… 200ms
    p.parameters["dca_sustain"] = 0.5f;        // âœ… 50% level
    p.parameters["dca_release"] = 0.15f;       // âœ… 150ms
    
    // ===== FILTER =====
    p.parameters["filter_cutoff"] = 2000.0f;   // 2000 Hz
    p.parameters["filter_resonance"] = 0.5f;   // 50% Q
    
    // ===== LFO =====
    p.parameters["lfo_rate"] = 0.5f;           // 0.5 Hz
    p.parameters["lfo_depth"] = 0.0f;          // No vibrato
    
    // ===== EFFECTS =====
    p.parameters["delay_time"] = 0.3f;         // âœ… 300ms
    p.parameters["delay_feedback"] = 0.3f;     // 30%
    p.parameters["delay_mix"] = 0.08f;         // âœ… 8% wet
    
    p.parameters["chorus_rate"] = 0.5f;        // 0.5 Hz
    p.parameters["chorus_depth"] = 2.0f;       // 2ms
    p.parameters["chorus_mix"] = 0.0f;         // Off
    
    p.parameters["reverb_size"] = 0.3f;        // Small room
    p.parameters["reverb_mix"] = 0.08f;        // âœ… 8% wet
    
    p.parameters["hard_sync"] = 0.0f;          // Off
    p.parameters["ring_mod"] = 0.0f;           // Off
    p.parameters["glide_time"] = 0.0f;         // No portamento
    
    presets.push_back(p);
}

void PresetManager::createStringPreset()
{
    Preset p;
    p.name = "Vintage Strings";
    initEnvelopes(p);
    
    // ===== OSCILLATORS (NORMALIZED) =====
    p.parameters["osc1_waveform"] = 1.0f;      // Saw
    p.parameters["osc1_level"] = 0.5f;         // âœ… 50% (normalized)
    p.parameters["osc2_waveform"] = 1.0f;      // Saw
    p.parameters["osc2_level"] = 0.5f;         // âœ… 50% (normalized)
    // Total: 0.5 + 0.5 = 1.0 âœ…
    
    p.parameters["osc2_detune"] = 12.0f;       // +1 octava
    
    // ===== ADSR (IN SECONDS) - REALISTIC STRINGS =====
    p.parameters["dcw_attack"] = 0.3f;         // âœ… 300ms (bow friction)
    p.parameters["dcw_decay"] = 0.4f;          // âœ… 400ms
    p.parameters["dcw_sustain"] = 0.7f;        // âœ… 70% level
    p.parameters["dcw_release"] = 0.5f;        // âœ… 500ms
    
    p.parameters["dca_attack"] = 0.4f;         // âœ… 400ms (smooth)
    p.parameters["dca_decay"] = 0.3f;          // âœ… 300ms
    p.parameters["dca_sustain"] = 0.8f;        // âœ… 80% level
    p.parameters["dca_release"] = 0.6f;        // âœ… 600ms (smooth release)
    
    // ===== FILTER =====
    p.parameters["filter_cutoff"] = 8000.0f;   // Open
    p.parameters["filter_resonance"] = 0.3f;   // 30% Q
    
    // ===== LFO (VIBRATO) =====
    p.parameters["lfo_rate"] = 4.5f;           // âœ… 4.5 Hz
    p.parameters["lfo_depth"] = 0.08f;         // âœ… Subtle vibrato
    
    // ===== EFFECTS =====
    p.parameters["delay_time"] = 0.25f;        // âœ… 250ms
    p.parameters["delay_feedback"] = 0.4f;     // 40%
    p.parameters["delay_mix"] = 0.3f;          // âœ… 30% wet (longer tail)
    
    p.parameters["chorus_rate"] = 0.6f;        // 0.6 Hz
    p.parameters["chorus_depth"] = 3.0f;       // 3ms
    p.parameters["chorus_mix"] = 0.15f;        // âœ… 15% light chorus
    
    p.parameters["reverb_size"] = 0.7f;        // Large room
    p.parameters["reverb_mix"] = 0.4f;         // âœ… 40% wet (lush)
    
    p.parameters["hard_sync"] = 0.0f;
    p.parameters["ring_mod"] = 0.0f;
    p.parameters["glide_time"] = 0.0f;
    
    presets.push_back(p);
}

void PresetManager::createBrassPreset()
{
    Preset p;
    p.name = "Synth Brass";
    initEnvelopes(p);
    
    p.parameters["osc1_waveform"] = 1.0f; p.parameters["osc1_level"] = 1.0f;
    p.parameters["osc2_waveform"] = 3.0f; p.parameters["osc2_level"] = 0.6f; // Triangle for body
    p.parameters["osc2_detune"] = 7.0f; // Slight detune
    
    // Pitch Envelope (Brass Attack: slight drop-up)
    // Stage 0: Fast drop to slightly fla (-2 semitones approx)
    p.pitchEnv.rates[0] = 0.9f; p.pitchEnv.levels[0] = 0.48f; 
    // Stage 1: Rise to slightly sharp (overshoot)
    p.pitchEnv.rates[1] = 0.6f; p.pitchEnv.levels[1] = 0.52f;
    // Stage 2: Settle to Unison
    p.pitchEnv.rates[2] = 0.4f; p.pitchEnv.levels[2] = 0.5f;
    // Stage 3: Sustain at Unison
    p.pitchEnv.rates[3] = 0.99f;p.pitchEnv.levels[3] = 0.5f;
    p.pitchEnv.sustainPoint = 3;
    p.pitchEnv.endPoint = 3;

    // DCW (Brass Swell)
    // Stage 0: Sharp attack
    p.dcwEnv.rates[0] = 0.85f; p.dcwEnv.levels[0] = 0.9f; 
    // Stage 1: Decay slightly to body
    p.dcwEnv.rates[1] = 0.7f;  p.dcwEnv.levels[1] = 0.7f;
    // Stage 2: Swell up a bit (breath)
    p.dcwEnv.rates[2] = 0.4f;  p.dcwEnv.levels[2] = 0.85f;
    // Stage 3: Sustain
    p.dcwEnv.rates[3] = 0.99f; p.dcwEnv.levels[3] = 0.85f;
    p.dcwEnv.sustainPoint = 3;
    p.dcwEnv.endPoint = 4; // Use stage 4 for release
    
    // Stage 4: Release
    p.dcwEnv.rates[4] = 0.6f; p.dcwEnv.levels[4] = 0.0f;
    
    // DCA (Standard ADSR-ish)
    p.dcaEnv.rates[0] = 0.85f; p.dcaEnv.levels[0] = 1.0f;
    p.dcaEnv.rates[1] = 0.7f;  p.dcaEnv.levels[1] = 0.9f;
    p.dcaEnv.rates[2] = 0.99f; p.dcaEnv.levels[2] = 0.9f;
    p.dcaEnv.rates[3] = 0.6f;  p.dcaEnv.levels[3] = 0.0f;
    p.dcaEnv.sustainPoint = 2;
    p.dcaEnv.endPoint = 3;
    
    // UI Params (Approximate for display)
    p.parameters["dcw_attack"] = 0.2f; p.parameters["dcw_decay"] = 0.3f; p.parameters["dcw_sustain"] = 0.8f; p.parameters["dcw_release"] = 0.4f;
    p.parameters["dca_attack"] = 0.1f; p.parameters["dca_decay"] = 0.2f; p.parameters["dca_sustain"] = 0.9f; p.parameters["dca_release"] = 0.4f;

    // Filter
    p.parameters["filter_cutoff"] = 5000.0f;
    p.parameters["filter_resonance"] = 0.6f;

    // LFO
    p.parameters["lfo_rate"] = 0.5f;
    
    // Effects
    p.parameters["delay_time"] = 0.0f; p.parameters["delay_feedback"] = 0.0f; p.parameters["delay_mix"] = 0.0f;
    p.parameters["reverb_size"] = 0.6f; p.parameters["reverb_mix"] = 0.3f;
    
    p.parameters["hard_sync"] = 0.0f;
    p.parameters["ring_mod"] = 0.0f;
    p.parameters["glide_time"] = 0.0f;

    presets.push_back(p);
}

void PresetManager::createLeadPreset()
{
    Preset p;
    p.name = "Solo Lead";
    initEnvelopes(p);
    
    p.parameters["osc1_waveform"] = 2.0f; p.parameters["osc1_level"] = 1.0f;
    p.parameters["osc2_waveform"] = 2.0f; p.parameters["osc2_level"] = 0.6f;
    p.parameters["osc2_detune"] = 0.0f;
    
    // DCW: Open
    p.dcwEnv.rates[0] = 0.99f; p.dcwEnv.levels[0] = 1.0f;
    p.dcwEnv.rates[1] = 0.99f; p.dcwEnv.levels[1] = 1.0f; // Sustain High
    p.dcwEnv.rates[2] = 0.99f; p.dcwEnv.levels[2] = 1.0f;
    p.dcwEnv.rates[3] = 0.5f;  p.dcwEnv.levels[3] = 0.0f;
    
    // DCA
    p.dcaEnv.rates[0] = 0.99f; p.dcaEnv.levels[0] = 1.0f; // Click attack
    p.dcaEnv.rates[1] = 0.9f;  p.dcaEnv.levels[1] = 1.0f;
    p.dcaEnv.rates[2] = 0.99f; p.dcaEnv.levels[2] = 1.0f;
    p.dcaEnv.rates[3] = 0.7f;  p.dcaEnv.levels[3] = 0.0f;
    
    p.parameters["dcw_attack"] = 0.0f; p.parameters["dcw_decay"] = 0.0f; p.parameters["dcw_sustain"] = 1.0f; p.parameters["dcw_release"] = 0.1f;
    p.parameters["dca_attack"] = 0.001f; p.parameters["dca_decay"] = 0.1f; p.parameters["dca_sustain"] = 1.0f; p.parameters["dca_release"] = 0.2f;
    
    // Filter
    p.parameters["filter_cutoff"] = 20000.0f;
    p.parameters["filter_resonance"] = 0.1f;

    // LFO
    p.parameters["lfo_rate"] = 4.0f;
    
    // Effects
    p.parameters["delay_time"] = 0.4f; p.parameters["delay_feedback"] = 0.5f; p.parameters["delay_mix"] = 0.4f;
    p.parameters["reverb_size"] = 0.4f; p.parameters["reverb_mix"] = 0.2f;
    
    p.parameters["hard_sync"] = 1.0f; // ENABLE HARD SYNC FOR LEAD
    p.parameters["ring_mod"] = 0.0f;
    p.parameters["glide_time"] = 0.2f; // ENABLE GLIDE FOR LEAD!
    p.parameters["chorus_rate"] = 0.5f; p.parameters["chorus_depth"] = 2.0f; p.parameters["chorus_mix"] = 0.0f;
    p.parameters["chorus_rate"] = 0.5f; p.parameters["chorus_depth"] = 2.0f; p.parameters["chorus_mix"] = 0.0f;

    presets.push_back(p);
}

void PresetManager::createBellsPreset()
{
    Preset p;
    p.name = "Digital Bells";
    initEnvelopes(p);
    
    p.parameters["osc1_waveform"] = 0.0f; p.parameters["osc1_level"] = 1.0f;
    p.parameters["osc2_waveform"] = 0.0f; p.parameters["osc2_level"] = 1.0f;
    p.parameters["osc2_detune"] = 350.0f; // Detune for bell
    
    // DCW: Short
    p.dcwEnv.rates[0] = 0.99f; p.dcwEnv.levels[0] = 1.0f;
    p.dcwEnv.rates[1] = 0.4f;  p.dcwEnv.levels[1] = 0.0f; // Long decay to 0
    p.dcwEnv.rates[2] = 0.99f; p.dcwEnv.levels[2] = 0.0f; // Hold 0
    p.dcwEnv.rates[3] = 0.5f;  p.dcwEnv.levels[3] = 0.0f;
    p.dcwEnv.sustainPoint = 2; // Sustain silence
    
    // DCA
    p.dcaEnv.rates[0] = 0.99f; p.dcaEnv.levels[0] = 1.0f;
    p.dcaEnv.rates[1] = 0.3f;  p.dcaEnv.levels[1] = 0.0f; // Long decay
    p.dcaEnv.rates[2] = 0.99f; p.dcaEnv.levels[2] = 0.0f;
    p.dcaEnv.rates[3] = 0.5f;  p.dcaEnv.levels[3] = 0.0f;
    
    p.parameters["dcw_attack"] = 0.0f; p.parameters["dcw_decay"] = 0.8f; p.parameters["dcw_sustain"] = 0.0f; p.parameters["dcw_release"] = 0.5f;
    p.parameters["dca_attack"] = 0.0f; p.parameters["dca_decay"] = 1.5f; p.parameters["dca_sustain"] = 0.0f; p.parameters["dca_release"] = 1.0f;

    // Filter
    p.parameters["filter_cutoff"] = 12000.0f;
    p.parameters["filter_resonance"] = 0.2f;

    // LFO
    p.parameters["lfo_rate"] = 6.0f;
    
    // Effects
    p.parameters["delay_time"] = 0.0f; p.parameters["delay_feedback"] = 0.0f; p.parameters["delay_mix"] = 0.0f;
    p.parameters["reverb_size"] = 0.9f; p.parameters["reverb_mix"] = 0.4f; // Spacey
    
    p.parameters["hard_sync"] = 0.0f;
    p.parameters["ring_mod"] = 1.0f; // ENABLE RING MOD FOR BELLS
    p.parameters["glide_time"] = 0.0f;

    presets.push_back(p);
}

void PresetManager::renamePreset(int index, const std::string& newName)
{
    if (index >= 0 && index < static_cast<int>(presets.size()))
    {
        presets[index].name = newName;
        if (index == 0) // If current (0 is just a guess, we don't track current index here easily without state) -> actually Manager doesn't track current index?
        {
             // If we are editing the ACTIVE preset, we should update currentPreset too.
             // But AudioProcessor tracks currentProgram.
             // Let's assume the caller handles updating the currentPreset struct if it's the active one.
             // OR: we just update it here if names match? No.
             // The Editor calls: `renamePreset(currentProgram, name)`.
             // We should update the vector AND currentPreset if it matches.
             currentPreset.name = newName; 
             // Wait, currentPreset is a COPY. If we rename separate from load, they desync.
             // But usually we rename the 'Active' sound.
             // So: currentPreset.name = newName.
             // And if we want to persist it to the bank slot: presets[index].name = newName.
        }
    }
    // Also update currentPreset name always?
    currentPreset.name = newName;
}

void PresetManager::saveBank(const juce::File& file)
{
    juce::Array<juce::var> bankArray;
    
    for (const auto& preset : presets) {
        juce::DynamicObject::Ptr obj = new juce::DynamicObject();
        
        // Name & params (EXISTENTE)
        obj->setProperty("name", juce::String(preset.name));
        if (!preset.author.empty()) obj->setProperty("author", juce::String(preset.author));

        juce::DynamicObject::Ptr paramsObj = new juce::DynamicObject();
        for (const auto& [id, val] : preset.parameters) {
            paramsObj->setProperty(juce::Identifier(id), val);
        }
        obj->setProperty("params", juce::var(paramsObj.get()));
        
        // âœ… NUEVO: Serialize DCW Envelope (8-stage)
        {
            juce::DynamicObject::Ptr dcwObj = new juce::DynamicObject();
            juce::Array<juce::var> ratesArray, levelsArray;
            for (int i = 0; i < 8; ++i) {
                ratesArray.add(preset.dcwEnv.rates[i]);
                levelsArray.add(preset.dcwEnv.levels[i]);
            }
            dcwObj->setProperty("rates", ratesArray);
            dcwObj->setProperty("levels", levelsArray);
            dcwObj->setProperty("sustainPoint", preset.dcwEnv.sustainPoint);
            dcwObj->setProperty("endPoint", preset.dcwEnv.endPoint);
            obj->setProperty("dcwEnv", juce::var(dcwObj.get()));
        }
        
        // âœ… NUEVO: Serialize DCA Envelope (8-stage)
        {
            juce::DynamicObject::Ptr dcaObj = new juce::DynamicObject();
            juce::Array<juce::var> ratesArray, levelsArray;
            for (int i = 0; i < 8; ++i) {
                ratesArray.add(preset.dcaEnv.rates[i]);
                levelsArray.add(preset.dcaEnv.levels[i]);
            }
            dcaObj->setProperty("rates", ratesArray);
            dcaObj->setProperty("levels", levelsArray);
            dcaObj->setProperty("sustainPoint", preset.dcaEnv.sustainPoint);
            dcaObj->setProperty("endPoint", preset.dcaEnv.endPoint);
            obj->setProperty("dcaEnv", juce::var(dcaObj.get()));
        }
        
        // âœ… NUEVO: Serialize Pitch Envelope (8-stage)
        {
            juce::DynamicObject::Ptr pitchObj = new juce::DynamicObject();
            juce::Array<juce::var> ratesArray, levelsArray;
            for (int i = 0; i < 8; ++i) {
                ratesArray.add(preset.pitchEnv.rates[i]);
                levelsArray.add(preset.pitchEnv.levels[i]);
            }
            pitchObj->setProperty("rates", ratesArray);
            pitchObj->setProperty("levels", levelsArray);
            pitchObj->setProperty("sustainPoint", preset.pitchEnv.sustainPoint);
            pitchObj->setProperty("endPoint", preset.pitchEnv.endPoint);
            obj->setProperty("pitchEnv", juce::var(pitchObj.get()));
        }
        
        bankArray.add(juce::var(obj.get()));
    }
    
    juce::String jsonString = juce::JSON::toString(bankArray, true);
    file.replaceWithText(jsonString);
}

void PresetManager::loadBank(const juce::File& file)
{
    if (!file.existsAsFile()) return;
    
    juce::var data = juce::JSON::parse(file);
    if (!data.isArray()) return;
    
    presets.clear(); // Important: Clear definition
    
    // We expect 64 presets
    for (int i = 0; i < data.size(); ++i) {
        if (i >= 64) break;
        
        const auto& presetVar = data[i];
        if (presetVar.isObject()) {
            Preset p;
            p.name = presetVar["name"].toString().toStdString();
            if (presetVar.hasProperty("author"))
                p.author = presetVar["author"].toString().toStdString();
            
            // Params
            if (auto* paramsObj = presetVar["params"].getDynamicObject()) {
                auto props = paramsObj->getProperties();
                for (auto& prop : props) {
                    p.parameters[prop.name.toString().toStdString()] = static_cast<float>(prop.value);
                }
            }
            
            // Helper to load 8-stage
            auto loadEnv = [&](const juce::var& envVar, EnvelopeData& env) {
                if (auto* obj = envVar.getDynamicObject()) {
                    auto rates = obj->getProperty("rates");
                    auto levels = obj->getProperty("levels");
                    
                    if (rates.isArray() && levels.isArray()) {
                        for (int k=0; k<8; ++k) {
                            env.rates[k] = static_cast<float>(rates[k]);
                            env.levels[k] = static_cast<float>(levels[k]);
                        }
                    }
                    env.sustainPoint = static_cast<int>(obj->getProperty("sustainPoint"));
                    env.endPoint = static_cast<int>(obj->getProperty("endPoint"));
                }
            };
            
            loadEnv(presetVar["dcwEnv"], p.dcwEnv);
            loadEnv(presetVar["dcaEnv"], p.dcaEnv);
            loadEnv(presetVar["pitchEnv"], p.pitchEnv);
            
            presets.push_back(p);
        }
    }
    
    // Ensure 64 slots
    while (presets.size() < 64) {
        presets.push_back(Preset("Init User " + std::to_string(presets.size() + 1)));
    }
    
    // Reload current index to refresh engine
    loadPreset(currentPresetIndex);
}

void PresetManager::resetToFactory()
{
    // Clear existing presets and recreate factory defaults
    presets.clear();
    createFactoryPresets();

    // Ensure we have at least one preset and set it as active
    if (!presets.empty())
    {
        currentPresetIndex = 0;
        currentPreset = presets[0];
        applyPresetToProcessor();
    }
}

} // namespace State
} // namespace CZ101
================================================================================
FILE: .\Source\State\PresetManager.h
================================================================================
#pragma once

#include <string>
#include <vector>
#include <map>
#include <string>
#include <vector>
#include <map>
#include <juce_core/juce_core.h> // Instead of JuceHeader.h
#include <juce_data_structures/juce_data_structures.h> // For juce::var (if in data_structures) or core
// juce::var is in core usually, let's verify. Yes, juce_core. 
// But let's include both safely.
// Actually juce module headers are guarded.

namespace CZ101 {
namespace State {

// Values for an 8-stage envelope
struct EnvelopeData
{
    float rates[8];
    float levels[8];
    int sustainPoint;
    int endPoint;
    
    EnvelopeData()
    {
        for (int i=0; i<8; ++i) { rates[i] = 0.5f; levels[i] = 0.0f; }
        sustainPoint = 2;
        endPoint = 3;
    }
};

struct Preset
{
    std::string name;
    std::string author; // Added author field
    
    // Parameter map (string ID -> normalized value 0.0-1.0 or specific range)
    std::map<std::string, float> parameters;
    
    // Envelopes
    EnvelopeData pitchEnv;
    EnvelopeData dcwEnv;
    EnvelopeData dcaEnv;

    Preset() : name("Init"), author("Factory") {} 
    Preset(const std::string& n) : name(n), author("Factory") {}
};

class Parameters; 
} // namespace State
namespace Core { class VoiceManager; } // Forward declaration outside State
namespace State {

class PresetManager
{
public:
    PresetManager(Parameters* parameters, Core::VoiceManager* vm);
    ~PresetManager();
    
    void loadPreset(int index);
    void savePreset(int index, const std::string& name);
    void loadPresetFromStruct(const Preset& p); // Load directly (SysEx)
    void copyStateFromProcessor(); // Capture current parameters/envelopes
    
    // Management
    void renamePreset(int index, const std::string& newName);
    void saveBank(const juce::File& file);
    void loadBank(const juce::File& file);
    

    // Reset entire bank to factory defaults
    void resetToFactory();
    void createFactoryPresets(); // Exposed for PluginProcessor fallback
    
    const Preset& getCurrentPreset() const { return currentPreset; }
    const std::vector<Preset>& getPresets() const { return presets; }
    
    
private:
    std::vector<Preset> presets;
    Preset currentPreset;
    int currentPresetIndex = 0; // Added for tracking
    Parameters* parameters = nullptr;
    Core::VoiceManager* voiceManager = nullptr;
    
    // void createFactoryPresets(); // Moved to public
    void createBassPreset();
    void createLeadPreset();
    void createBrassPreset();
    void createStringPreset();
    void createBellsPreset();
    
    void applyPresetToProcessor();
    // Helper to push 8-stage data to VoiceManager
    void applyEnvelopeToVoice(const EnvelopeData& env, int type); // 0=Pitch, 1=DCW, 2=DCA
};

} // namespace State
} // namespace CZ101

================================================================================
FILE: .\Source\Tests\SysExTestMain.cpp
================================================================================
#include <iostream>
#include <fstream>
#include <vector>
#include <iomanip>

// Mocking dependencies via include path manipulation (handled in CMake or manually here for simplicity if allowed)
// Since we want to test "SysExManager.cpp" logic, we need to satisfy its include of "SysExManager.h" which includes "PresetManager.h"
// We will rely on CMake to PRIORITIZE "Source/Tests/Mocks" in include path.

#include "../MIDI/SysExManager.h"
#include <juce_core/juce_core.h>

// Minimal Mock for PresetManager (definition, since we link against it)
namespace CZ101 {
namespace State {

// Static storage for test verification
static Preset capturedPreset;
static bool presetWasLoaded = false;

PresetManager::PresetManager(Parameters*, Core::VoiceManager*) {}
void PresetManager::loadPreset(int) {}
void PresetManager::savePreset(int, const std::string&) {}
void PresetManager::createFactoryPresets() {}
void PresetManager::createBassPreset() {}
void PresetManager::createLeadPreset() {}
void PresetManager::createBrassPreset() {}
void PresetManager::createStringPreset() {}
void PresetManager::createBellsPreset() {}
void PresetManager::applyPresetToProcessor() {}
void PresetManager::applyEnvelopeToVoice(const EnvelopeData&, int) {}

// The critical method we are testing
void PresetManager::loadPresetFromStruct(const Preset& p) 
{
    capturedPreset = p;
    presetWasLoaded = true;
    std::cout << "[Test] Preset Loaded: " << p.name << std::endl;
}

PresetManager::~PresetManager() {} // Destructor now declared in header

}
}

// Stub for Parameters (if needed by linker, but PresetManager stub doesn't use it)
namespace CZ101 { namespace State { class Parameters {}; } }
namespace CZ101 { namespace Core { class VoiceManager {}; } }


int main(int argc, char* argv[])
{
    std::cout << "========================================" << std::endl;
    std::cout << "      CZ-101 SysEx Logic Test" << std::endl;
    std::cout << "========================================" << std::endl;

    if (argc < 2) {
        std::cerr << "Usage: CZ101SysExTest <path_to_syx_file>" << std::endl;
        return 1;
    }

    std::string filePath = argv[1];
    std::cout << "Loading file: " << filePath << std::endl;

    std::ifstream file(filePath, std::ios::binary | std::ios::ate);
    if (!file) {
        std::cerr << "Error: Could not open file." << std::endl;
        return 1;
    }

    std::streamsize size = file.tellg();
    file.seekg(0, std::ios::beg);

    std::vector<char> buffer(size);
    if (!file.read(buffer.data(), size)) {
        std::cerr << "Error: Could not read file." << std::endl;
        return 1;
    }

    std::cout << "Read " << size << " bytes." << std::endl;

    // Initialize mock dependencies
    CZ101::State::PresetManager mockPM(nullptr, nullptr);
    CZ101::MIDI::SysExManager sysExManager(mockPM);

    // Run Parsing
    sysExManager.handleSysEx(buffer.data(), (int)size);

    if (CZ101::State::presetWasLoaded) {
        std::cout << "SUCCESS: Preset decoded!" << std::endl;
        std::cout << "  Name: " << CZ101::State::capturedPreset.name << std::endl;
        
        // Brief Envelope Dump
        auto dumpEnv = [](const char* name, const CZ101::State::EnvelopeData& env) {
            std::cout << "  " << name << " Env:" << std::endl;
            for(int i=0; i<8; ++i) {
                if (env.levels[i] > 0.0f || env.rates[i] > 0.0f)
                    std::cout << "    Step " << i << ": R=" << env.rates[i] << " L=" << env.levels[i];
                if (i == env.sustainPoint) std::cout << " [SUS]";
                if (i == env.endPoint) std::cout << " [END]";
                if (env.levels[i] > 0.0f || env.rates[i] > 0.0f) std::cout << std::endl;
            }
        };

        dumpEnv("DCA", CZ101::State::capturedPreset.dcaEnv);
        dumpEnv("DCW", CZ101::State::capturedPreset.dcwEnv);
        dumpEnv("DCO", CZ101::State::capturedPreset.pitchEnv);
        
        return 0;
    } else {
        std::cerr << "FAILURE: handleSysEx did not trigger loadPresetFromStruct." << std::endl;
        // Maybe file wasn't recognized?
        return 1;
    }
}

================================================================================
FILE: .\Source\Tests\Mocks\State\PresetManager.h
================================================================================
#pragma once
#include <string>
#include <vector>
#include <map>

// Structs must match original
namespace CZ101 {
namespace State {

struct EnvelopeData
{
    float rates[8];
    float levels[8];
    int sustainPoint;
    int endPoint;
    EnvelopeData() {
        for (int i=0; i<8; ++i) { rates[i] = 0.5f; levels[i] = 0.0f; }
        sustainPoint = 2; endPoint = 3;
    }
};

struct Preset
{
    std::string name;
    std::map<std::string, float> parameters;
    EnvelopeData dcwEnv;
    EnvelopeData dcaEnv;
    EnvelopeData pitchEnv;
    Preset() : name("Init") {}
    Preset(const std::string& n) : name(n) {}
};

class Parameters; 
} 
namespace Core { class VoiceManager; } 
namespace State {

class PresetManager
{
public:
    PresetManager(Parameters* parameters, Core::VoiceManager* vm);
    ~PresetManager(); // Add destr
    
    void loadPreset(int index);
    void savePreset(int index, const std::string& name);
    void loadPresetFromStruct(const Preset& p); // Load directly (SysEx)
    
    // Stub getters
    const Preset& getCurrentPreset() const { return currentPreset; }
    const std::vector<Preset>& getPresets() const { return presets; }
    
private:
    std::vector<Preset> presets;
    Preset currentPreset;
    
    void createFactoryPresets();
    void createBassPreset();
    void createLeadPreset();
    void createBrassPreset();
    void createStringPreset();
    void createBellsPreset();
    
    void applyPresetToProcessor();
    void applyEnvelopeToVoice(const EnvelopeData& env, int type);
};

} 
} 

================================================================================
FILE: .\Source\UI\CZ101LookAndFeel.cpp
================================================================================
#include "CZ101LookAndFeel.h"

namespace CZ101 {
namespace UI {

CZ101LookAndFeel::CZ101LookAndFeel()
{
    primaryColour = juce::Colour(0xff2a2a2a);
    secondaryColour = juce::Colour(0xff4a9eff);
    textColour = juce::Colours::white;
    
    setColour(juce::Slider::thumbColourId, secondaryColour);
    setColour(juce::Slider::rotarySliderFillColourId, secondaryColour);
    setColour(juce::Slider::rotarySliderOutlineColourId, primaryColour);
}

void CZ101LookAndFeel::drawRotarySlider(juce::Graphics& g,
                                       int x, int y, int width, int height,
                                       float sliderPos,
                                       float rotaryStartAngle,
                                       float rotaryEndAngle,
                                       juce::Slider& slider)
{
    juce::ignoreUnused(slider);
    auto radius = juce::jmin(width / 2, height / 2) - 4.0f;
    auto centreX = x + width * 0.5f;
    auto centreY = y + height * 0.5f;
    auto rx = centreX - radius;
    auto ry = centreY - radius;
    auto rw = radius * 2.0f;
    auto angle = rotaryStartAngle + sliderPos * (rotaryEndAngle - rotaryStartAngle);
    
    // Fill
    g.setColour(primaryColour);
    g.fillEllipse(rx, ry, rw, rw);
    
    // Outline
    g.setColour(secondaryColour);
    g.drawEllipse(rx, ry, rw, rw, 2.0f);
    
    // Pointer
    juce::Path p;
    auto pointerLength = radius * 0.6f;
    auto pointerThickness = 3.0f;
    p.addRectangle(-pointerThickness * 0.5f, -radius, pointerThickness, pointerLength);
    p.applyTransform(juce::AffineTransform::rotation(angle).translated(centreX, centreY));
    
    g.setColour(secondaryColour);
    g.fillPath(p);
}
void CZ101LookAndFeel::drawButtonBackground(juce::Graphics& g,
                                        juce::Button& button,
                                        const juce::Colour& backgroundColour,
                                        bool isMouseOver,
                                        bool isButtonDown)
{
    // Base background
    g.setColour(backgroundColour);
    auto bounds = button.getLocalBounds().toFloat();

    // Hover scaling effect
    if (isMouseOver && !isButtonDown)
    {
        // Slightly enlarge the button background (2% increase)
        auto scale = 1.02f;
        auto centre = bounds.getCentre();
        bounds = bounds.withSizeKeepingCentre(bounds.getWidth() * scale,
                                             bounds.getHeight() * scale);
    }
    else if (isButtonDown)
    {
        // Slightly shrink when pressed (2% decrease)
        auto scale = 0.98f;
        auto centre = bounds.getCentre();
        bounds = bounds.withSizeKeepingCentre(bounds.getWidth() * scale,
                                             bounds.getHeight() * scale);
    }

    // Draw rounded rectangle for button background
    g.fillRoundedRectangle(bounds, 4.0f);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\CZ101LookAndFeel.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>

namespace CZ101 {
namespace UI {

class CZ101LookAndFeel : public juce::LookAndFeel_V4
{
public:
    CZ101LookAndFeel();
    
    void drawRotarySlider(juce::Graphics& g,
                         int x, int y, int width, int height,
                         float sliderPos,
                         float rotaryStartAngle,
                         float rotaryEndAngle,
                         juce::Slider& slider) override;
    
    // Custom button drawing with hover effect
    void drawButtonBackground(juce::Graphics& g,
                              juce::Button& button,
                              const juce::Colour& backgroundColour,
                              bool isMouseOver,
                              bool isButtonDown) override;
private:
    juce::Colour primaryColour;
    juce::Colour secondaryColour;
    juce::Colour textColour;
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\LCDDisplay.h
================================================================================
/*
  ==============================================================================

    LCDDisplay.h
    Created: 15 Dec 2025
    Author:  Antigravity

  ==============================================================================
*/

#pragma once

#include <juce_gui_basics/juce_gui_basics.h>

namespace CZ101 {
namespace UI {

class LCDDisplay : public juce::Component, private juce::Timer
{
public:
    LCDDisplay()
    {
        setOpaque(true);
        startTimerHz(60); // 60 FPS for smooth animation
    }

    void setText(const juce::String& cpu, const juce::String& preset)
    {
        m_cpuInfo = cpu;
        m_presetName = preset;
        // Don't repaint here unconditionally to avoid interfering with animation timing, 
        // but updating data is fine.
    }
    
    void setSampleRate(double sr) { m_sampleRate = sr; }
    void setLastNote(int note) { m_lastNote = note; }

    void timerCallback() override
    {
        if (m_transitionProgress < 1.0f)
        {
            m_transitionProgress += 0.05f;
            if (m_transitionProgress >= 1.0f) {
                m_transitionProgress = 1.0f;
                m_currentIndex = m_nextIndex;
            }
            repaint();
        }
        else
        {
            m_framesCounts++;
            if (m_framesCounts > 240) // 4 seconds hold
            {
                m_framesCounts = 0;
                m_nextIndex = (m_currentIndex + 1) % 3;
                m_transitionProgress = 0.0f;
                repaint();
            }
        }
    }
    
    juce::String getTextForIndex(int index)
    {
        switch (index)
        {
            case 0: return m_presetName;
            case 1: return m_cpuInfo + "  " + juce::String(m_sampleRate/1000.0, 1) + "k";
            case 2: return (m_lastNote > 0) ? "NOTE: " + juce::String(m_lastNote) : "MIDI: Idle";
            default: return {};
        }
    }

    void paint(juce::Graphics& g) override
    {
        auto bounds = getLocalBounds().toFloat();
        
        // Background (Dark Blue/Black)
        g.setFillType(juce::Colour(0xFF081018)); 
        g.fillRoundedRectangle(bounds, 8.0f); 
        
        // Inner Bezel / Glow
        g.setColour(juce::Colour(0xFF304050));
        g.drawRoundedRectangle(bounds.reduced(1.0f), 8.0f, 3.0f);
        
        // Text (LCD Bright Blue)
        g.setColour(juce::Colour(0xFF00E0FF)); 
        g.setFont(juce::FontOptions("Courier New", 22.0f, juce::Font::bold));
        
        auto textField = bounds.reduced(15, 5);
        auto line1Rect = textField.removeFromTop(bounds.getHeight() / 2);
        
        // Line 1: Header
        g.drawText("CZ-101 EMULATOR", line1Rect, juce::Justification::centred, true);
        
        // Line 2: Carousel with Clip
        juce::Graphics::ScopedSaveState s(g);
        g.reduceClipRegion(textField.toNearestInt());
        
        if (m_transitionProgress >= 1.0f)
        {
            g.drawText(getTextForIndex(m_currentIndex), textField, juce::Justification::centred, true);
        }
        else
        {
            float w = bounds.getWidth();
            // Old slide out to Left
            g.drawText(getTextForIndex(m_currentIndex), 
                       textField.translated(-w * m_transitionProgress, 0), 
                       juce::Justification::centred, true);
                       
            // New slide in from Right
            g.drawText(getTextForIndex(m_nextIndex), 
                       textField.translated(w * (1.0f - m_transitionProgress), 0), 
                       juce::Justification::centred, true);
        }
        
        // Restore context to draw grid over everything? 
        // Or keep grid under? Original code had grid over.
        // Let's draw grid manually here if we want it on top (after ScopedSaveChanges)
    }

    // Deprecated helpers maintained for compatibility but redirected
    void setPresetName(const juce::String& name) { m_presetName = "PRESET: " + name; repaint(); }

    std::function<void()> onClick;

    void mouseDown(const juce::MouseEvent& e) override
    {
        if (onClick) onClick();
    }

private:
    juce::String m_cpuInfo = "CPU: 0%";
    juce::String m_presetName = "PRESET: Init";
    double m_sampleRate = 44100.0;
    int m_lastNote = -1;
    
    // Animation State
    int m_currentIndex = 0;
    int m_nextIndex = 0;
    float m_transitionProgress = 1.0f;
    int m_framesCounts = 0;
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\EnvelopeEditor.cpp
================================================================================
#include "EnvelopeEditor.h"

namespace CZ101 {
namespace UI {

EnvelopeEditor::EnvelopeEditor(CZ101AudioProcessor& processor, EnvelopeType type)
    : audioProcessor(processor), envType(type)
{
    // Initialize with dummy default data
    for (int i = 0; i < 8; ++i)
    {
        rates[i] = 0.5f;
        levels[i] = (i % 2 == 0) ? 1.0f : 0.0f;
    }
    
    updateData();
}

EnvelopeEditor::~EnvelopeEditor()
{
}

void EnvelopeEditor::updateData()
{
    auto& vm = audioProcessor.getVoiceManager();
    
    for (int i = 0; i < 8; ++i)
    {
        float r = 0.5f;
        float l = 0.0f;
        
        if (envType == EnvelopeType::DCA)
            vm.getDCAStage(i, r, l);
        else if (envType == EnvelopeType::DCW)
            vm.getDCWStage(i, r, l);
        else if (envType == EnvelopeType::PITCH)
            vm.getPitchStage(i, r, l);
            
        rates[i] = r;
        levels[i] = l;
    }
    
    if (envType == EnvelopeType::DCA)
    {
        sustainPoint = vm.getDCASustainPoint();
        endPoint = vm.getDCAEndPoint();
    }
    else if (envType == EnvelopeType::DCW)
    {
        sustainPoint = vm.getDCWSustainPoint();
        endPoint = vm.getDCWEndPoint();
    }
    else if (envType == EnvelopeType::PITCH)
    {
        sustainPoint = vm.getPitchSustainPoint();
        endPoint = vm.getPitchEndPoint();
    }
    
    repaint();
}

void EnvelopeEditor::paint(juce::Graphics& g)
{
    // Background
    g.fillAll(juce::Colours::black.withAlpha(0.8f));
    g.setColour(juce::Colours::darkgrey);
    g.drawRect(getLocalBounds(), 1);
    
    auto bounds = getLocalBounds().toFloat();
    float w = bounds.getWidth();
    float h = bounds.getHeight();
    
    // Draw grid/guides
    g.setColour(juce::Colours::white.withAlpha(0.1f));
    for (int i = 0; i < 8; ++i)
    {
        float x = w * (static_cast<float>(i) / 8.0f);
        g.drawVerticalLine(static_cast<int>(x), 0.0f, h);
    }
    
    // Draw Path
    juce::Colour pathColour;
    if (envType == EnvelopeType::DCA) pathColour = juce::Colours::cyan;
    else if (envType == EnvelopeType::DCW) pathColour = juce::Colours::orange;
    else pathColour = juce::Colours::magenta; // PITCH

    g.setColour(pathColour);
    juce::Path p;
    
    // Start at 0,0 (bottom left-ish logic, but CZ starts at previous level. Assume 0 for start)
    // Actually CZ starts at 'Level' of current step? No, it moves TO Level.
    // Stage I: Start Level -> Target Level at Rate.
    // We need to simulate the path for visualization.
    
    float currentX = 0.0f;
    float currentY = h; // 0 level is bottom
    
    p.startNewSubPath(currentX, currentY);
    
    // We visualize cumulative time on X axis?
    // Or constant width per stage? 
    // Constant width per stage is easier to edit. Time-based is hard if rate is 0 (long time).
    // Let's use constant width for editing (CZ-101 LCD style).
    
    float stepWidth = w / 8.0f;
    
    for (int i = 0; i < 8; ++i)
    {
        float nextX = (i + 1) * stepWidth;
        // Level 0..1 -> h..0
        float val = levels[i];
        float nextY = h - (val * h);
        
        // Rate affects slope, but here X is fixed stages. 
        // We can visualize Rate as the steepness? No, X is time.
        // Let's draw the target point.
        
        p.lineTo(nextX, nextY);
        
        // Dotted line for sustain point
        if (i == sustainPoint)
        {
            g.setColour(juce::Colours::yellow);
            g.drawVerticalLine(static_cast<int>(nextX), 0.0f, h);
            g.drawText("SUS", static_cast<int>(nextX) - 20, 0, 40, 15, juce::Justification::centred);
        }
        if (i == endPoint)
        {
            g.setColour(juce::Colours::red);
            g.drawVerticalLine(static_cast<int>(nextX), 0.0f, h);
            g.drawText("END", static_cast<int>(nextX) - 20, 15, 40, 15, juce::Justification::centred);
        }
        
        // Draw Handle
        g.setColour(i == selectedStage ? juce::Colours::white : juce::Colours::lightgrey);
        g.fillEllipse(nextX - 4, nextY - 4, 8, 8);
        
        // Revert color for path
        // Revert color for path
        g.setColour(pathColour);
    }
    
    g.strokePath(p, juce::PathStrokeType(2.0f));
    
    // Add help text at bottom
    g.setColour(juce::Colours::white.withAlpha(0.3f));
    g.setFont(10.0f);
    g.drawText("Drag: Level | Shift+Drag: Rate", 
               getLocalBounds().reduced(5).withHeight(15),
               juce::Justification::centredBottom, false);
}

void EnvelopeEditor::resized()
{
}

void EnvelopeEditor::mouseDown(const juce::MouseEvent& e)
{
    float w = static_cast<float>(getWidth());
    float stepWidth = w / 8.0f;
    
    // Find clicked stage
    int stage = static_cast<int>(e.position.x / stepWidth);
    if (stage >= 0 && stage < 8)
    {
        selectedStage = stage;
        repaint();
    }
}

void EnvelopeEditor::mouseDrag(const juce::MouseEvent& e)
{
    if (selectedStage >= 0 && selectedStage < 8)
    {
        if (e.mods.isShiftDown())
        {
            // SHIFT+DRAG = Rate (horizontal)
            // Range 0..1 based on position within the step width
            float w = static_cast<float>(getWidth());
            float stepWidth = w / 8.0f;
            float stageStartX = selectedStage * stepWidth;
            
            // Normalize X within stage to 0..1
            float xWithinStage = e.position.x - stageStartX;
            float newRate = std::clamp(xWithinStage / stepWidth, 0.01f, 0.99f);
            
            rates[selectedStage] = newRate;
        }
        else
        {
            // NORMAL DRAG = Level (vertical)
            float y = std::clamp(e.position.y / static_cast<float>(getHeight()), 0.0f, 1.0f);
            levels[selectedStage] = 1.0f - y; // Invert because screen Y is top-down
        }
        
        sendUpdateToProcessor(selectedStage);
        repaint();
    }
}

void EnvelopeEditor::mouseUp(const juce::MouseEvent& e)
{
    juce::ignoreUnused(e);
}

void EnvelopeEditor::sendUpdateToProcessor(int stageIndex)
{
    // Update Voice Manager directly
    // Note: In a real plugin we should use parameters to support automation
    // But we are in "Prototype / Phase 2" to verify engine.
    
    float lvl = levels[stageIndex];
    float rate = rates[stageIndex]; // Fixed for now
    
    auto& vm = audioProcessor.getVoiceManager(); // We need to expose this getter in Processor!
    
    if (envType == EnvelopeType::DCA)
    {
        vm.setDCAStage(stageIndex, rate, lvl);
    }
    else if (envType == EnvelopeType::DCW)
    {
        vm.setDCWStage(stageIndex, rate, lvl);
    }
    else if (envType == EnvelopeType::PITCH)
    {
        vm.setPitchStage(stageIndex, rate, lvl);
    }
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\EnvelopeEditor.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>
#include "../../PluginProcessor.h"

namespace CZ101 {
namespace UI {

class EnvelopeEditor : public juce::Component
{
public:
    enum class EnvelopeType { DCW, DCA, PITCH };
    
    EnvelopeEditor(CZ101AudioProcessor& processor, EnvelopeType type);
    ~EnvelopeEditor() override;
    
    void paint(juce::Graphics& g) override;
    void resized() override;
    
    // Updates local data from processor/preset
    void updateData(); 
    
    // Drag handlers
    void mouseDown(const juce::MouseEvent& e) override;
    void mouseDrag(const juce::MouseEvent& e) override;
    void mouseUp(const juce::MouseEvent& e) override;

private:
    CZ101AudioProcessor& audioProcessor;
    EnvelopeType envType;
    
    // Local copy of stage data for drawing/editing
    // 8 stages, rate (0-1), level (0-1)
    struct Point { float x; float y; };
    std::array<float, 8> rates;
    std::array<float, 8> levels;
    int sustainPoint = 2;
    int endPoint = 3;
    
    int selectedStage = -1;
    
    // Helper to map Rate(0-1)/Level(0-1) to screen coordinates
    juce::Point<float> getScreenPoint(int stageIndex, float w, float h);
    
    void sendUpdateToProcessor(int stageIndex);
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\Knob.cpp
================================================================================
#include "Knob.h"

namespace CZ101 {
namespace UI {

Knob::Knob(const juce::String& name)
    : juce::Slider(name)
{
    setSliderStyle(juce::Slider::RotaryHorizontalVerticalDrag);
    setTextBoxStyle(juce::Slider::TextBoxBelow, false, 50, 14);
    
    label.setText(name, juce::dontSendNotification);
    label.setJustificationType(juce::Justification::centred);
    label.setColour(juce::Label::textColourId, juce::Colours::white);
    label.setFont(juce::Font(12.0f));
    addAndMakeVisible(label);
}

void Knob::paint(juce::Graphics& g)
{
    juce::Slider::paint(g);
}

void Knob::resized()
{
    auto bounds = getLocalBounds();
    // Label at Top
    auto labelArea = bounds.removeFromTop(14);
    label.setBounds(labelArea);
    
    // Slider takes the rest (and puts TextBox at bottom)
    juce::Slider::resized();
}

void Knob::setLabel(const juce::String& text)
{
    labelText = text;
    label.setText(text, juce::dontSendNotification);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\Knob.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>

namespace CZ101 {
namespace UI {

class Knob : public juce::Slider
{
public:
    Knob(const juce::String& name);
    
    void paint(juce::Graphics& g) override;
    void resized() override;
    
    void setLabel(const juce::String& text);
    
private:
    juce::String labelText;
    juce::Label label;
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\MIDIActivityIndicator.cpp
================================================================================
#include "MIDIActivityIndicator.h"

namespace CZ101 {
namespace UI {

MIDIActivityIndicator::MIDIActivityIndicator()
{
    startTimer(30);
}

void MIDIActivityIndicator::paint(juce::Graphics& g)
{
    auto bounds = getLocalBounds().toFloat();
    
    g.setColour(juce::Colour(0xff2a2a2a));
    g.fillEllipse(bounds);
    
    if (brightness > 0.0f)
    {
        auto colour = juce::Colour(0xff4a9eff).withAlpha(brightness);
        g.setColour(colour);
        g.fillEllipse(bounds.reduced(2.0f));
    }
}

void MIDIActivityIndicator::timerCallback()
{
    if (isActive)
    {
        brightness = 1.0f;
        isActive = false;
    }
    else
    {
        brightness -= FADE_SPEED;
        if (brightness < 0.0f)
            brightness = 0.0f;
    }
    
    repaint();
}

void MIDIActivityIndicator::triggerActivity()
{
    isActive = true;
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\MIDIActivityIndicator.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>

namespace CZ101 {
namespace UI {

class MIDIActivityIndicator : public juce::Component, public juce::Timer
{
public:
    MIDIActivityIndicator();
    
    void paint(juce::Graphics& g) override;
    void timerCallback() override;
    
    void triggerActivity();
    
private:
    bool isActive = false;
    float brightness = 0.0f;
    
    static constexpr float FADE_SPEED = 0.1f;
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\PresetBrowser.cpp
================================================================================
#include "PresetBrowser.h"

namespace CZ101 {
namespace UI {

PresetBrowser::PresetBrowser()
{
    addAndMakeVisible(presetCombo);
    addAndMakeVisible(prevButton);
    addAndMakeVisible(nextButton);
    addAndMakeVisible(menuButton);
    
    prevButton.setButtonText("<");
    nextButton.setButtonText(">");
    menuButton.setButtonText("MENU");
    
    // updatePresetList() cannot be called here yet as manager is null
    
    presetCombo.onChange = [this]()
    {
        selectPreset(presetCombo.getSelectedItemIndex());
    };
    
    prevButton.onClick = [this]()
    {
        int current = presetCombo.getSelectedItemIndex();
        if (current > 0)
            presetCombo.setSelectedItemIndex(current - 1);
    };
    
    nextButton.onClick = [this]()
    {
        int current = presetCombo.getSelectedItemIndex();
        if (current < presetCombo.getNumItems() - 1)
            presetCombo.setSelectedItemIndex(current + 1);
    };
    
    menuButton.onClick = [this] { showMenu(); };
}

void PresetBrowser::setPresetManager(State::PresetManager* pm)
{
    presetManager = pm;
    if (presetManager)
        updatePresetList();
}

void PresetBrowser::paint(juce::Graphics& g)
{
    auto bounds = getLocalBounds().toFloat();
    
    // Glass-morphism Effect
    g.setColour(juce::Colour(0xff1a1a1a).withAlpha(0.8f));
    g.fillRoundedRectangle(bounds, 6.0f);
    
    // Gradient Sheen
    juce::ColourGradient sheen(juce::Colours::white.withAlpha(0.1f), 0.0f, 0.0f,
                               juce::Colours::transparentWhite, 0.0f, bounds.getHeight() * 0.5f, false);
    g.setGradientFill(sheen);
    g.fillRoundedRectangle(bounds, 6.0f);
    
    // Border
    g.setColour(juce::Colours::white.withAlpha(0.15f));
    g.drawRoundedRectangle(bounds, 6.0f, 1.0f);
}

void PresetBrowser::resized()
{
    auto bounds = getLocalBounds().reduced(5);
    
    // Left: MENU (60px)
    menuButton.setBounds(bounds.removeFromLeft(60));
    bounds.removeFromLeft(5);
    
    // Nav Buttons
    prevButton.setBounds(bounds.removeFromLeft(30));
    bounds.removeFromLeft(5);
    nextButton.setBounds(bounds.removeFromRight(30));
    bounds.removeFromRight(5);
    
    presetCombo.setBounds(bounds);
}

void PresetBrowser::showMenu()
{
    juce::PopupMenu m;
    m.addSectionHeader("Bank Management");
    m.addItem(1, "Init Bank (Factory Reset)");
    m.addSeparator();
    m.addItem(2, "Load Bank (.json)...");
    m.addItem(3, "Save Bank (.json)...");
    
    m.showMenuAsync(juce::PopupMenu::Options().withTargetComponent(&menuButton),
        [this](int result)
        {
            if (result == 1) initBank();
            else if (result == 2) loadBank();
            else if (result == 3) saveBank();
        });
}

void PresetBrowser::initBank()
{
    if (!presetManager) return;

    // Show confirmation dialog
    juce::AlertWindow::showOkCancelBox(
        juce::AlertWindow::WarningIcon,
        "Reset Bank",
        "Are you sure? This will replace all presets with factory defaults.",
        "Reset",
        "Cancel",
        nullptr,
        juce::ModalCallbackFunction::create([this](int result)
        {
            // result == 1 means OK/Reset pressed
            if (result == 1)
            {
                presetManager->resetToFactory();
                updatePresetList();
                selectPreset(0);
            }
        })
    );
}

void PresetBrowser::loadBank()
{
    if (!presetManager) return;
    fileChooser = std::make_unique<juce::FileChooser>("Load Bank", juce::File::getSpecialLocation(juce::File::userDocumentsDirectory), "*.json");
    
    auto flags = juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles;
    fileChooser->launchAsync(flags, [this](const juce::FileChooser& fc)
    {
        auto file = fc.getResult();
        if (file.existsAsFile())
        {
            presetManager->loadBank(file);
            updatePresetList();
            selectPreset(0); // Go to first preset
        }
    });
}

void PresetBrowser::saveBank()
{
    if (!presetManager) return;
    fileChooser = std::make_unique<juce::FileChooser>("Save Bank", juce::File::getSpecialLocation(juce::File::userDocumentsDirectory), "*.json");
    
    auto flags = juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::warnAboutOverwriting;
    fileChooser->launchAsync(flags, [this](const juce::FileChooser& fc)
    {
        auto file = fc.getResult();
        if (file != juce::File())
        {
            presetManager->saveBank(file);
        }
    });
}

void PresetBrowser::updatePresetList()
{
    presetCombo.clear();
    
    if (presetManager == nullptr) return;
    
    const auto& presets = presetManager->getPresets();
    for (size_t i = 0; i < presets.size(); ++i)
    {
        presetCombo.addItem(presets[i].name, static_cast<int>(i) + 1);
    }
    
    presetCombo.setSelectedItemIndex(0);
}

void PresetBrowser::selectPreset(int index)
{
    if (presetManager)
        presetManager->loadPreset(index);

    if (onPresetSelected)
        onPresetSelected(index);
}

int PresetBrowser::getSelectedItemIndex() const
{
    return presetCombo.getSelectedItemIndex();
}

void PresetBrowser::setSelectedItemIndex(int index)
{
    presetCombo.setSelectedItemIndex(index);
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\PresetBrowser.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>
#include "../../State/PresetManager.h"

namespace CZ101 {
namespace UI {

class PresetBrowser : public juce::Component
{
public:
    PresetBrowser();
    void setPresetManager(State::PresetManager* pm);
    
    void paint(juce::Graphics& g) override;
    void resized() override;
    
    std::function<void(int)> onPresetSelected;
    std::function<void()> onSaveRequested;
    
    // Exposed for Editor
    void updatePresetList();
    int getSelectedItemIndex() const;
    void setSelectedItemIndex(int index);
    
private:
    State::PresetManager* presetManager = nullptr;
    juce::ComboBox presetCombo;
    juce::TextButton prevButton;
    juce::TextButton nextButton;
    juce::TextButton saveButton;
    
    // Bank Management
    juce::TextButton menuButton;
    std::unique_ptr<juce::FileChooser> fileChooser;
    
    void showMenu();
    void initBank();
    void loadBank();
    void saveBank();
    
    // void updatePresetList(); // Moved to public
    void selectPreset(int index);
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\WaveformDisplay.cpp
================================================================================
#include "WaveformDisplay.h"
#include <cmath>

namespace CZ101 {
namespace UI {

WaveformDisplay::WaveformDisplay()
{
    waveformData.resize(256);
    generateWaveform();
    startTimer(50);
}

void WaveformDisplay::paint(juce::Graphics& g)
{
    auto bounds = getLocalBounds().toFloat();
    
    g.fillAll(juce::Colour(0xff1a1a1a));
    
    g.setColour(juce::Colour(0xff2a2a2a));
    g.drawRect(bounds, 2.0f);
    
    juce::Path path;
    auto width = bounds.getWidth();
    auto height = bounds.getHeight();
    auto centerY = bounds.getCentreY();
    
    path.startNewSubPath(bounds.getX(), centerY);
    
    for (size_t i = 0; i < waveformData.size(); ++i)
    {
        float x = bounds.getX() + (i / static_cast<float>(waveformData.size())) * width;
        float y = centerY - waveformData[i] * (height * 0.4f);
        path.lineTo(x, y);
    }
    
    g.setColour(juce::Colour(0xff4a9eff));
    g.strokePath(path, juce::PathStrokeType(2.0f));
}

void WaveformDisplay::timerCallback()
{
    repaint();
}

void WaveformDisplay::setWaveform(int waveformType)
{
    currentWaveform = waveformType;
    generateWaveform();
}

void WaveformDisplay::pushBuffer(const juce::AudioBuffer<float>& buffer)
{
    // Simple circular buffer or just grab the first channel's chunk for visualization
    auto* channelData = buffer.getReadPointer(0);
    int numSamples = buffer.getNumSamples();
    
    for (int i = 0; i < numSamples; ++i)
    {
        // Simple ring buffer push
        waveformData[writePos] = channelData[i];
        writePos = (writePos + 1) % waveformData.size();
    }
}

void WaveformDisplay::generateWaveform() 
{
    // No-op or clear, as we use live data now
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Components\WaveformDisplay.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_audio_basics/juce_audio_basics.h> // For AudioBuffer
#include <vector>

namespace CZ101 {
namespace UI {

class WaveformDisplay : public juce::Component, public juce::Timer
{
public:
    WaveformDisplay();
    
    void paint(juce::Graphics& g) override;
    void timerCallback() override;
    
    void setWaveform(int waveformType);
    void pushBuffer(const juce::AudioBuffer<float>& buffer);
    
private:
    std::vector<float> waveformData;
    int currentWaveform = 0;
    int writePos = 0;
    
    void generateWaveform();
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Overlays\NameEditorOverlay.cpp
================================================================================
#include "NameEditorOverlay.h"

namespace CZ101 {
namespace UI {

NameEditorOverlay::NameEditorOverlay()
{
    addAndMakeVisible(titleLabel);
    titleLabel.setText("RENAME PRESET", juce::dontSendNotification);
    titleLabel.setJustificationType(juce::Justification::centred);
    titleLabel.setColour(juce::Label::textColourId, juce::Colours::cyan);
    
    addAndMakeVisible(nameEditor);
    nameEditor.setJustification(juce::Justification::centred);
    
    addAndMakeVisible(saveButton);
    addAndMakeVisible(cancelButton);
    
    saveButton.addListener(this);
    cancelButton.addListener(this);
    
    // Enter key support
    nameEditor.onReturnKey = [this] { buttonClicked(&saveButton); };
    nameEditor.onEscapeKey = [this] { buttonClicked(&cancelButton); };
}

NameEditorOverlay::~NameEditorOverlay()
{
    saveButton.removeListener(this);
    cancelButton.removeListener(this);
}

void NameEditorOverlay::paint(juce::Graphics& g)
{
    // Semi-transparent background for the whole component
    g.fillAll(juce::Colours::black.withAlpha(0.6f));
    
    // Dialog box
    auto bounds = getLocalBounds().toFloat();
    // Create a 300x150 rectangle centered in bounds
    auto dialogRect = juce::Rectangle<float>(300, 150).withCentre(bounds.getCentre());
    
    g.setColour(juce::Colour(0xff2a2a2a));
    g.fillRoundedRectangle(dialogRect, 10.0f);
    
    g.setColour(juce::Colours::cyan);
    g.drawRoundedRectangle(dialogRect, 10.0f, 2.0f);
}

void NameEditorOverlay::resized()
{
    auto bounds = getLocalBounds();
    auto center = bounds.getCentre();
    
    int w = 300;
    int h = 150;
    int x = center.x - w/2;
    int y = center.y - h/2;
    
    titleLabel.setBounds(x + 10, y + 10, w - 20, 30);
    nameEditor.setBounds(x + 20, y + 50, w - 40, 30);
    
    cancelButton.setBounds(x + 20, y + 100, 120, 30);
    saveButton.setBounds(x + 160, y + 100, 120, 30);
}

void NameEditorOverlay::startRename(const juce::String& currentName, std::function<void(const juce::String&)> onSaveCallback)
{
    nameEditor.setText(currentName);
    onSave = onSaveCallback;
    setVisible(true);
    toFront(true);
    nameEditor.grabKeyboardFocus();
}

void NameEditorOverlay::buttonClicked(juce::Button* b)
{
    if (b == &saveButton)
    {
        if (onSave) onSave(nameEditor.getText());
        setVisible(false);
    }
    else if (b == &cancelButton)
    {
        setVisible(false);
    }
}

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\UI\Overlays\NameEditorOverlay.h
================================================================================
#pragma once

#include <juce_gui_basics/juce_gui_basics.h>

namespace CZ101 {
namespace UI {

class NameEditorOverlay : public juce::Component,
                          private juce::Button::Listener
{
public:
    NameEditorOverlay();
    ~NameEditorOverlay() override;

    void paint(juce::Graphics& g) override;
    void resized() override;
    
    // Setup
    void startRename(const juce::String& currentName, std::function<void(const juce::String&)> onSaveCallback);
    
    // Listener
    void buttonClicked(juce::Button* b) override;

private:
    juce::Label titleLabel;
    juce::TextEditor nameEditor;
    juce::TextButton saveButton { "SAVE" };
    juce::TextButton cancelButton { "CANCEL" };
    
    std::function<void(const juce::String&)> onSave;
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(NameEditorOverlay)
};

} // namespace UI
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\DSPHelpers.h
================================================================================
#pragma once

#include <cmath>
#include <algorithm>

namespace CZ101 {
namespace Utils {

class DSPHelpers
{
public:
    static float dbToGain(float db)
    {
        return std::pow(10.0f, db / 20.0f);
    }
    
    static float gainToDb(float gain)
    {
        return 20.0f * std::log10(std::max(gain, 0.00001f));
    }
    
    static float midiNoteToFrequency(int midiNote)
    {
        return 440.0f * std::pow(2.0f, (midiNote - 69) / 12.0f);
    }
    
    static int frequencyToMidiNote(float frequency)
    {
        return static_cast<int>(69 + 12 * std::log2(frequency / 440.0f));
    }
    
    static float lerp(float a, float b, float t)
    {
        return a + t * (b - a);
    }
    
    static float clamp(float value, float min, float max)
    {
        return std::clamp(value, min, max);
    }
    
    static float mapRange(float value, float inMin, float inMax, float outMin, float outMax)
    {
        return outMin + (value - inMin) * (outMax - outMin) / (inMax - inMin);
    }
};

} // namespace Utils
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\PerformanceMonitor.cpp
================================================================================
#include "PerformanceMonitor.h"
#include <algorithm>

namespace CZ101 {
namespace Utils {

PerformanceMonitor::PerformanceMonitor()
{
}

void PerformanceMonitor::startMeasurement()
{
    startTime = std::chrono::high_resolution_clock::now();
}

void PerformanceMonitor::stopMeasurement()
{
    endTime = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(endTime - startTime);
    double timeMs = duration.count() / 1000.0;
    
    totalTime += timeMs;
    peakTime = std::max(peakTime, timeMs);
    measurementCount++;
}

double PerformanceMonitor::getAverageCpuUsage() const
{
    if (measurementCount == 0)
        return 0.0;
    
    return totalTime / measurementCount;
}

double PerformanceMonitor::getPeakCpuUsage() const
{
    return peakTime;
}

int PerformanceMonitor::getVoiceCount() const
{
    return currentVoiceCount;
}

void PerformanceMonitor::setVoiceCount(int count)
{
    currentVoiceCount = count;
}

void PerformanceMonitor::reset()
{
    totalTime = 0.0;
    peakTime = 0.0;
    measurementCount = 0;
}

} // namespace Utils
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\PerformanceMonitor.h
================================================================================
#pragma once

#include <chrono>
#include <string>

namespace CZ101 {
namespace Utils {

class PerformanceMonitor
{
public:
    PerformanceMonitor();
    
    void startMeasurement();
    void stopMeasurement();
    
    double getAverageCpuUsage() const;
    double getPeakCpuUsage() const;
    int getVoiceCount() const;
    
    void setVoiceCount(int count);
    void reset();
    
private:
    std::chrono::high_resolution_clock::time_point startTime;
    std::chrono::high_resolution_clock::time_point endTime;
    
    double totalTime = 0.0;
    double peakTime = 0.0;
    int measurementCount = 0;
    int currentVoiceCount = 0;
};

} // namespace Utils
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\SmoothedValue.h
================================================================================
#pragma once

#include <cmath>

namespace CZ101 {
namespace Utils {

template<typename FloatType>
class SmoothedValue
{
public:
    SmoothedValue() = default;
    
    void reset(FloatType initialValue) noexcept
    {
        currentValue = initialValue;
        target = initialValue;
    }
    
    void setTargetValue(FloatType newTarget) noexcept
    {
        target = newTarget;
    }
    
    void setSmoothingTime(FloatType timeInSeconds, double sampleRate) noexcept
    {
        auto numSamples = static_cast<int>(timeInSeconds * sampleRate);
        setNumSteps(numSamples);
    }
    
    void setNumSteps(int numSteps) noexcept
    {
        stepsToTarget = numSteps;
        countdown = stepsToTarget;
        
        if (countdown > 0)
            step = (target - currentValue) / static_cast<FloatType>(countdown);
        else
            step = 0;
    }
    
    FloatType getNextValue() noexcept
    {
        if (countdown <= 0)
        {
            currentValue = target;
            return currentValue;
        }
        
        --countdown;
        currentValue += step;
        return currentValue;
    }
    
    FloatType getCurrentValue() const noexcept
    {
        return currentValue;
    }
    
    FloatType getTargetValue() const noexcept
    {
        return target;
    }
    
    bool isSmoothing() const noexcept
    {
        return countdown > 0;
    }

private:
    FloatType currentValue = 0;
    FloatType target = 0;
    FloatType step = 0;
    int countdown = 0;
    int stepsToTarget = 0;
};

} // namespace Utils
} // namespace CZ101

================================================================================
FILE: .\Source\Utils\StringHelpers.h
================================================================================
#pragma once

#include <string>
#include <sstream>
#include <iomanip>

namespace CZ101 {
namespace Utils {

class StringHelpers
{
public:
    static std::string formatFrequency(float hz)
    {
        std::ostringstream oss;
        if (hz >= 1000.0f)
            oss << std::fixed << std::setprecision(2) << (hz / 1000.0f) << " kHz";
        else
            oss << std::fixed << std::setprecision(1) << hz << " Hz";
        return oss.str();
    }
    
    static std::string formatTime(float seconds)
    {
        std::ostringstream oss;
        if (seconds >= 1.0f)
            oss << std::fixed << std::setprecision(2) << seconds << " s";
        else
            oss << std::fixed << std::setprecision(1) << (seconds * 1000.0f) << " ms";
        return oss.str();
    }
    
    static std::string formatPercentage(float value)
    {
        std::ostringstream oss;
        oss << std::fixed << std::setprecision(1) << (value * 100.0f) << "%";
        return oss.str();
    }
    
    static std::string formatDecibels(float db)
    {
        std::ostringstream oss;
        oss << std::fixed << std::setprecision(1) << db << " dB";
        return oss.str();
    }
};

} // namespace Utils
} // namespace CZ101
